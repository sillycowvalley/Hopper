program Optimize
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define DIAGNOSTICS  
      
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    uses "CodeGen/Asm6502"
    
    uses "CodeModel/AsmPoints"
    
    bool verbose;
    bool showSizes;
    bool isExperimental;
    bool IsExperimental { get { return isExperimental; }}
    
    <string,variant> symbols;
    <uint,bool> methodsCalled;
    
    uint romSize;
    uint romAddress;
    
    uint irqIndex;
    bool irqExists;
    uint nmiIndex;
    bool nmiExists;
    
    
    <string> outputLinesRemoved;
    <string> outputLinesSizes;
    uint     totalBytesRemoved;
    uint     totalMethodsRemoved;
    uint     totalMethodBytes;
    
    
    const uint progressSteps = 256;
    uint progressInstructions;
    ProgessNudge()
    {
        progressInstructions++;
        if ((progressInstructions % progressSteps) == 0)
        {
            Parser.ProgressTick("o"); // optimizer
        }
    }
    
    CheckTarget()
    {
        romSize = 0x8000;
        foreach (var kv in symbols)
        {
            if (kv.key == "symbols")
            {
                // preprocessor symbols
                <string,string> pdValues = kv.value;
                if (pdValues.Contains("CPU_6502"))
                {
                    Architecture = CPUArchitecture.M6502;
                }
                if (pdValues.Contains("CPU_65C02S"))
                {
                    Architecture = CPUArchitecture.W65C02;
                }
                if (pdValues.Contains("ROM_32K"))
                {
                    romSize = 0x8000;
                }
                if (pdValues.Contains("ROM_16K"))
                {
                    romSize = 0x4000;
                }
                if (pdValues.Contains("ROM_8K"))
                {
                    romSize = 0x2000;
                }
                if (pdValues.Contains("ROM_4K"))
                {
                    romSize = 0x1000;
                }
                if (pdValues.Contains("ROM_1K"))
                {
                    romSize = 0x0400;
                }
                break;
            }
        } // kv
        long startAddress = 0x10000 - romSize; 
        romAddress = uint(startAddress);
    }
    
    bool RemoveUnreachableMethods()
    {
        if (verbose)
        {
            ReportUnreachable();
        }
        
        bool removed;
        <string, <string,variant> > debugSymbols = GetDebugSymbols();
        <string, <string,variant> > newDebugSymbols;
        foreach (var methodCall in methodsCalled)
        {
            uint methodIndex = methodCall.key;
            if (methodCall.value || (methodIndex == 0) || (irqExists && (methodIndex == irqIndex)) || (nmiExists && (methodIndex == nmiIndex)))
            {
                 string index = "0x" + methodIndex.ToHexString(4);
                 newDebugSymbols[index] = debugSymbols[index];
            }
            else
            {
                removed = true;
            }
        }
        if (removed)
        {
            if (debugSymbols.Contains("globals"))
            {
                newDebugSymbols["globals"] = debugSymbols["globals"];
            }
            SetDebugSymbols(newDebugSymbols);
            
        }
        return removed;
    }
    
    ReportMethodSizes()
    {
        outputLinesSizes.Clear();
        totalMethodBytes = 0;
        
        foreach (var methodCall in methodsCalled)
        {
            uint methodIndex = methodCall.key;
            bool isCalled = methodCall.value || 
                            (methodIndex == 0); // "main" is an exception
            <byte> code = Code.GetMethodCode(methodIndex);
            uint  sizeInBytes = code.Count;
            string methodName = Code.GetMethodName(methodIndex);
            string sizeString = sizeInBytes.ToString();
            if (!isCalled)
            {
                continue;
            }
            outputLinesSizes.Append("  " + methodName.Pad(' ', 40) + sizeString.LeftPad(' ', 5));  
            totalMethodBytes = totalMethodBytes +  sizeInBytes;
        }
    }
    ReportUnreachable()
    {
        foreach (var methodCall in methodsCalled)
        {
            uint methodIndex = methodCall.key;
            bool isCalled = methodCall.value || 
                            (methodIndex == 0); // "main" is an exception
            <byte> code = Code.GetMethodCode(methodIndex);
            uint sizeInBytes = code.Count;
            string methodName = Code.GetMethodName(methodIndex);
            string sizeString = sizeInBytes.ToString();
            if (isCalled)
            {
                continue;
            }
            outputLinesRemoved.Append("  " + methodName.Pad(' ', 40) + sizeString.LeftPad(' ', 5));  
            totalBytesRemoved = totalBytesRemoved +  sizeInBytes;
            totalMethodsRemoved++;
        }
    }
    
    bool Optimize(uint pass, ref long codeBefore, ref long codeAfter)
    {
        //PrintLn("Optimize: " + pass.ToString());
        
        bool modified = false;
        <uint> indices = Code.GetMethodIndices();
        methodsCalled.Clear();
        <uint, bool> methodsWalked;
        foreach (var index in indices)
        {
            methodsCalled[index] = false;
            methodsWalked[index] = false;
        }
        codeAfter = 0;
        
        AsmPoints.Reset(); 
        
        uint methodIndex = 0; // "main"
        methodsCalled[methodIndex] = true; // "main"
        if (irqExists)
        {
            methodsCalled[irqIndex] = true;
        }
        if (nmiExists)
        {
            methodsCalled[nmiIndex] = true;
        }
        
        loop
        {
            methodsWalked[methodIndex] = true;
            uint size = AsmPoints.Load(methodIndex, "before pass " + pass.ToString());
            if (pass == 0)
            {
                codeBefore += size;
            }
            AsmPoints.MarkInstructions();
            
            // BRA|JMP to BRA|JMP -> BRA|JMP
            if (AsmPoints.OptimizeJMPJMP())
            {
                modified = true;
            }
            
            // removing JMP -> JMP + 1, can cause more short JumpToJump's to work
            if (AsmPoints.OptimizeRemoveJMPJMPs())
            {
                modified = true;
            }
            if (Architecture == CPUArchitecture.W65C02)
            {
                // JMP -> BRA
                if (AsmPoints.OptimizeJMP())
                {
                    modified = true;
                }
                if (AsmPoints.OptimizeLDASTAtoSTZ())
                {
                    modified = true;
                }
                if (AsmPoints.OptimizeSMBandRMB())
                {
                    modified = true;
                }
                // BEQ BRA -> BNE (for example)
                if (AsmPoints.OptimizeBEQBRA())
                {
                    modified = true;
                }
            }
            else
            {
                // BEQ JMP -> BNE (for example)
                if (AsmPoints.OptimizeBEQJMP())
                {
                    modified = true;
                }   
            }
            // BRA|JMP to RTS - > RTS
            if (AsmPoints.OptimizeJMPRTS())
            {
                modified = true;
            }
            // RTS|RTS to RTS - > RTS
            if (AsmPoints.OptimizeRTSRTS())
            {
                modified = true;
            }
            
            if (irqExists && (methodIndex == irqIndex))
            {
                // skip    
            }
            else if (nmiExists && (methodIndex == nmiIndex))
            {
                // skip    
            }
            else // TODO: // JSR|RTI - > iJMP .. RTI
            {
                // JSR|RTS - > iJMP
                if (AsmPoints.OptimizeJSRRTS())
                {
                    modified = true;
                }
            }
            if (AsmPoints.OptimizeCMP())
            {
                modified = true;
            }
            
            
            // TODO:
            //
            // 1. check for LDA|X|Y #0 followed by STA|X|Y and replace with STZ on W65C02
            //
            // 2. CMP #0 after LDA, LDX, LDY, INC, INX, INY, DEC, DEX, DEY, INA, DEA, AND, ORA, EOR, ASL, LSR, ROL, 
            //              ROR, PLA, PLX, PLY, SBC, ADC, TAX, TXA, TAY, TYA, and TSX
            // is redundant if checking Z or V. They all set the Z and V flags. C is a different story.
            
            
            
            
            if (pass > 0) // allow inlining to happen first
            {
                if (AsmPoints.OptimizeUnreachableToNOP())
                {
                    modified = true;
                }
                // remove NOPs : should be last OptimizeXXX
                if (AsmPoints.OptimizeRemoveNOPs())
                {
                    modified = true;
                }
            }
            
            AsmPoints.CollectMethodCalls(methodsCalled);
            
            size = AsmPoints.Save();
            codeAfter = codeAfter + size;
            ProgessNudge();
            
            bool walkNextMethod;
            foreach (var kv in methodsCalled)
            {
                bool isCalled = kv.value;
                if (isCalled)
                {
                    uint iMethod = kv.key;
                    if (!methodsWalked.Contains(iMethod))
                    {
                        PrintLn("Pass:" + pass.ToString() + " " + iMethod.ToHexString(4));
                    }
                    if (!methodsWalked[iMethod])
                    {
                        // called but not yet walked
                        methodIndex = iMethod;
                        walkNextMethod = true;
                        break;
                    }
                }
            }
            if (!walkNextMethod) // no more to walk
            {
                break;
            }
        } // loop
        
        if (RemoveUnreachableMethods())
        {
            modified = true;
        }
        if (showSizes)
        {
            ReportMethodSizes();
        }
        methodsCalled.Clear(); // just to be sure 
        
        return modified;
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for AsmOpt:");
        PrintLn("  ASMOPT <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -v         : verbose output");
        PrintLn("    -t         : method size after optimization");
        PrintLn("    -x         : experimental");
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-v":
                        {
                            verbose = true;
                        }
                        case "-t":
                        {
                            showSizes = true;
                        }
                        case "-x":
                        {
                            isExperimental = true;
                        }
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                BadArguments();
                break;
            }
            
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                BadArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                if (!Code.ParseCode(codePath, true, true))
                {
                    break;
                }
                long codeBefore;
                long codeAfter;
                string optPath = codePath;
                string symbolsPath = codePath.Replace(extension, ".sym");
                string verbosePath = codePath.Replace(extension, ".txt");
                
                if (File.Exists(symbolsPath))
                {
                    if (JSON.Read(symbolsPath, ref symbols))
                    {
                        CheckTarget();
                    }
                }
                
                string hopperMethod = Code.GetMethodName(0);
                string irqMethod = hopperMethod.Replace(".Hopper", ".IRQ");
                string nmiMethod = hopperMethod.Replace(".Hopper", ".NMI");
                if (Code.MethodExists(irqMethod))
                {
                    irqIndex = Code.GetMethodIndex(irqMethod);
                    irqExists  = true;
                }
                if (Code.MethodExists(nmiMethod))
                {
                    nmiIndex = Code.GetMethodIndex(nmiMethod);
                    nmiExists  = true;
                }
                
                uint pass = 0;
                loop
                {
                    if (!Optimize(pass, ref codeBefore, ref codeAfter))
                    {
                        break;
                    }
                    pass++;
                }
                               
                File.Delete(optPath);
                if (!Code.ExportCode(optPath)) // after
                {
                    break;
                }
                success = true;
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    if (verbose || showSizes)
                    {
                        file logFile = File.Create(verbosePath);
                        bool addNewLine;
                        if (outputLinesSizes.Count != 0)
                        {
                            string content = "Method sizes after optimization:";
                            logFile.Append(content + Char.EOL);
                            PrintLn(content);
                            uint count;
                            foreach (var str in outputLinesSizes)
                            {
                                logFile.Append(str + Char.EOL);
                                PrintLn(str);
                                count++;
                            }
                            string space;
                            string sizeString = totalMethodBytes.ToString();
                            content = space.Pad(' ', 42) + sizeString.LeftPad(' ', 5) +
                                      " (" + count.ToString() + " methods)";
                            logFile.Append(content + Char.EOL);
                            PrintLn(content);
                            addNewLine = true;
                        }
                        if (totalMethodsRemoved > 0)
                        {
                            if (addNewLine)
                            {
                                logFile.Append("" + Char.EOL);
                                PrintLn();
                            }
                            string content = "Unreachable Code (includes inlined and removed):";
                            logFile.Append(content + Char.EOL);
                            PrintLn(content);
                            foreach (var str in outputLinesRemoved)
                            {
                                logFile.Append(str + Char.EOL);
                                PrintLn(str);
                            }
                            string space;
                            string sizeString = totalBytesRemoved.ToString();
                            content = space.Pad(' ', 42) + sizeString.LeftPad(' ', 5) +
                                      " (" + totalMethodsRemoved.ToString() + " methods)";
                            logFile.Append(content + Char.EOL);
                            PrintLn(content);
                        }
                        <string,variant> gValues;
                        foreach (var kv in symbols)
                        {
                            if (kv.key == "globals")
                            {
                                // globals
                                gValues = kv.value;
                                break;
                            }
                        } // kv
                        logFile.Flush();
                    }
                    Print("Success, " + codeBefore.ToString() + "->" + codeAfter.ToString() + " bytes of code,", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                
                break;
            }
            break;
        } // loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }   
    } // Hopper()
}
