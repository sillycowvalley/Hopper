program PreProcess
{
    //#define EXPERIMENTAL
    
    // Turned off JSON_EXPRESS so we'll see errors in 'configuration.options'
    // #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    
    uses "/Source/System/System"
    uses "/Source/System/Diagnostics"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    uses "Tokens/SysCalls"
    uses "Tokens/LibCalls"
    
    uses "Symbols"
    uses "Constant"
    uses "Directives" 
    
    uses "JSON/Configuration"
    
    bool isExperimental;
    bool IsExperimental { get { return isExperimental; } set { isExperimental = value; } }
    bool isVerbose;
    bool IsVerbose { get { return isVerbose; } set { isVerbose = value; } }
    
    bool isZ80;
    bool IsZ80      { get { return isZ80; }      set { isZ80 = value; } }
    bool isAssembly;
    bool IsAssembly { get { return isAssembly; } set { isAssembly = value; } }
    
    bool IsDebugger  { get { return false; } }
    
    bool NoPackedInstructions { get { return false; } } // to keep peephole code happy (even though it is not used)
    
    // Documentation:
    // - documentation comments
    // - .json to .md conversion? .pdf conversion?
    // Future:
    // - drop << and >> tokens? synthesize them when needed? or, deal with them in the context of types?
    // - block comments aware of strings ("...*/...")
    
    string projectPath;
    <string, bool> unitsParsed;
    string programNamespace;
    
    bool normalizeIdentifier(<string,string> idToken, ref string identifier, ref bool public, bool noDuplicates)
    {
        bool success = false;
        loop
        {
            identifier = idToken["lexeme"];
            if (identifier.Contains('.'))
            {
                Parser.ErrorAtCurrent("simple identifier expected");           
                break;
            }
            if (Token.IsReservedWord(identifier))
            {
                Parser.ErrorAtCurrent("identifier '" + identifier + "' is a reserved word");
                break;
            }
            public = Char.IsUpper(identifier[0]);
            identifier = CurrentNamespace + "." + identifier; // append current namespace
            if (noDuplicates)
            {
                if (Symbols.GlobalExists(identifier))
                {
                    Parser.ErrorAtCurrent("identifier already in use");
                    break;
                }
            }
            success = true;
            break;
        }
        return success;
    }
    
    bool isValueType(string typeName)
    {
        bool found;
        loop
        {
            string valueTypes = "|bool|byte|char|uint|int|type|";
            typeName = "|" + typeName + "|";
            if (valueTypes.Contains(typeName))
            {
                found = true;
                break;
            }
            break;
        }
        return found;
    }
    
    bool tryParseTypeString(ref string typeString, ref bool deferred, bool allowEmptyConstArrays)
    {
        bool genericKAllowed = (CurrentNamespace == "Dictionary") || (CurrentNamespace == "Pair");
        bool genericVAllowed = genericKAllowed || (CurrentNamespace == "Array") || (CurrentNamespace == "List");  
        
        bool success = false;
        
        deferred = false;
        loop
        {
            bool isSimple = false;
            <string,string> typeToken = Parser.CurrentToken;
            if (Parser.CheckKeyword("|bool|byte|char|uint|int|long|float|string|type|variant|file|directory|"))
            {
                isSimple = true;
            }
            if (Parser.Check(HopperToken.Identifier) || Parser.Check(HopperToken.DottedIdentifier))
            {
                if (genericKAllowed && (typeToken["lexeme"] == "K"))
                {
                    isSimple = true;
                }
                else if (genericVAllowed && (typeToken["lexeme"] == "V"))
                {
                    isSimple = true;
                }
                else
                {
                    isSimple = true; // on first pass, just assume it is a valid named value type
                    
                    string name = typeToken["lexeme"];
                    if (!name.Contains('.') && name[0].IsLower())
                    {
                        // if it is a local named value type, it helps to qualify it for future resolution
                        typeToken["lexeme"] = CurrentNamespace + "." + typeToken["lexeme"];
                    }
                    Symbols.DeferValidation(typeToken);
                    deferred = true;
                }
            }
            if (isSimple)
            {
                // simple type
                success = true;
                typeString = typeString + typeToken["lexeme"];
                Parser.Advance();
                bool arrayUnitV = false;
                bool systemByteArray = false;
                if (Parser.Check(HopperToken.LBracket))
                {
                    // like byte[8192]
                    if (!IsValueType(typeString))
                    {
                        if ((CurrentNamespace == "Array") && (typeString == "V"))
                        {
                            // V[] for "this"
                            arrayUnitV = true;
                        }
                        else
                        {
                            Parser.ErrorAtCurrent("arrays can only contain value types");
                            success = false;
                            break;   
                        }
                    }
                    else if (   (CurrentNamespace == "System") 
                             || (CurrentNamespace == "Runtime") 
                             || (CurrentNamespace == "Wire") 
                             || (CurrentNamespace == "SPI")
                             || allowEmptyConstArrays
                               ) 
                    {
                        byte upperBound;
                        systemByteArray = Types.IsByteRange(typeString, ref upperBound);
                        if (upperBound != 0)
                        {
                            deferred = false; // enum or flags is already defined
                        }
                    }
                    
                    Parser.Advance(); // [
                    typeString = typeString + "[";
                    string value;
                    if (Parser.Check(HopperToken.RBracket))
                    {
                        // empty array range 
                    }
                    else
                    {
                        string actualType;
                        value = ParseConstantExpression("uint", ref actualType);
                    }
                    typeString = typeString + value;   
                    if (!Parser.Check(HopperToken.RBracket))
                    {
                        Parser.ErrorAtCurrent(']');
                        success = false;
                        break;
                    }
                    Parser.Advance(); // ]   
                    typeString = typeString + "]";
                    
                    break;
                }
            }
            else if (Parser.Check(HopperToken.LT))
            {
                Parser.Advance(); // <
                // <byte> and <string,byte>
                typeString = typeString + "<";
                bool memberDeferred;
                success = tryParseTypeString(ref typeString, ref memberDeferred, false); // dictionary key
                if (success)
                {
                    if (memberDeferred)
                    {
                        // TODO ?
                    }
                    if (Parser.Check(HopperToken.Comma))
                    {
                        // TODO: make <byte,byte,byte> illegal
                        Parser.Advance(); // ,
                        typeString = typeString + ",";       
                        success = tryParseTypeString(ref typeString, ref memberDeferred, false); // dictionary value
                        if (success && memberDeferred)
                        {
                            // TODO ?
                        }
                        
                    }
                }
                if (success)
                {
                    if (!Parser.Check(HopperToken.GT))
                    {
                        Parser.ErrorAtCurrent('>');
                        success = false;
                        break;
                    }
                    Parser.Advance(); // >
                    typeString = typeString + ">";
                }
            }
            break;
        }
        return success;
    }
  
    <string> walkBlock()
    {
      <string> blockPos;
      loop
      {
          bool isSystem = false;
          bool isInline = false;
          bool isNoOpt  = false;
          if (Parser.CheckKeyword("|system|library|"))
          {
              isSystem = true;
          }
          else if (IsAssembly && Parser.CheckKeyword("inline"))
          {
              isInline = true;
              // Advance past "inline" to get to the "{"
              Parser.Advance();
              if (!Parser.Check(HopperToken.LBrace))
              {
                  Parser.ErrorAtCurrent("'{' expected after 'inline'");
                  break;
              }
          }
          else if (IsAssembly && Parser.CheckKeyword("noopt"))
          {
              isNoOpt = true;
              // Advance past "noopt" to get to the "{"
              Parser.Advance();
              if (!Parser.Check(HopperToken.LBrace))
              {
                  Parser.ErrorAtCurrent("'{' expected after 'noopt'");
                  break;
              }
          }
          else if (!Parser.Check(HopperToken.LBrace))
          {
              Parser.ErrorAtCurrent('{');
              break;
          }
          <string,string> currentToken = Parser.CurrentToken;
          long pos;
          if (Long.TryParse(currentToken["pos"], ref pos))
          {
          }
          if (isSystem)
          {
              // zero pos implies no source (syscall or libcall)
              blockPos.Append("0");
              blockPos.Append(currentToken["line"]);
              blockPos.Append(currentToken["source"]);
          }
          else if (isInline || isNoOpt)
          {
              // inline methods have source code, but marked specially
              blockPos.Append(pos.ToString());
              blockPos.Append(currentToken["line"]);
              blockPos.Append(currentToken["source"]);
              if (isInline)
              {
                  blockPos.Append("inline"); // add marker for inline
              }
              if (isNoOpt)
              {
                  blockPos.Append("noopt"); // add marker for inline
              }
          }
          else
          {
              blockPos.Append(pos.ToString());
              blockPos.Append(currentToken["line"]);
              blockPos.Append(currentToken["source"]);
          }
          Parser.Advance();
          if (isSystem)
          {
              Parser.Consume(HopperToken.SemiColon);
              break;
          }
          int nested = 1;
          loop
          {
              if (HadError)
              {
                  Parser.ErrorAtCurrent('}');
                  break;
              }
              if (Parser.Check(HopperToken.RBrace))
              {
                  Parser.Advance(); // }
                  nested--;
                  if (nested == 0)
                  {
                      break;
                  }
                  continue;
              }
              if (Parser.Check(HopperToken.LBrace))
              {
                  // nested { .. }
                  nested++;
              }
              Parser.Advance(); // anything else
          }
          break;
        }
        return blockPos;      
    }
    
    friendDeclaration()
    {
        
        Parser.Advance(); // friend
        loop
        {
            Parser.Consume(HopperToken.Identifier, "Unit name identifier expected");
            if (Parser.HadError)
            {
                break;
            }
            <string,string> previousToken = Parser.PreviousToken;
            
            Symbols.AddFriend(previousToken["lexeme"], CurrentNamespace); 
            
            if (Parser.Check(HopperToken.Comma))
            {
                Parser.Advance(); // ,
                continue;
            }
            Parser.Consume(HopperToken.SemiColon);
            break;   
        }
    }

    constDeclaration()
    {
        string typeString;   
        loop
        {
            Parser.Advance(); // const
            bool deferred;
            if (!tryParseTypeString(ref typeString, ref deferred, true) || deferred) // constDeclaration
            {
                Parser.ErrorAtCurrent("simple type expected");
                break;
            }
            if (   (!IsValueType(typeString) && (typeString != "float") && (typeString != "long") && (typeString != "string") && !IsInferredByteArray(typeString))
                || (typeString == "delegate")) 
            {
                Parser.ErrorAtCurrent("simple type expected");
                break;
            }   
                        
            <string,string> idToken = Parser.CurrentToken;
            string identifier;
            bool public;
            if (!normalizeIdentifier(idToken, ref identifier, ref public, true)) // noDuplicates
            {
                break;   
            }
            Parser.Advance(); // identifier
            string actualType;
            string value;
            if (IsAssembly && Parser.Check(HopperToken.SemiColon))
            {
                Parser.Advance(); // consume ';'
                // Validate it's an enum array type
                if (!typeString.EndsWith("[]"))
                {
                    Parser.ErrorAtCurrent("uninitialized const requires array type");
                    break;
                }
                string elementType = typeString.Substring(0, typeString.Length - 2);
                if (!Types.IsEnum(elementType))
                {
                    Parser.ErrorAtCurrent("uninitialized const array requires enum type");
                    break;
                }
                // Create 256-byte string of zeros
                for (uint i = 0; i < 256; i++)
                {
                    value = value + char(0);
                }
                actualType = elementType + "[256]";
            }
            else
            {
                Parser.Consume(HopperToken.Assign);
                if (HadError)
                {
                    break;
                }    
                
                value = ParseConstantExpression(typeString, ref actualType);
                if (HadError)
                {
                    break;
                }
                Parser.Consume(HopperToken.SemiColon);
            }
            string constantName = CurrentNamespace + "." + idToken["lexeme"];
            Symbols.AddConstant(constantName, actualType, value);   
            Symbols.AddLocation(constantName, idToken["source"] + ":" + idToken["line"]);
            break;                                 
       }          
        
    }
    recordDeclaration()
    {
        loop
        {
            Parser.Advance(); // record
            
            if (!Parser.Check(HopperToken.Identifier) || Parser.Check(HopperToken.DottedIdentifier))
            {
                Parser.ErrorAtCurrent("identifier expected");       
                break;
            }
            <string,string> idToken = Parser.CurrentToken;
            string identifier;
            bool public;
            if (!normalizeIdentifier(idToken, ref identifier, ref public, true))
            {
                break;   
            }
            Symbols.AddLocation(identifier, idToken["source"] + ":" + idToken["line"]);
            
            Parser.Advance(); // identifier           
            if (!Parser.Check(HopperToken.LBrace))
            {
                Parser.ErrorAtCurrent('{');
                break;
            }
            Parser.Advance(); // {
            
            <string> memberNames;
            < <string> > members;
            
            loop
            {
                if (Parser.Check(HopperToken.RBrace))
                {
                    Parser.Advance(); // }
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent("unexpected end of file in record declaration");
                    break;
                }   
                
                string typeString;   
                bool deferred;
                if (!tryParseTypeString(ref typeString, ref deferred, false))
                {
                    if (!HadError)
                    {
                        Parser.ErrorAtCurrent("type expected");
                    }
                    break;
                }
                if (!Parser.Check(HopperToken.Identifier))
                {
                    Parser.ErrorAtCurrent("identifier expected");   
                    break;
                }  
                <string,string> memberToken = Parser.CurrentToken;
                string memberName = memberToken["lexeme"];
                Parser.Advance(); // memberName  
                if (memberNames.Contains(memberName))
                {
                    Parser.ErrorAtCurrent("duplicate member name in record");   
                    break;
                }
                memberNames.Append(memberName);
                <string> member;
                member.Append(memberName);
                member.Append(typeString);
                members.Append(member);                
                
                Symbols.AddLocation(identifier + "." + memberName, memberToken["source"] + ":" + memberToken["line"]);
                
                if (!Parser.Check(HopperToken.SemiColon))
                {
                    Parser.ErrorAtCurrent(';');
                    break;
                }
                Parser.Advance(); // ;
            } // loop
                    
            if (HadError)
            {
                break;
            }
            Symbols.AddRecord(identifier, members);
            break;
        } // loop
    }
    
    enumDeclaration(bool isFlags)
    {
        loop
        {
            Parser.Advance(); // enum | flags
            
            if (!Parser.Check(HopperToken.Identifier) || Parser.Check(HopperToken.DottedIdentifier))
            {
                Parser.ErrorAtCurrent("identifier expected");       
                break;
            }
            <string,string> idToken = Parser.CurrentToken;
            string identifier;
            bool public;
            if (!normalizeIdentifier(idToken, ref identifier, ref public, true))
            {
                break;   
            }
            Symbols.AddLocation(identifier, idToken["source"] + ":" + idToken["line"]);
            
            Parser.Advance(); // identifier           
            
            if (!Parser.Check(HopperToken.LBrace))
            {
                Parser.ErrorAtCurrent('{');
                break;
            }
            Parser.Advance(); // {
            <string,uint> values;
            uint currentValue = 0;
            loop
            {
                if (Parser.Check(HopperToken.RBrace))
                {
                    Parser.Advance(); // }
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent("unexpected end of file in enum/flags declaration");
                    break;
                }
                
                if (!Parser.Check(HopperToken.Identifier))
                {
                    Parser.ErrorAtCurrent("identifier expected");       
                    break;
                }
                
                <string,string> entryToken = Parser.CurrentToken;
                
                string qualifiedName = identifier + "." + entryToken["lexeme"];
                if (values.Contains(qualifiedName))
                {
                    Parser.ErrorAtCurrent("duplicate member identifier"); 
                    break;
                }
                
                string valueString;
                Parser.Advance();
                if (Parser.Check(HopperToken.Assign))
                {
                    Parser.Advance(); // =
                    string actualType;
                    valueString = ParseConstantExpression("uint", ref actualType);
                    if (!UInt.TryParse(valueString, ref currentValue))
                    {
                        Parser.ErrorAtCurrent("'uint' constant expected"); 
                    }
                }
                                
                values[qualifiedName] = currentValue;
                Symbols.AddLocation(qualifiedName, entryToken["source"] + ":" + entryToken["line"]);
                
                currentValue++;
                bool expectComma = false;
                if (!Parser.Check(HopperToken.RBrace))
                {
                    expectComma = true;        
                }
                if (Parser.Check(HopperToken.Comma))
                {
                    Parser.Advance(); // ,
                }
                else if (expectComma)
                {
                    Parser.ErrorAtCurrent(',');       
                }
            } // loop
                    
            if (HadError)
            {
                break;
            }
            if (isFlags)
            {
                Symbols.AddFlags(identifier, values);
            }
            else
            {
                Symbols.AddEnum(identifier, values);
            }
            break;
        } // loop
    }
    enumDeclaration()
    {
        enumDeclaration(false);
    }   
    flagsDeclaration()
    {
        enumDeclaration(true);
    }   
    
    usesDeclaration(string sourcePath)
    {
        loop
        {
            <string,string> prevToken = Parser.PreviousToken;
            <string,string> usesToken = Parser.CurrentToken;
            
            if ((prevToken.Count != 0) && (usesToken["line"] == prevToken["line"]))
            {
                Parser.ErrorAtCurrent("'uses' must be first token on line");
                break;
            }
            Parser.Advance(); // uses
            if (!Parser.Check(HopperToken.StringConstant))
            {
                Parser.ErrorAtCurrent("path of unit source expected");
                break;
            }
            Parser.Advance();
            <string, string> pathToken = Parser.PreviousToken;
            string usesPath = pathToken["lexeme"];
            string usesPathLower = usesPath.ToLower();
            
            string usesExtension = Path.GetExtension(usesPathLower);
            if (usesExtension == ".")
            {
                usesExtension = IsAssembly ? ".asm" : ".hs";
                usesPath = usesPath + usesExtension;
            }
            if (!File.Exists(usesPath))
            {
                string tryFile = usesPath;
                uint removeLevels = 0;
                if (tryFile.StartsWith("./"))
                {
                    tryFile = tryFile.Substring(2);
                }
                while (tryFile.StartsWith("../"))
                {
                    tryFile = tryFile.Substring(3);
                    removeLevels++;
                }
                
                if (!tryFile.StartsWith("/"))
                {
                    // first try relative to current source file:
                    string currentDirectory = Path.GetDirectoryName(sourcePath);
                    while (removeLevels > 0)
                    {
                        currentDirectory = Path.GetDirectoryName(currentDirectory);
                        removeLevels--;
                    }
                    string tryPath = Path.Combine(currentDirectory, tryFile);
                    if (File.Exists(tryPath))
                    {
                        usesPath = tryPath;
                    }
                    else
                    {
                        // then try relative to main project file
                        string projectDirectory = Path.GetDirectoryName(projectPath);
                        tryPath = Path.Combine(projectDirectory, tryFile);
                        if (File.Exists(tryPath))
                        {
                            usesPath = tryPath;
                        }
                    }
                }
            }
            if (!File.Exists(usesPath))
            {
                Parser.ErrorAtCurrent("'" + usesPath + "' not found");
                break;
            }
            else
            {
                // relative path from '/'? add '/' to be canonical (and avoid multiple references to the same unit)
                if (!usesPath.StartsWith('/') && (CurrentDirectory == "/"))
                {
                    usesPath = "/" + usesPath;
                }
                if (IsVerbose)
                {
                    PrintLn(); Print('"' + sourcePath + "\" -> uses " + usesPath + "\" ", Colour.DarkGray, Colour.Black);
                }
            }
            
            if (pathToken["line"] != usesToken["line"])
            {
                Parser.ErrorAtCurrent("'uses' and path must appear on one line");
                break;
            }
            
            <string, string> nextToken = Parser.CurrentToken;
            if (nextToken["line"] == pathToken["line"])
            {
                Parser.ErrorAtCurrent("'uses' declaration must be alone on line");
                break;
            }
            
            //PrintLn("  uses \"" + usesPath + '"'); // REMOVE
            
            parseUnit(usesPath, false);
            break;
        }
    }
    
    mainMethodDeclaration()
    {
        loop
        {
            if (programNamespace != Types.CurrentNamespace)
            {
                Parser.ErrorAtCurrent("identifier expected"); // {.. } entry point only allowed in 'program'
                break;
            }
            
            <string> blockPos = walkBlock();
            if (HadError)
            {
                break;
            }
            
            < <string > > arguments;
            Symbols.AddMethod(CurrentNamespace + ".Hopper", arguments, blockPos);
            break;
        }
    }   
    
    < < string > > argumentsDeclaration()
    {
        < < string > > arguments;
        <string> argumentNames;
        
        Parser.Advance(); // (
        loop
        {
            if (Parser.Check(HopperToken.RParen))
            {
                Parser.Advance(); // )
                break; // done
            }
            if (arguments.Count != 0)
            {
                if (!Parser.Check(HopperToken.Comma))
                {
                    Parser.ErrorAtCurrent(',');       
                    break;
                }
                Parser.Advance();
            }
            string isReference = "";
            if (Parser.CheckKeyword("ref"))
            {
                Parser.Advance(); // ref   
                isReference = "ref";   
            }
            string typeString;   
            bool deferred;
            if (!tryParseTypeString(ref typeString, ref deferred, false)) // argumentsDeclaration
            {
                if (!HadError)
                {
                    Parser.ErrorAtCurrent("type expected");
                }
                break;
            }
            if (!Parser.Check(HopperToken.Identifier))
            {
                Parser.ErrorAtCurrent("identifier expected");   
                break;
            }  
            <string,string> currentToken = CurrentToken;
            string identifier = currentToken["lexeme"];
            if (argumentNames.Contains(identifier))
            {
                Parser.ErrorAtCurrent("argument '" + identifier + "' already exists");
                break;
            }       
            if (Token.IsReservedWord(identifier))
            {
                Parser.ErrorAtCurrent("identifier '" + identifier + "' is a reserved word");
                break;
            }
            argumentNames.Append(identifier);
            <string> argument;
            argument.Append(isReference);
            argument.Append(typeString);
            argument.Append(identifier);
            arguments.Append(argument);          
            Parser.Advance();
        }
        return arguments;
    }
       
    methodDeclaration(<string,string> idToken, bool isDelegate)
    {
        loop
        {
            string identifier;
            bool public;
            if (!normalizeIdentifier(idToken, ref identifier, ref public, false))
            {
                break;   
            }
            
            if (idToken["lexeme"] == "Hopper")
            {
                if (programNamespace != Types.CurrentNamespace)
                {
                    Parser.ErrorAtCurrent("'Hopper()' is reserved for entry point in 'program " + programNamespace + "'");
                    break;
                }
            }
            
            if (isDelegate)
            {
                Symbols.AddLocation(identifier, idToken["source"] + ":" + idToken["line"]);
            }
            < <string > > arguments = argumentsDeclaration();
            if (HadError)
            {
                break;
            }
            if (IsAssembly && (arguments.Count != 0))
            {
                Parser.ErrorAt(idToken, "no arguments in assembly");
                break;
            }
            if (idToken["lexeme"] == "Hopper")
            {
                if (arguments.Count != 0)
                {
                    Parser.ErrorAt(idToken, "the entry point, should not have arguments.");
                    break;
                }
            }
            if (isDelegate)
            {
                Parser.Consume(HopperToken.SemiColon);
                if (HadError)
                {
                    break;
                }
                Symbols.AddMethodDelegate(identifier, arguments);
                break;   
            }
            <string> blockPos = walkBlock();
            if (HadError)
            {
                break;
            }
            
             // Inline validation for methods
            if ((blockPos.Count >= 4) && (blockPos[3] == "inline"))
            {
                if (isDelegate)
                {
                    Parser.ErrorAt(idToken, "delegates cannot be inline");
                    break;
                }
            }
            
            Symbols.AddMethod(identifier, arguments, blockPos);
            break;
        }
    }
     
    functionDeclaration(<string,string> idToken, string returnTypeString, bool isDelegate)
    {
        loop
        {
            string identifier;
            bool public;
            if (!normalizeIdentifier(idToken, ref identifier, ref public, false))
            {
                break;   
            }
            
            if (idToken["lexeme"] == "Hopper")
            {
                if (programNamespace != Types.CurrentNamespace)
                {
                    Parser.ErrorAtCurrent("'Hopper()' is reserved for entry point in 'program " + programNamespace + "'.");
                    break;
                }
                else
                {
                    Parser.ErrorAtCurrent("'Hopper()', the entry point, should not have a return value.");
                    break;
                }
            }
            
            if (isDelegate)
            {
                Symbols.AddLocation(identifier, idToken["source"] + ":" + idToken["line"]);
            }
            
            < <string > > arguments = argumentsDeclaration();
            if (HadError)
            {
                break;
            }
            if (isDelegate)
            {
                Parser.Consume(HopperToken.SemiColon);
                if (HadError)
                {
                    break;
                }
                Symbols.AddFunctionDelegate(identifier, arguments, returnTypeString);
                break;   
            }
            <string> blockPos = walkBlock();
            if (HadError)
            {
                break;
            }
            
            // Validate inline usage
            if ((blockPos.Count >= 4) && (blockPos[3] == "inline"))
            {
                // Add inline-specific validations
                if (isDelegate)
                {
                    Parser.ErrorAt(idToken, "delegates cannot be inline");
                    break;
                }
                
                if (identifier == "Hopper")
                {
                    Parser.ErrorAt(idToken, "entry point cannot be inline");
                    break;
                }
                
                // Could add other restrictions like:
                // - No recursive calls
                // - Size limitations
                // - Parameter count limits
            }
            
            Symbols.AddFunction(identifier, arguments, returnTypeString, blockPos);
            break;
        }
    }   
    
    bool isThisType(string typeName)
    {
        bool found;
        loop
        {
            string valueTypes = "|array|dictionary|list|string|bool|byte|char|uint|int|long|float|type|file|directory|";
            typeName = "|" + typeName + "|";
            if (valueTypes.Contains(typeName))
            {
                found = true;
                break;
            }
            break;
        }
        return found;
    }
    
    
    propertyDeclaration(<string,string> idToken, string typeString)
    {
        bool hadGet;
        bool hadSet;
        loop
        {
            string identifier;
            bool public;
            if (!normalizeIdentifier(idToken, ref identifier, ref public, true))
            {
                break;   
            }
            
            Parser.Consume(HopperToken.LBrace);
            if (HadError)
            {
                break;
            }
            loop
            {
                if (Parser.CheckKeyword("get"))
                {
                    Parser.Advance();
                    if (hadGet)
                    {
                        Parser.ErrorAtCurrent("'get' already defined for " + identifier);    
                        break;    
                    }
                    hadGet = true;
                    <string> blockPos = walkBlock();
                    if (HadError)
                    {
                        break;
                    }
                    
                    string getterName = identifier + "_Get";
                    < <string > > arguments;
                    
                    uint iDot;
                    string typeName;
                    if (getterName.IndexOf('.', ref iDot))
                    {
                        typeName = getterName.Substring(0, iDot);
                        typeName = typeName.ToLower();
                        if (isThisType(typeName))
                        {
                            switch (typeName)
                            {
                                case "array":
                                {
                                    typeName = "V[]";
                                }
                                case "list":
                                {
                                    typeName = "<V>";
                                }
                                case "dictionary":
                                {
                                    typeName = "<K,V>";
                                }
                            }
                            <string> thisargument;
                            thisargument.Append(""); // not "ref"
                            thisargument.Append(typeName);
                            thisargument.Append("this");
                            arguments.Append(thisargument); 
                        }
                    }
                    
                    Symbols.AddFunction(getterName, arguments, typeString, blockPos);
                    continue;
                }
                else if (Parser.CheckKeyword("set"))
                {
                    Parser.Advance();
                    if (hadSet)
                    {
                        Parser.ErrorAtCurrent("'set' already defined for " + identifier);        
                        break;
                    }
                    hadSet = true;
                    <string> blockPos = walkBlock();
                    if (HadError)
                    {
                        break;
                    }
                    string setterName = identifier + "_Set";
                    
                    < <string > > arguments;
                    
                    uint iDot;
                    string typeName;
                    if (setterName.IndexOf('.', ref iDot))
                    {
                        typeName = setterName.Substring(0, iDot);
                        typeName = typeName.ToLower();
                        if (isThisType(typeName))
                        {
                            switch (typeName)
                            {
                                case "array":
                                {
                                    typeName = "V[]";
                                }
                                case "list":
                                {
                                    typeName = "<V>";
                                }
                                case "dictionary":
                                {
                                    typeName = "<K,V>";
                                }
                            }
                            <string> thisargument;
                            thisargument.Append(""); // not "ref"
                            thisargument.Append(typeName);
                            thisargument.Append("this");
                            arguments.Append(thisargument); 
                        }
                    }
                    
                    <string> argument;
                    argument.Append(""); // not "ref"
                    argument.Append(typeString);
                    argument.Append("value");
                    arguments.Append(argument);          
                    
                    
                    Symbols.AddMethod(setterName, arguments, blockPos);
                    continue;
                }
                break;
            } // loop
            if (!hadGet && !hadSet)
            {
                Parser.ErrorAtCurrent("'get' or 'set' expected");        
                break;
            }
            
            Parser.Consume(HopperToken.RBrace);
            break;
        }
    }
    
    globalDeclaration(<string,string> idToken, string typeString)
    {
        loop
        {
            string identifier;
            bool public;
            if (!normalizeIdentifier(idToken, ref identifier, ref public, true))
            {
                break;   
            }
            if (!IsAssembly && public)
            {
                Parser.ErrorAtCurrent("member variables must be private");
                break;
            }
            <string> blockPos;
            <string,string> currentToken = Parser.CurrentToken;
            if (Parser.Check(HopperToken.Assign))
            {
                long pos;
                if (Long.TryParse(currentToken["pos"], ref pos))
                {
                    
                }
                Parser.Advance();
                // current position is now at expression to initialize global member
                currentToken = Parser.CurrentToken;
                
                pos = pos + 1; // one beyond '='
                
                blockPos.Append(pos.ToString());
                blockPos.Append(currentToken["line"]);
                blockPos.Append(currentToken["source"]);
            }
            else
            {
                blockPos.Append("0");
                blockPos.Append(currentToken["line"]);
                blockPos.Append(currentToken["source"]);
            }
            Symbols.AddGlobalMember(identifier, typeString, blockPos);
            
            loop
            {
                if (Parser.Check(HopperToken.SemiColon))
                {
                    Parser.Advance();
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent(';');
                    break;
                }
                Parser.Advance(); // gobble gobble
            } // loop
            break;
        } // loop
    }
    
    declaration(ref uint curlyDeclarations, ref string lastID, string sourcePath)
    {
        bool isDelegate;
        lastID = "";
        if (Parser.CheckKeyword("delegate"))
        {
            if (IsAssembly)
            {
                Parser.Error("no delegates in assembly");
            }
            else if (IsZ80) // TODO: ternary
            {
                Parser.ErrorAtCurrent("delegates not supported by Z80 compiler");
            }
            else
            {
                isDelegate = true;
                Parser.Advance(); // delegate
            }
        }
        
        if (Parser.CheckDirective("#define"))
        {
            Directives.Declaration(); 
        }
        else if (Parser.Check(HopperToken.Directive))
        {
            //OutputDebug("Directive:");
            //DumpCurrent();
            Directives.Directive(); 
        }
        else
        {
            // not directive
            bool allDefined = Directives.IsAllDefined();
            if (!allDefined)
            {                                  
                loop
                {
                    if (Parser.Check(HopperToken.Directive))
                    {
                        
                        //DumpCurrent();
                        // The only directives we don't want to gobble are:
                        // - the #endif that flips allDefined
                        // - the #else that flips allDefined
                        if (Parser.CheckDirective("#define"))
                        {
                            Directives.Declaration(); 
                        }
                        else
                        {
                            Directives.Directive(); 
                        }
                        allDefined = Directives.IsAllDefined();
                        if (allDefined)
                        {
                            //OutputDebug("allDefined->");
                            break;
                        }
                        else
                        {
                            //OutputDebug("Gobbled");
                            continue;
                        }
                    }
                    if (Parser.Check(HopperToken.EOF))
                    {
                        break;
                    }
                    Parser.Advance(); // gobble gobble
                } // loop
            }                                           
            else if (Parser.Check(HopperToken.LBrace))
            {
                mainMethodDeclaration();
                curlyDeclarations++;
            }
            else if (Parser.CheckKeyword("const"))
            {
                constDeclaration();
            }
            else if (Parser.CheckKeyword("enum"))
            {
                enumDeclaration();
                curlyDeclarations++;
            }
            else if (Parser.CheckKeyword("flags"))
            {
                flagsDeclaration();
                curlyDeclarations++;
            }
            else if (Parser.CheckKeyword("friend"))
            {
                friendDeclaration();
            }
            else if (Parser.CheckKeyword("uses"))
            {
                if (curlyDeclarations > 0)
                {
                    Parser.ErrorAtCurrent("must appear before function, method, property, enum or flags declarations");
                }
                else
                {
                    usesDeclaration(sourcePath);
                }
            }
            else if (Parser.CheckKeyword("record"))
            {
                if (IsAssembly)
                {
                    Parser.Error("no records in assembly");
                }
                else
                {
                    recordDeclaration();
                    curlyDeclarations++;
                }
            }
            else if (Parser.CheckKeyword("reserve"))
            {
                if (!IsAssembly)
                {
                    Parser.Error("'reserve' is an assembly keyword");
                }
                else
                {
                    Parser.Advance(); // reserve  
                    
                    loop
                    {
                        string actualType;
                        string location = ParseConstantExpression("uint", ref actualType);
                        if (HadError)
                        {
                            break;
                        }
                        if (!Parser.Check(HopperToken.Comma))
                        {
                            Parser.Error("',' expected");  
                            
                        }
                        Parser.Advance(); // ,
                        string length = ParseConstantExpression("uint", ref actualType);
                        if (HadError)
                        {
                            break;
                        }
                        uint ilocation;
                        uint ilength;
                        _ = UInt.TryParse(location, ref ilocation);
                        _ = UInt.TryParse(length, ref ilength);
                        
                        string reserveSymbol = "__RESERVE_" + ilocation.ToHexString(4) + "_" + ilength.ToHexString(4);
                        Symbols.AddDefine(reserveSymbol, "true");
                        
                        <string, string> idToken = Parser.CurrentToken;
                        Symbols.AddLocation(reserveSymbol, idToken["source"] + ":" + idToken["line"]);
                
                        break;
                    } // loop
                }
            }
            else
            {   // global, method or function
                loop
                {
                    <string, string> idToken;
                    bool isFunction = false;
                    bool isProperty = false;
                    bool isMethod = false;
                    bool isGlobal = false;
                               
                    string typeString;
                    bool isType = false;
                  
                    bool deferred;
                    if (HopperToken.LParen != Parser.PeekTokenType())
                    {           
                        isType = tryParseTypeString(ref typeString, ref deferred, true); // declaration (global or return type?)
                    }
                    if (isType) // could be assuming a named type that has not been defined yet
                    {
                        if (Parser.Check(HopperToken.Identifier) || Parser.Check(HopperToken.DottedIdentifier))
                        {
                            idToken = Parser.CurrentToken;
                            lastID = idToken["lexeme"];
                            Parser.Advance();
                            if (Parser.Check(HopperToken.LParen))
                            {
                                if (IsAssembly)
                                {
                                    Parser.Error("no 'return' type in assembly");
                                    break;
                                }
                                // return type followed by function id and then '('
                                isFunction = true;
                            }
                            else if (Parser.Check(HopperToken.Assign))
                            {
                                if (IsAssembly)
                                {
                                    Parser.Error("global initialization not supported in assembly");
                                    break;
                                }
                                // type followed by global id and then '='
                                isGlobal = true;
                            }
                            else if (Parser.Check(HopperToken.SemiColon))
                            {
                                // type followed by global id and then ';'
                                isGlobal = true;
                            }
                            else if (Parser.Check(HopperToken.LBrace))
                            {
                                if (IsAssembly)
                                {
                                    Parser.Error("no properties in assembly");
                                    break;
                                }
                                // type followed by property id and then '{'
                                isProperty = true;
                            }
                            else
                            {
                                Parser.Error("'(' or ';' expected");
                                break;
                            }
                        }
                        else if (deferred && Parser.Check(HopperToken.LBrace))
                        {
                            Parser.ErrorAtCurrent("unexpected '{'");
                        }
                        else
                        {
                            Parser.ErrorAtCurrent("identifier expected, " + typeString);
                            break;
                        }
                    } // isType
                    else if (Parser.Check(HopperToken.Identifier) || Parser.Check(HopperToken.DottedIdentifier))
                    {
                        idToken = Parser.CurrentToken;
                        lastID = idToken["lexeme"];
                        Parser.Advance();
                        if (Parser.Check(HopperToken.Identifier) || Parser.Check(HopperToken.DottedIdentifier))
                        {
                            // named type (like enum or flags)
                            <string,string> typeToken = idToken;
                            idToken = Parser.CurrentToken;
                            Parser.Advance();
                            // two consecutive identifiers implies:
                            if (Parser.Check(HopperToken.LParen))
                            {
                                if (IsAssembly)
                                {
                                    Parser.Error("no 'return' in assembly");
                                    break;
                                }
                                // return type followed by function id and then '('
                                isFunction = true;
                            }
                            else if (Parser.Check(HopperToken.SemiColon) || Parser.Check(HopperToken.Assign))
                            {
                                // type followed by global id and then ';' or '='
                                isGlobal = true;
                            }
                            else if (Parser.Check(HopperToken.LBrace))
                            {
                                if (IsAssembly)
                                {
                                    Parser.Error("no properties in assembly");
                                    break;
                                }
                                // type followed by property id and then '{'
                                isProperty = true;
                            }
                            else
                            {
                                Parser.ErrorAtCurrent("'(' or ';' expected");
                                break;
                            }
                            typeString = typeToken["lexeme"];
                        } // two identifiers   
                        else
                        {
                            // single identifier implies method name
                            if (!Parser.Check(HopperToken.LParen))
                            {
                                Parser.ErrorAtCurrent('(');
                                break;
                            }
                            isMethod = true;
                        }
                    } // identifier or two identifiers
                                            
                    if (isFunction)
                    {
                        functionDeclaration(idToken, typeString, isDelegate);
                        isDelegate = false;
                        curlyDeclarations++;
                    }          
                    else if (isProperty)
                    {
                        propertyDeclaration(idToken, typeString);
                        curlyDeclarations++;
                    }
                    else if (isMethod)
                    {
                        methodDeclaration(idToken, isDelegate);
                        isDelegate = false;
                        curlyDeclarations++;
                    }
                    else if (isGlobal)
                    {
                        globalDeclaration(idToken, typeString);
                    }
                    else
                    {
                        Parser.ErrorAtCurrent("function, method, property or global declaration expected");
                    }
                    if (isDelegate)
                    {
                        Parser.ErrorAtCurrent("invalid delegate declaration");
                    }
                    break;
                } // loop
            } // global, method or function
        } // not directive
    } // declaration()
    /*
    uint nesting;
    indent()
    {
        PrintLn();
        for (uint i = 0; i < nesting; i++)
        {
            Print("    ");
        }
    }
    */
    parseUnit(string sourcePath, bool firstUnit)
    {
        sourcePath = sourcePath.ToLower();
        if (unitsParsed.Contains(sourcePath))
        {
            return; // has already been parsed
        }
        
        string pushNamespace = Types.CurrentNamespace;
        <string,string> pushToken = Parser.CurrentToken;
        <bool> storedNesting = Directives.Store();
        
        /*
        nesting++;
        if (!firstUnit)
        {
            indent();
            Print("Push:");
            Print(pushToken["type"]);
            Print(" '" + pushToken["lexeme"] + "'");
            Print(" " + pushToken["line"]);
            Print(" " + pushToken["pos"]);
            Print(" " + pushToken["source"]);
        }
        indent();
        Print("<" + sourcePath);
        */
        
        loop
        {
            unitsParsed[sourcePath] = true; // sourcePath is about to be parsed
            Parser.Reset();
            Directives.New();
                           
            //Scanner.Load(sourcePath);
            long pos;
            Scanner.Reset(pos, 1, sourcePath);
            Parser.Advance(); // load up first token
            if (firstUnit)
            {
                Parser.ConsumeKeyword("program");
                Parser.Consume(HopperToken.Identifier, "Program name identifier expected");
            }
            else
            {
                Parser.ConsumeKeyword("unit");
                Parser.Consume(HopperToken.Identifier, "Unit name identifier expected");
            }
            if (Parser.HadError)
            {
                break;
            }
            
            if (Parser.HadError)
            {
                break;
            }
            <string,string> previousToken = Parser.PreviousToken;
            Types.CurrentNamespace = previousToken["lexeme"];
            AddNameSpace(Types.CurrentNamespace, sourcePath);
            
            if (firstUnit)
            {
                programNamespace = Types.CurrentNamespace;
            }
          
            Parser.Consume(HopperToken.LBrace);
            if (Parser.HadError)
            {
                break;
            }
            
            bool endedProperly = false;
            uint curlyDeclarations;
            string lastID;
            uint progressCount = 0;
            loop
            {
                if (Parser.Check(HopperToken.EOF))
                {
                    break;
                }
                if (Parser.Check(HopperToken.RBrace))
                {
                    endedProperly = true;
                    break;
                }
                if (Parser.HadError)
                {
                    break;
                }
                declaration(ref curlyDeclarations, ref lastID, sourcePath);
                if (Parser.HadError)
                {
                    break;
                }
                if (progressCount % 32 == 0)
                {
                    Parser.ProgressTick("p"); // preprocess
                }
                progressCount++;
            }   
            if (Parser.HadError)
            {
                // already seen error message
                break;
            }
            else if (!endedProperly)
            {
                // can't "Consume" at the end of the file
                string message = "'}' expected";
                if (lastID.Length != 0)
                {
                    message = " missing '}', opening '{' in " + lastID;
                }
                Parser.Error(message);
            }
            else
            {
                uint mIndex;
                if (firstUnit && !Symbols.GetFunctionIndex("Hopper", ref mIndex))
                {
                    Parser.Error("program requires entry point");
                }
                else if (Directives.IsStillOpen)
                {
                    Parser.ErrorAtCurrent("'#endif' expected before end of file");
                }
            }
            break;
        } // loop
        if (!firstUnit && !Parser.HadError)
        {
            // pop previous parser state
            /*
            indent();
            Print("Pop:");
            Print(pushToken["type"]);
            Print(" '" + pushToken["lexeme"] + "'");
            Print(" " + pushToken["line"]);
            Print(" " + pushToken["pos"]);
            Print(" " + pushToken["source"]);
            */
            long pos;
            if (!Long.TryParse(pushToken["pos"], ref pos))
            {
                Parser.Error("invalid pos: '" + pushToken["pos"] + "'");
            }
            uint ln;
            if (!UInt.TryParse(pushToken["line"], ref ln))
            {
                Parser.Error("invalid line: '" + pushToken["line"] + "'");
            }
            pos = pos - Token.GetLength(pushToken); // Advance reloads 'Current'
            Scanner.Reset(pos, ln, pushToken["source"]); // / calls Scanner.Load
            /*
            indent();
            Print("CurrentSourcePath=" + Scanner.CurrentSourcePath);    
            */
            Parser.Reset();
            Parser.Advance();
            /*
            indent();
            Print("Reset:");
            
            <string, string> current = CurrentToken;
            Print(" " + current["type"]);
            Print(" '" + current["lexeme"] + "'");
            Print(" " + current["line"]);
            Print(" " + current["pos"]);
            Print(" " + current["source"]); 
            */
        }
        Directives.Restore(storedNesting);
        Types.CurrentNamespace = pushNamespace; 
        /*
        indent();
        Print(">");
        nesting--;
        */
    }
    
    bool buildSymbols(string sourcePath, <string> cliSymbols)
    {
        bool success = true;
        unitsParsed.Clear();

        Symbols.New();
        Scanner.New();
        SysCalls.New();
        LibCalls.New();

        foreach (var symbol in cliSymbols)
        {
            Symbols.AddDefine(symbol, "true");
        }
        
        parseUnit(sourcePath, true);
        success = !Parser.HadError;
        if (success)
        {
            success = Constant.ResolveUnresolveds();
        }
        return success;
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for PREPROCESS:");
        PrintLn("  PREPROCESS [args] <source file>");    
        PrintLn("    -g <c> <r>  : called from GUI, not console");
        PrintLn("    -x          : use experimental features");
        PrintLn("    -d <symbol> : define conditional compilation symbols");
        PrintLn("    -a          : preprocess assembly");
        PrintLn("    -t          : preprocess assembly as part of the Tigger C toolchain");
        PrintLn("    -z          : for Z80 compiler");
        PrintLn("    -v          : verbose output (show 'uses' resolution)");
    }
    Hopper()
    {  
        bool success = false;
        loop
        {
          <string> rawArgs = System.Arguments;
          <string> args;
          <string> cliSymbols;
          
          for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
          {
              string arg = rawArgs[iArg];
              if ((arg.Length == 2) && (arg[0] == '-'))
              {
                  arg = arg.ToLower();
                  switch (arg)
                  {
                      case "-g":
                      {
                          uint col;
                          uint row;
                          iArg++;
                          if (UInt.TryParse(rawArgs[iArg], ref col))
                          {
                          }
                          iArg++;
                          if (UInt.TryParse(rawArgs[iArg], ref row))
                          {
                          }
                          Parser.SetInteractive(byte(col), byte(row));
                      }
                      case "-d":
                      {
                          iArg++;
                          cliSymbols.Append(rawArgs[iArg]);
                      }
                      case "-x":
                      {
                          isExperimental = true;   
                      }
                      case "-v":
                      {
                          isVerbose = true;   
                      }
                      case "-a":
                      {
                          isAssembly = true;
                      }
                      case "-t":
                      {
                          IsTiggerC = true;
                      }
                      case "-z":
                      {
                          isZ80 = true;   
                      }
                      default:
                      {
                          args.Clear();
                          break;
                      }
                  }
              }
              else
              {
                  args.Append(arg);
              }
          }
          
          if (args.Count != 1)
          {
              BadArguments();
              break;
          }
          bool sourceFound;
          projectPath = args[0];
          string ext = ".hs";
          string codePath = args[0];
          
          <string> sourceFolders;
          sourceFolders.Append(System.CurrentDirectory);
          sourceFolders.Append("/Source/Compiler/");
          sourceFolders.Append("/Source/Debugger/");
          sourceFolders.Append("/Source/Editor/");
          sourceFolders.Append("/Source/Shell/");
          sourceFolders.Append("/Source/Testing/");
          foreach (var sourceFolder in sourceFolders)
          {
              if (File.Exists(ref projectPath, ref ext, sourceFolder))
              {
                  sourceFound = true;
                  break;
              }
          }
          if (!sourceFound)
          {
              BadArguments();
              break;
          }
          projectPath = Path.GetFullPath(projectPath);
          
          long startTime = Millis;
          loop
          {
              string extension = Path.GetExtension(projectPath);
              string jsonPath  = projectPath.Replace(extension, ".sym");
              jsonPath = Path.GetFileName(jsonPath);
              jsonPath = Path.Combine("/Debug/Obj/", jsonPath);
              if (File.Exists(jsonPath))
              {
                  // delete previous so no output on error
                  File.Delete(jsonPath); 
              }
              if (!IsTiggerC)
              {
                  cliSymbols = Configuration.ReadSymbols(cliSymbols, IsAssembly ? "Hopper 6502 Assembly" : "Hopper");
              }
              if (!buildSymbols(projectPath, cliSymbols))
              {
                 // error!
                 break;
              }              
              if (!Symbols.DeferredValidation())
              {
                 // error!
                 break;
              }
              if (!Parser.IsInteractive())
              {
                  PrintLn();
                  PrintLn("Exporting: '" + jsonPath + "'");
              }
              if (!Symbols.Export(jsonPath))
              {
                  break;
              }
              if (!Parser.IsInteractive())
              {
                  Print("Success. ", Colour.ProgressText, Colour.ProgressFace);
                  long elapsedTime = Millis - startTime;
                  float seconds = elapsedTime / 1000.0;
                  PrintLn("  " +seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace); 
              }
              else
              {
                  Parser.ProgressDone();
              }
              success = true;
              break;
          } // main loop
          break;
        } // arguments loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
      
    }
}
