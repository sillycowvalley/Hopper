program Z80Gen
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define SHORT_CALLS  // use CALLB to save space
    
    //#define INLINE_STACK_OPERATIONS
    //#define INLINE_OTHER_INSTRUCTIONS
    
    #define CHECKED
//  #define PATCHCHECKED
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "CodeGen/Instructions"
    uses "Symbols"
    
    uses "/Source/Runtime/Platform/SysCalls"
    
    
    uses "CODEGEN/AsmZ80"
    uses "CODEGEN/Z80Library"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    <string,variant> symbols;
    
    long codeSize = 0;
    <byte> output;
    <uint,uint> patches;         // <callLocation,methodIndex>
    <uint,uint> methods;         // <methodIndex,address>
    
    <string,bool> missingOpCodes;
    
    uint entryIndex;
    uint romSize = 0x8000;
    
    bool NoPackedInstructions { get { return false; } }
    
    uint CurrentAddress { get { return output.Count; } }
    
    reset()
    {
        // switch to Mode 1 for IRQ and NMI
        Emit     (OpCode.IM_1);
               
        //      Error = 0;
        Emit     (OpCode.XOR_A_A);
        EmitWord (OpCode.LD_inn_A, LastError);
        
        byte romPages  = byte(romSize >> 8);
        byte heapStart = romPages;
        byte heapSize  = 0xFC - heapStart; // 0xFC..0xFF used by stack and system
        
        EmitByte (OpCode.LD_A_n,   heapStart);
        EmitWord (OpCode.LD_inn_A, HeapStart);
        EmitWord (OpCode.LD_inn_A, FreeList+1);
        Emit     (OpCode.XOR_A_A);
        EmitWord (OpCode.LD_inn_A, FreeList+0);
        EmitByte (OpCode.LD_A_n,   heapSize);
        EmitWord (OpCode.LD_inn_A, HeapSize);
        
        uint heapStartAddress = (heapStart << 8);
        
        // all memory is in this single free list record
        EmitWord (OpCode.LD_inn_A, heapStartAddress + 1);
        Emit     (OpCode.XOR_A_A);
        EmitWord (OpCode.LD_inn_A, heapStartAddress + 0);
        
        // next = null
        EmitWord (OpCode.LD_inn_A, heapStartAddress + 2);
        EmitWord (OpCode.LD_inn_A, heapStartAddress + 3);
        
        // prev = null
        EmitWord (OpCode.LD_inn_A, heapStartAddress + 4);
        EmitWord (OpCode.LD_inn_A, heapStartAddress + 5);
        
        Emit(OpCode.EI);   
    }
    
    PatchByte(uint address, byte value)
    {
        patchByte(address, value);
    }
    bool firstBadPatch = true;
    bool firstPatchFailed = true;
    bool firstOpNotImplemented = true;
    patchByte(uint address, byte value)
    {
        if (address >= output.Count)
        {
            if (firstBadPatch)
            {
                PrintLn(" Bad patchByte: 0x" + address.ToHexString(4));
            }
            firstBadPatch = false;
        }
        else
        {
            output.SetItem(address, value);
        }
    }
    
    bool jumpPatch(uint methodIndex, uint patchLocation, uint targetAddress, uint methodAddress, uint methodLength)
    {
        bool success;
        loop
        {
#ifdef PATCHCHECKED            
            if ((patchLocation < methodAddress) || (patchLocation > methodAddress+methodLength-2))
            {
                PrintLn("0x" + methodIndex.ToHexString(4) + ": jumpPatch: patchLocation 0x" + patchLocation.ToHexString(4) + 
                        " outside method [0x"+methodAddress.ToHexString(4)+"-0x"+(methodAddress+methodLength-2).ToHexString(4) +"]");
                break;
            }
            if ((targetAddress < methodAddress) || (targetAddress > methodAddress+methodLength-2))
            {
                PrintLn("0x" + methodIndex.ToHexString(4) + ": jumpPatch: targetAddress 0x" + targetAddress.ToHexString(4) +
                        " outside method [0x"+methodAddress.ToHexString(4)+"-0x"+(methodAddress+methodLength-2).ToHexString(4) +"]");
                break;
            }
            OpCode jump = OpCode(output[patchLocation-1]);
            switch (jump)
            {
                case OpCode.JP_nn:
                case OpCode.JP_Z_nn:
                case OpCode.JP_NZ_nn:
                {
                }
                default:
                {
                    PrintLn("0x" + methodIndex.ToHexString(4) + ": jumpPatch: targetAddress-1 0x" + (targetAddress-1).ToHexString(4) + " is not a jump instruction (" + (output[patchLocation-1]).ToHexString(2) + ")");
                    break;
                }
            }
#endif
            // PATCH
            patchByte(patchLocation+0, byte(targetAddress & 0xFF));
            patchByte(patchLocation+1, byte(targetAddress >> 8));
            success = true;
            break;
        } // loop
        return success;
    }           
        
    doCallPatches(bool onlyEntry)
    {
        if (!onlyEntry)
        {
            // <uint,uint> patches; // <callLocation,methodIndex>
            // <uint,uint> methods; // <methodIndex,address>
            foreach (var kv in patches)
            {
                uint patchAddress  = kv.key;
                uint targetMethod  = kv.value;
                uint targetAddress = methods[targetMethod];
            
#ifdef PATCHCHECKED  
                bool patchOk = false;          
                OpCode instruction = GetOpCode(output, patchAddress-1);
                patchOk = (instruction == OpCode.CALL_nn);
                if (!patchOk)
                {
                    OpCode instruction1 = GetOpCode(output, patchAddress-3);
                    patchOk = (instruction == OpCode.LD_DE_nn) && (instruction1 == OpCode.DDDD); // PUSHD signature
                }
                if (!patchOk)
                {
                    PrintLn("doCallPatches: patchLocation-1 0x" + (patchAddress-1).ToHexString(4) + " is not a CALL instruction (" + (uint(instruction)).ToHexString(4) + ")");
                    continue;
                }
#endif
                // PATCH
                patchByte(patchAddress+0, byte(targetAddress & 0xFF));
                patchByte(patchAddress+1, byte(targetAddress >> 8));
            }
        }
        patchByte(5, byte(methods[entryIndex] & 0xFF));
        patchByte(6, byte(methods[entryIndex] >> 8));
    }
    
    emit(OpCode opCode)
    {
        uint ui = uint(opCode);
        if ((ui & 0xFF00) != 0)
        {
            output.Append(byte(ui >> 8));
        }
        output.Append(byte(ui & 0xFF));
    }
    Emit(OpCode opCode)
    {
        emit(opCode);
    }
    EmitByte(OpCode opCode, byte lsb)
    {
        emit(opCode);
        emitByte(lsb);
    }
    
    EmitOffset(OpCode opCode, int offset)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        emit(opCode);
        emitByte(lsb);
    }
    
    EmitOffsetByte(OpCode opCode, int offset, byte msb)
    {
        if (offset < 0)
        {
            offset += 256;
        }
        byte lsb = byte(offset);
        emit(opCode);
        emitByte(lsb);
        emitByte(msb);
    }

    EmitWord(OpCode opCode, uint operand)
    {
        emit(opCode);
        emitByte(byte(operand & 0xFF));
        emitByte(byte(operand >> 8));
    }
    emitByte(byte lsb)
    {
        output.Append(lsb);
    }
    
    writeSystem()
    {
        while (output.Count < 256)
        {
            if (output.Count == 0x0038)
            {
                Z80Library.ISR();
            }
            if (output.Count >= 0x0040) // after the RSTx slots
            {
                Z80Library.Generate();
                break;
            }
            Emit(OpCode.NOP);
        }
    }  
    
    byte offsetOperandToByte(uint operand)
    {
        // calculate the 8-bit signed Hopper offset
        int ioffset = byte(operand & 0xFF);
        if (ioffset > 127)
        {
            ioffset = ioffset - 256;
        }
        
        // invert the sign since the Z80 stack grows downward
        ioffset = -ioffset;
        
        // double it to convert from stack slots to bytes
        ioffset *= 2;
        if (ioffset > 0)
        {
            ioffset += 2; // to skip BP
        }
        else
        {
            ioffset -= 2; // to skip BP
        }
        
        byte byteOffset = ioffset.GetByte(0);        
        return byteOffset;
    }   
        
    uint addressOperandToByte(uint operand)
    {
        // calculate the 8-bit signed Hopper address
        int iaddress = byte(operand & 0xFF);
        
        // invert the sign since the Z80 stack grows downward
        iaddress = -iaddress;
        
        // double it to convert from stack slots to bytes
        iaddress *= 2;
        
        iaddress -= 4; // skip:
                       // - the return address from startup
                       // - the first slot itself
        
        long address = long(StackAddress) + long(StackSize) + iaddress;
        //PrintLn(operand.ToString() + " " + iaddress.ToString() + " -> 0x" + address.ToHexString(4));
        return uint(address);
    }
    
    checkIncReferenceTop(byte slot, <byte> referenceSlots)
    {
        if (referenceSlots.Count != 0)
        {
            if (referenceSlots.Contains(slot))
            {
                // reference type: array or string
                Emit    (OpCode.EX_iSP_IX);
                EmitByte(OpCode.INC_iIX_d, +1); // reference count is 2nd byte in object
                Emit    (OpCode.EX_iSP_IX);
            }
        }
    }
    checkDecReferenceTop(byte slot, <byte> referenceSlots)
    {
        if (referenceSlots.Count != 0)
        {
            if (referenceSlots.Contains(slot))
            {
                // reference type: array or string
                Emit      (OpCode.EX_iSP_IX);
                Emit      (OpCode.PUSH_IX);
                
                Emit      (OpCode.PUSH_HL);
                
                Emit      (OpCode.PUSH_IX);
                EmitWord  (OpCode.CALL_nn, Z80Library.GetAddress("GCRelease"));
                Emit      (OpCode.POP_DE); // cleanup stack
                
                Emit      (OpCode.POP_HL);
                
                Emit      (OpCode.POP_IX);
                Emit      (OpCode.EX_iSP_IX);
            }
        }
    }
    
    pushLocalB(uint operand, <byte> localReferenceSlots)
    {
        byte offset = offsetOperandToByte(operand);
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit(OpCode.PUSH_DE);
        checkIncReferenceTop(byte(operand & 0xFF), localReferenceSlots);
    }
    pushLocalBB(uint operand0, uint operand1, <byte> localReferenceSlots)
    {
        byte offset0 = offsetOperandToByte(operand0);
        byte offset1 = offsetOperandToByte(operand1);
        EmitByte(OpCode.LD_E_iIY_d, offset0);
        EmitByte(OpCode.LD_D_iIY_d, offset0 + 1);
        Emit(OpCode.PUSH_DE);
        checkIncReferenceTop(offset0, localReferenceSlots);
        EmitByte(OpCode.LD_E_iIY_d, offset1);
        EmitByte(OpCode.LD_D_iIY_d, offset1 + 1);
        Emit(OpCode.PUSH_DE);
        checkIncReferenceTop(offset1, localReferenceSlots);
    }
    popLocalB(uint operand, <byte> localReferenceSlots)
    {    
        byte offset = offsetOperandToByte(operand);
        checkDecReferenceTop(byte(operand & 0xFF), localReferenceSlots);
        Emit(OpCode.POP_DE);
        EmitByte(OpCode.LD_iIY_d_E, offset);
        EmitByte(OpCode.LD_iIY_d_D, offset + 1);
    }
    
    incLocalBB(uint operand0, uint operand1)
    {
        byte offset0 = offsetOperandToByte(operand0);
        byte offset1 = offsetOperandToByte(operand1);
        EmitByte(OpCode.LD_E_iIY_d, offset0);
        EmitByte(OpCode.LD_D_iIY_d, offset0 + 1);
        EmitByte(OpCode.LD_L_iIY_d, offset1);
        EmitByte(OpCode.LD_H_iIY_d, offset1 + 1);
        Emit(OpCode.ADD_HL_DE);
        EmitByte(OpCode.LD_iIY_d_L, offset0);
        EmitByte(OpCode.LD_iIY_d_H, offset0 + 1);
    }
    
    incLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        EmitByte  (OpCode.INC_iIY_d, offset);
        EmitOffset(OpCode.JR_NZ_e,    +3);    // did it overflow from 0xFF back around to 0x00?
        EmitByte  (OpCode.INC_iIY_d, offset+1);
    }
    decLocalB(uint operand)
    {
        byte offset = offsetOperandToByte(operand);
        EmitByte  (OpCode.DEC_iIY_d,  offset);
        EmitByte  (OpCode.LD_A_n,       0xFF);
        EmitByte  (OpCode.CP_A_iIY_d, offset); // wrapped around from 0x00 to 0xFF?
        EmitOffset(OpCode.JR_NZ_e,        +3);
        EmitByte  (OpCode.DEC_iIY_d,  offset+1);
    }
    pushStackAddrB(byte operand)
    {
        // address = BP + operand
        
        // HL = IY (BP)
        Emit(OpCode.PUSH_IY);
        Emit(OpCode.POP_HL);
        
        // two scenarios:
        // - operand >= 0
        // - operand < 0
        
        if (operand <= 127)
        {
            uint offset = uint(operand) << 1;
            offset += 2; // BP itself
            EmitWord(OpCode.LD_DE_nn, offset);
            Emit    (OpCode.XOR_A_A);
            Emit    (OpCode.SBC_HL_DE);
        }
        else
        {
            // operand > 127
            int offset = int(operand) - 256; // FF -> -1
            offset = offset * 2;
            offset -= 2; // return address
            uint ui = uint(-offset);
            EmitWord(OpCode.LD_DE_nn, ui);
            Emit    (OpCode.ADD_HL_DE);
        }
             
        Emit(OpCode.PUSH_HL);
    }
    
    pushRelB(uint operand, <byte> localReferenceSlots)
    {
        byte offset = operand.GetByte(0);
        if ((offset & 0b10000000) == 0)
        {
            Die(0x0B); // pushRelB for something other than ref argument?
        }
        
        int ioffset = offset - 256; // 0xFF -> -1
        ioffset -= 1; // return address
        ioffset *= 2;
        
        uint uoffset = uint(-ioffset);
        
        Emit    (OpCode.PUSH_IY);
        Emit    (OpCode.POP_IX);
        EmitWord(OpCode.LD_DE_nn, uoffset);
        Emit    (OpCode.ADD_IX_DE);
        
        // load the address of the stack slot
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit    (OpCode.PUSH_DE);
        Emit    (OpCode.POP_IX);
        
        // load the value from that stack slot and push it
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit    (OpCode.PUSH_DE);
        
        checkIncReferenceTop(offset, localReferenceSlots);
    }
    popRelB(uint operand, <byte> localReferenceSlots)
    {
        byte offset = operand.GetByte(0);
        if ((offset & 0b10000000) == 0)
        {
            Die(0x0B); // pushRelB for something other than ref argument?
        }
        
        int ioffset = offset - 256; // 0xFF -> -1
        ioffset -= 1; // return address
        ioffset *= 2;
        
        uint uoffset = uint(-ioffset);
        
        Emit    (OpCode.PUSH_IY);
        Emit    (OpCode.POP_IX);
        EmitWord(OpCode.LD_DE_nn, uoffset);
        Emit    (OpCode.ADD_IX_DE);
        
        // load the address of the stack slot
        EmitByte(OpCode.LD_E_iIX_d, +0);
        EmitByte(OpCode.LD_D_iIX_d, +1);
        Emit    (OpCode.PUSH_DE);
        Emit    (OpCode.POP_IX);
        
        checkDecReferenceTop(offset, localReferenceSlots); // TODO : figure this out
        
        // pop and store the value at that stack slot
        Emit(OpCode.POP_DE);    
        EmitByte(OpCode.LD_iIX_d_E, +0);
        EmitByte(OpCode.LD_iIX_d_D, +1);
    }         
    
    
    incGlobalB(uint operand, string typeName)
    {
        uint address = addressOperandToByte(operand);
        if (typeName == "byte")
        {
            EmitWord(OpCode.LD_HL_nn,    address);
            Emit    (OpCode.INC_iHL);
        }
        else
        {
            EmitWord  (OpCode.LD_IX_nn,   address);
            EmitByte  (OpCode.INC_iIX_d, +0);
            EmitOffset(OpCode.JR_NZ_e,   +3);    // did it overflow from 0xFF back around to 0x00?
            EmitByte  (OpCode.INC_iIX_d, +1);
        }
    }
    decGlobalB(uint operand, string typeName)
    {
        uint address = addressOperandToByte(operand);
        if (typeName == "byte")
        {
            EmitWord(OpCode.LD_HL_nn,    address);
            Emit    (OpCode.DEC_iHL);
        }
        else
        {
            EmitWord  (OpCode.LD_IX_nn,    address);
            EmitByte  (OpCode.DEC_iIX_d,  +0);
            EmitByte  (OpCode.LD_A_n,      0xFF);
            EmitByte  (OpCode.CP_A_iIX_d, +0); // wrapped around from 0x00 to 0xFF?
            EmitOffset(OpCode.JR_NZ_e,    +3);
            EmitByte  (OpCode.DEC_iIX_d,  +1);
        }
    }
    pushGlobalB(uint operand, <byte> globalReferenceSlots)
    {
        uint address = addressOperandToByte(operand);
        EmitWord(OpCode.LD_DE_inn, address);
        Emit    (OpCode.PUSH_DE);
        checkIncReferenceTop(byte(operand & 0xFF), globalReferenceSlots);
    }
    pushGlobalBB(uint operand0, uint operand1, <byte> globalReferenceSlots)
    {
        uint address0 = addressOperandToByte(operand0);
        uint address1 = addressOperandToByte(operand1);
        EmitWord(OpCode.LD_DE_inn, address0);
        Emit    (OpCode.PUSH_DE);
        checkIncReferenceTop(byte(operand0 & 0xFF), globalReferenceSlots);
        EmitWord(OpCode.LD_DE_inn, address1);
        Emit    (OpCode.PUSH_DE);
        checkIncReferenceTop(byte(operand1 & 0xFF), globalReferenceSlots);
    }
    
    popCopyLocalB(uint operand, <byte> localReferenceSlots)
    {    
        byte offset = offsetOperandToByte(operand);
    
        // this is the slot we are about to overwrite: decrease reference count    
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit      (OpCode.PUSH_DE);
        Emit      (OpCode.POP_IX);
        EmitByte  (OpCode.DEC_iIX_d,  +1);
        
        // oldvalue == newvalue?
        Emit      (OpCode.LD_A_D);
        EmitOffset(OpCode.CP_A_iIY_d, +0);
        EmitOffset(OpCode.JR_NZ_e, +6); // Different
        Emit      (OpCode.LD_A_E);
        EmitOffset(OpCode.CP_A_iIY_d, +1);
        EmitOffset(OpCode.JR_Z_e, +30);  // Exit:
// Different: 
        // clone self (top) 
        EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GCClone"));
        
        // release the original
        checkDecReferenceTop(byte(operand & 0xFF), localReferenceSlots);
        
        // cleanup stack    
        Emit    (OpCode.POP_DE); 
        
        // write clone to slot
        EmitByte(OpCode.LD_E_iIY_d, offset);
        EmitByte(OpCode.LD_D_iIY_d, offset + 1);
        Emit      (OpCode.PUSH_DE);
        Emit      (OpCode.POP_IX);
        EmitOffset(OpCode.LD_iIX_d_L,  +0);
        EmitOffset(OpCode.LD_iIX_d_H,  +1);
// Exit:        
        // overwriting self - no more to do        
    }
        
          
    
    popCopyGlobalB(uint operand, <byte> globalReferenceSlots)
    {    
        uint address = addressOperandToByte(operand);
        
        // this is the slot we are about to overwrite: decrease reference count
        EmitWord  (OpCode.LD_IX_nn,    address);
        EmitOffset(OpCode.LD_L_iIX_d,  +0);
        EmitOffset(OpCode.LD_H_iIX_d,  +1);
        Emit      (OpCode.PUSH_HL);
        checkDecReferenceTop(byte(operand & 0xFF), globalReferenceSlots);
        
        // oldvalue == newvalue?
        Emit      (OpCode.POP_DE);  // oldvalue
        Emit      (OpCode.POP_HL); 
        Emit      (OpCode.PUSH_HL); // top / newvalue
        Emit      (OpCode.LD_A_D);
        Emit      (OpCode.CP_A_H);
        EmitOffset(OpCode.JR_NZ_e, +4); // Different
        Emit      (OpCode.LD_A_E);
        Emit      (OpCode.CP_A_L);
        EmitOffset(OpCode.JR_Z_e, +30);  // Exit:
// Different:    
        // clone self (top) 
        EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GCClone"));
        
        // release the original
        checkDecReferenceTop(byte(operand & 0xFF), globalReferenceSlots);
        
        // cleanup stack    
        Emit    (OpCode.POP_DE); 
        
        // write clone to slot
        EmitWord  (OpCode.LD_IX_nn,    address);
        EmitOffset(OpCode.LD_iIX_d_L,  +0);
        EmitOffset(OpCode.LD_iIX_d_H,  +1);
        
// Exit:        
        // overwriting self - no more to do
    }
    popGlobalB(uint operand, <byte> globalReferenceSlots)
    {    
        uint address = addressOperandToByte(operand);
        checkDecReferenceTop(byte(operand & 0xFF), globalReferenceSlots);
        Emit    (OpCode.POP_DE);
        EmitWord(OpCode.LD_inn_DE, address);
    }
    
    <byte> DeleteSlot(<byte> referenceSlots, byte removeSlot)
    {
        <byte> slots;
        foreach (var slot in referenceSlots)
        {
            if (slot != removeSlot)
            {
                slots.Append(slot);
            }
        }
        return slots;
    }
    
    bool writeMethod(uint methodIndex, <byte> code)
    {
        bool success;
        if (entryIndex == methodIndex)
        {
            writeSystem();
        }        
        uint methodAddress   = output.Count;
        methods[methodIndex] = methodAddress;
        if (entryIndex == methodIndex)
        {
            reset();
        }
        
        <byte> localReferenceSlots;
        <byte> globalReferenceSlots;
        
        <uint, string> globalTypes = Code.GetGlobalTypes(); // <address,name> : global stack index and type name ("array", "string", ..)
        loop
        {
            //<string, <string> > localVariables  = Code.GetLocals(methodIndex);     // <name, type, offset>
            <string, <string> > localArguments  = Code.GetArguments(methodIndex);  // <ref, type, name>
            /*
            foreach (var kv in localVariables)
            {
                <string> info = kv.value;
                if (Types.IsArray(info[1]) || (info[1] == "string"))
                {
                    int offset;
                    _ = Int.TryParse(info[2], ref offset); 
                    if (offset.GetByte(1) != 0)
                    {
                        Die(0x0B);
                    }
                    localReferenceSlots.Append(offset.GetByte(0));
                }
            }
            */
            foreach (var kv in localArguments)
            {
                <string> info = kv.value;
                if (Types.IsArray(info[1]) || (info[1] == "string") || (info[1] == "array"))
                {
                    int offset;
                    _ = Int.TryParse(kv.key, ref offset);
                    if (offset.GetByte(1) != 0xFF)
                    {
                        Die(0x0B);
                    }
                    localReferenceSlots.Append(offset.GetByte(0));
                }
            }
            foreach (var kv in globalTypes)
            {
                if ((kv.value == "array") || (kv.value == "string"))
                {
                    uint slot = kv.key;
                    if (slot.GetByte(1) != 0)
                    {
                        Die(0x0B);
                    }
                    globalReferenceSlots.Append(slot.GetByte(0));
                }
            }
            break;
        }
        
        <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        
        <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        <uint,uint> jumpPatchLocations;   // <hopperAddress,patchAddress>
        
        uint index;
        int currentLocalSP = 0; // SP - BP
        bool referenceR0;
        bool wasPushGP;
        loop
        {
            if (index == code.Count) { success = true; break; }
            
            uint hopperAddress = index;
            instructionAddresses[hopperAddress] = output.Count;
            uint operand;
            Instruction instruction = Instructions.GetOperandAndNextAddress(code, ref index, ref operand);
            string instructionName = Instructions.ToString(instruction);
            
            
            bool isStackOffset;
            bool isAddressOffset;
            bool isRET;
            byte width = Instructions.GetKitchenSinkWidth(instruction, ref isStackOffset, ref isAddressOffset, ref isRET);
            
            // ### emit code here
            
            switch (instruction)
            {
                case Instruction.ENTER:
                {
                    // PUSH BP
                    Emit(OpCode.PUSH_IY); 
                    
                    // BP <- SP
                    EmitWord(OpCode.LD_inn_SP, SPBPSwapper);
                    EmitWord(OpCode.LD_IY_inn, SPBPSwapper);
                }
                case Instruction.ENTERB:
                {
                    // PUSH BP
                    Emit(OpCode.PUSH_IY); 
                    
                    // BP <- SP
                    EmitWord(OpCode.LD_inn_SP, SPBPSwapper);
                    EmitWord(OpCode.LD_IY_inn, SPBPSwapper);
                    
                    // Create some empty stack slots:
                    EmitWord(OpCode.LD_DE_nn, 0x0000);
                    
                    currentLocalSP += int(operand);
                    
                    if (operand <= 5) // don't do this : makes an extra case for Z80Dasm and Z80Opt
                    {
                        loop
                        {
                            Emit(OpCode.PUSH_DE); // up to 5 pushes is the same length as the alternative below, but faster
                            operand--;
                            if (operand == 0) { break; }
                        }
                    }
                    else
                    {
                        EmitByte(OpCode.LD_B_n, byte(operand));
                        Emit(OpCode.PUSH_DE);
                        EmitOffset(OpCode.DJNZ_e, -3);
                    }
                }
                case Instruction.SWAP:
                {
                    Emit(OpCode.POP_DE);
                    Emit(OpCode.POP_BC);   
                    Emit(OpCode.PUSH_DE);
                    Emit(OpCode.PUSH_BC);
                    
                    bool topIsReference  = localReferenceSlots.Contains(byte(currentLocalSP-1));
                    bool nextIsReference = localReferenceSlots.Contains(byte(currentLocalSP-2));
                    if (topIsReference && !nextIsReference)
                    {
                         localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                         localReferenceSlots.Append(byte(currentLocalSP-2));
                    }
                    else if (!topIsReference && nextIsReference)
                    {
                        localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-2));
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                case Instruction.DUP:
                {
                    if (operand != 0) 
                    {
                        Die(0x0A);
                    }
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.PUSH_HL);
                    Emit(OpCode.PUSH_HL);
                    
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(byte(currentLocalSP-2)))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                        checkIncReferenceTop(byte(currentLocalSP-1), localReferenceSlots);
                    }
                }
                case Instruction.DUP0:
                {
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.PUSH_HL);
                    Emit(OpCode.PUSH_HL);
                    
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(byte(currentLocalSP-2)))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                        checkIncReferenceTop(byte(currentLocalSP-1), localReferenceSlots);
                    }
                }
                case Instruction.DECSP:
                {
                    loop
                    {
                        if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                        {
                            checkDecReferenceTop(byte(currentLocalSP-1), localReferenceSlots);
                            localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                        }
                        currentLocalSP--;
                        
                        Emit(OpCode.POP_DE);
                        operand--;
                        if (operand == 0) { break; }
                    }
                }
                case Instruction.PUSHD:
                {
                    Emit(OpCode.DDDD); // for patch signature used for validation and for the optimizer
                    EmitWord(OpCode.LD_DE_nn, operand);    
                    patches[output.Count-2] = operand; // patch it like a method
                    Emit(OpCode.PUSH_DE);
                    currentLocalSP++;
                }
                case Instruction.CALL:
                {
                    EmitWord(OpCode.CALL_nn, uint(operand));
                    patches[output.Count-2] = operand;
                }
                case Instruction.RETB:
                {
                    if (methodIndex == 0)
                    {
                        // release all globals:
                        foreach (var slot in globalReferenceSlots)
                        {
                            uint address = addressOperandToByte(slot);
                            EmitWord(OpCode.LD_DE_inn, address);
                            Emit    (OpCode.PUSH_DE);
                            EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GCRelease"));
                            Emit    (OpCode.POP_DE); // cleanup stack
                        }
                    }
                    
                    loop
                    {
                        if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                        {
                            checkDecReferenceTop(byte(currentLocalSP-1), localReferenceSlots);
                            localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                        }
                        currentLocalSP--;
                        
                        Emit(OpCode.POP_DE);
                        operand--;
                        if (operand == 0) { break; }
                    }
                
                    // POP BP
                    Emit(OpCode.POP_IY); 
                    Emit(OpCode.RET);
                }
                case Instruction.RET0:
                {
                    // POP BP
                    Emit(OpCode.POP_IY); 
                    Emit(OpCode.RET);
                }
                case Instruction.RETFAST:
                {
                    Emit(OpCode.RET);
                }
                
                
                case Instruction.ADD:
                {
                    if (wasPushGP)
                    {
                        // pushing global as ref argument
                        Emit(OpCode.POP_HL);    // GP
                        Emit(OpCode.POP_DE);    // offset
                        Emit(OpCode.XOR_A_A);
                        Emit(OpCode.SBC_HL_DE); // *2
                        Emit(OpCode.SBC_HL_DE);
                        EmitWord(OpCode.LD_DE_nn, 4);
                        Emit(OpCode.SBC_HL_DE);
                        Emit(OpCode.PUSH_HL);     
                        wasPushGP = false;
                    }
                    else
                    {
                        Emit(OpCode.POP_DE);    
                        Emit(OpCode.POP_HL);    
                        Emit(OpCode.ADD_HL_DE);
                        Emit(OpCode.PUSH_HL);  
                    }
                    
                    currentLocalSP--;
                }
                case Instruction.ADDI:
                {
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.ADD_HL_DE);
                    Emit(OpCode.PUSH_HL);  
                    
                    currentLocalSP--;
                }
                case Instruction.SUB:
                case Instruction.SUBI:
                {
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.AND_A); // clear carry
                    Emit(OpCode.SBC_HL_DE);
                    Emit(OpCode.PUSH_HL);  
                    
                    currentLocalSP--;
                }
                case Instruction.ADDB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.ADD_HL_DE);
                    Emit(OpCode.PUSH_HL);
                }
                case Instruction.SUBB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);
                    Emit(OpCode.POP_HL);    
                    Emit(OpCode.AND_A); // clear carry
                    Emit(OpCode.SBC_HL_DE);
                    Emit(OpCode.PUSH_HL);
                }
                
                case Instruction.MUL:
                {
                    // top -> BC, next -> DE
                    // HL = next * top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_DE);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MUL"));
                    Emit(OpCode.PUSH_HL);  
                    
                     currentLocalSP--; 
                }
                case Instruction.DIV:
                {
                    // top -> DE, next -> BC
                    // BC = next / top
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVMOD"));
                    Emit(OpCode.PUSH_BC); 
                    
                    currentLocalSP--; 
                }
                case Instruction.MOD:
                {
                    // top -> DE, next -> BC
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVMOD"));
                    Emit(OpCode.PUSH_HL);
                    
                    currentLocalSP--;
                }
                case Instruction.MULI:
                {
                    // top -> BC, next -> DE
                    // HL = next * top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_DE);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MULI"));
                    Emit(OpCode.PUSH_HL);  
                    
                    currentLocalSP--;
                }
                case Instruction.DIVI:
                {
                    // top -> DE, next -> BC
                    // BC = next / top
                    // HL = next % top
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("DIVI"));
                    Emit(OpCode.PUSH_BC);  
                    
                    currentLocalSP--;  
                }
                case Instruction.MODI:
                {
                    // top -> DE, next -> BC
                    // HL = next % top, always positive signed result
                    Emit(OpCode.POP_DE);    
                    Emit(OpCode.POP_BC);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("MODI"));
                    Emit(OpCode.PUSH_HL);
                    
                    currentLocalSP--;
                }
                
                case Instruction.BITSHL:
                {
                    // top -> BC, next -> HL
                    // HL = next  << top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITSHL"));
                    Emit(OpCode.PUSH_HL);   
                    
                    currentLocalSP--;
                }
                case Instruction.BITSHR:
                {
                    // top -> BC, next -> HL
                    // HL = next  >> top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITSHR"));
                    Emit(OpCode.PUSH_HL);  
                    
                    currentLocalSP--;  
                }
                case Instruction.BOOLAND:
                case Instruction.BITAND:
                {
                    // top -> BC, next -> HL
                    // HL = next & top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    //EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITAND"));
                    EmitBITAND();
                    Emit(OpCode.PUSH_HL);
                    
                    currentLocalSP--;
                }
                case Instruction.BOOLOR:
                case Instruction.BITOR:
                {
                    // top -> BC, next -> HL
                    // HL = next & top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    //EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITOR"));
                    EmitBITOR();
                    Emit(OpCode.PUSH_HL);  
                    
                    currentLocalSP--;
                }
                case Instruction.BITXOR:
                {
                    // top -> BC, next -> HL
                    // HL = next ^ top
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);
                    //EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITXOR"));
                    EmitBITXOR();
                    Emit(OpCode.PUSH_HL);    
                }
                case Instruction.BITNOT:
                {
                    // top = ~top
                    Emit(OpCode.POP_HL);
                    //EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("BITNOT"));
                    EmitBITNOT();
                    Emit(OpCode.PUSH_HL);  
                    
                    currentLocalSP--;  
                }
                case Instruction.BOOLNOT:
                {
                    // assumes [top] is 0 or 1
                    Emit    (OpCode.EX_iSP_HL);
                    Emit    (OpCode.LD_A_L);   
                    EmitByte(OpCode.XOR_A_n, 1);  
                    Emit    (OpCode.LD_L_A);  
                    Emit    (OpCode.EX_iSP_HL);
                }
                
                case Instruction.BITSHL8:
                {
                    // top = top << 8
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.LD_H_L);                   
                    EmitByte(OpCode.LD_L_n, 0);   
                    Emit(OpCode.PUSH_HL);    
                }
                case Instruction.BITSHR8:
                {
                    // top = top >> 8
                    Emit(OpCode.EX_iSP_HL);
                    Emit(OpCode.LD_L_H);                   
                    EmitByte(OpCode.LD_H_n, 0);
                    Emit(OpCode.EX_iSP_HL);
                }
                case Instruction.BITANDFF:
                {
                    // top = top & 0x00FF
                    Emit(OpCode.EX_iSP_HL);
                    EmitByte(OpCode.LD_H_n, 0);                   
                    Emit(OpCode.EX_iSP_HL);
                }
                
                case Instruction.PUSHIBLE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand & 0xFF);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LE"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHIBEQ:
                {
                    // next -> HL, top -> BC   
                    // EQ: DE = HL == BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand & 0xFF);    
                    Emit(OpCode.POP_HL);    
                    //EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("EQ"));
                    EmitEQ();
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHILT:
                {
                    // next -> HL, top -> BC
                    // LT: DE = HL < BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LT"));
                    Emit(OpCode.PUSH_DE);
                }
                case Instruction.PUSHILEI:
                {
                    // next -> HL, top -> BC
                    // LT: DE = HL < BC ? 1 : 0 
                    EmitWord(OpCode.LD_BC_nn, operand);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LEI"));
                    Emit(OpCode.PUSH_DE);
                }
                
                case Instruction.LE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LE"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                case Instruction.GE:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL >= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GE"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                case Instruction.LT:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL < BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LT"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                case Instruction.GT:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL > BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GT"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                
                case Instruction.LTI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL < BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LTI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                case Instruction.LEI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL <= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("LEI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                case Instruction.GTI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL > BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GTI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                case Instruction.GEI:
                {
                    // next -> HL, top -> BC
                    // LE: DE = HL >= BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("GEI"));
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                
                case Instruction.EQ:
                {
                    // next -> HL, top -> BC
                    // EQ: DE = HL == BC ? 1 : 0 
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    //EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("EQ"));
                    EmitEQ();
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                case Instruction.NE:
                {
                    // next -> HL, top -> BC
                    // EQ: DE = HL != BC ? 1 : 0
                    Emit(OpCode.POP_BC);    
                    Emit(OpCode.POP_HL);    
                    //EmitWord(OpCode.CALL_nn, Z80Library.GetAddress("NE"));
                    EmitNE();
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP--;
                }
                
                case Instruction.JZB:
                {
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.LD_A_L);
                    Emit(OpCode.OR_A_H);
                    EmitWord(OpCode.JP_Z_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                    
                    currentLocalSP--;
                }
                case Instruction.JNZB:
                {
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.LD_A_L);
                    Emit(OpCode.OR_A_H);
                    EmitWord(OpCode.JP_NZ_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                    
                    currentLocalSP--;
                }
                case Instruction.JB:
                {
                    EmitWord(OpCode.JP_nn, uint(0));
                    int offset = byte(operand);
                    if (offset > 127)
                    {
                        offset -= 256;
                    }
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = offset;
                }
                
                case Instruction.JZ:
                {
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.LD_A_L);
                    Emit(OpCode.OR_A_H);
                    EmitWord(OpCode.JP_Z_nn, uint(0));
                    int ioffset = Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8));
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = ioffset;
                    
                    currentLocalSP--;
                }
                case Instruction.JNZ:
                {
                    Emit(OpCode.POP_HL);
                    Emit(OpCode.LD_A_L);
                    Emit(OpCode.OR_A_H);
                    EmitWord(OpCode.JP_NZ_nn, uint(0));
                    int ioffset = Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8));
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches[hopperAddress]        = ioffset;
                    
                    currentLocalSP--;
                }
                
                case Instruction.J:
                {
                    EmitWord(OpCode.JP_nn, uint(0));
                    int ioffset = Int.FromBytes(byte(operand & 0xFF), byte(operand >> 8));                        
                    jumpPatchLocations[hopperAddress] = output.Count - 2;
                    jumpPatches       [hopperAddress] = ioffset;
                }
                                
                case Instruction.CAST:
                {
                    // NOP
                }
                case Instruction.NOP:
                {
                    // NOP
                }
                
                case Instruction.PUSHIB:
                case Instruction.PUSHI:
                {
                    EmitWord(OpCode.LD_DE_nn, operand);    
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP++;
                }
                case Instruction.PUSHI0:
                {
                    EmitWord(OpCode.LD_DE_nn, 0);    
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP++;
                }
                case Instruction.PUSHI1:
                {
                    EmitWord(OpCode.LD_DE_nn, 1);    
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP++;
                }
                case Instruction.PUSHIBB:
                {
                    EmitWord(OpCode.LD_DE_nn, operand & 0xFF);    
                    Emit(OpCode.PUSH_DE);
                    EmitWord(OpCode.LD_DE_nn, operand >> 8);    
                    Emit(OpCode.PUSH_DE);
                    
                    currentLocalSP += 2;
                }
                case Instruction.PUSHGP:
                {
                    EmitWord(OpCode.LD_DE_nn, StackAddress + StackSize);
                    Emit(OpCode.PUSH_DE);
                    wasPushGP = true;
                    currentLocalSP++;
                }
                
                
                
                case Instruction.PUSHSTACKADDRB:
                {
                    pushStackAddrB(byte(operand & 0xFF));
                    
                    currentLocalSP++;
                }
                case Instruction.PUSHRELB:
                {
                    pushRelB(operand, localReferenceSlots);
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(byte(operand)))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                case Instruction.POPRELB:
                {
                    popRelB(operand, localReferenceSlots);
                    if (localReferenceSlots.Contains(byte(operand)))
                    {
                        localReferenceSlots = DeleteSlot(localReferenceSlots, byte(operand));
                    }
                    currentLocalSP--;
                }
                                
                case Instruction.PUSHLOCALB:
                {
                    pushLocalB(operand, localReferenceSlots);
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(byte(operand)))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                case Instruction.PUSHLOCALB00:
                {
                    pushLocalB(0, localReferenceSlots);
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(0))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                case Instruction.PUSHLOCALB01:
                {
                    pushLocalB(1, localReferenceSlots);
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(1))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                case Instruction.PUSHLOCALBB:
                {
                    pushLocalBB(operand & 0xFF, operand >> 8, localReferenceSlots);
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(byte(operand & 0xFF)))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                    currentLocalSP++;
                    if (localReferenceSlots.Contains(byte(operand >> 8)))
                    {
                        localReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                
                case Instruction.PUSHR0:
                {
                    Emit(OpCode.PUSH_HL);
                    currentLocalSP++;
                    if (referenceR0)
                    {
                        if (!localReferenceSlots.Contains(byte(currentLocalSP-1)))
                        {
                            localReferenceSlots.Append(byte(currentLocalSP-1));
                        }
                        checkIncReferenceTop(byte(currentLocalSP-1), localReferenceSlots);
                    }
                }
                case Instruction.POPR0:
                {
                    referenceR0 = false;
                    Emit(OpCode.POP_HL);
                    if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        checkDecReferenceTop(byte(currentLocalSP-1), localReferenceSlots);
                        localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                        referenceR0 = true;
                    }
                    currentLocalSP--;
                }
                case Instruction.POPCOPYLOCALB:
                {
                    if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        Die(0x0B); // instruction implies reference type
                    }
                    popCopyLocalB(operand, localReferenceSlots);
                    localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                    currentLocalSP--;
                }
                case Instruction.POPCOPYLOCALB00:
                {
                    if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        Die(0x0B); // instruction implies reference type
                    }
                    popCopyLocalB(0, localReferenceSlots);
                    localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                    currentLocalSP--;
                }
                case Instruction.POPCOPYLOCALB01:
                {
                    if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        Die(0x0B); // instruction implies reference type
                    }
                    popCopyLocalB(1, localReferenceSlots);
                    localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                    currentLocalSP--;
                }
                
                case Instruction.POPLOCALB:
                {
                    popLocalB(operand, localReferenceSlots);
                    if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                    }
                    currentLocalSP--;
                }
                case Instruction.POPLOCALB00:
                {
                    popLocalB(0, localReferenceSlots);
                    if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                    }
                    currentLocalSP--;
                }
                case Instruction.POPLOCALB01:
                {
                    popLocalB(1, localReferenceSlots);
                    if (localReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        localReferenceSlots = DeleteSlot(localReferenceSlots, byte(currentLocalSP-1));
                    }
                    currentLocalSP--;
                }
                case Instruction.INCLOCALBB:
                case Instruction.INCLOCALIBB:
                {
                    incLocalBB(operand & 0xFF, operand >> 8);
                }
                case Instruction.INCLOCALB:
                case Instruction.INCLOCALIB:
                {
                    incLocalB(operand);
                }
                case Instruction.DECLOCALB:
                case Instruction.DECLOCALIB:
                {
                    decLocalB(operand);
                }
                
                case Instruction.PUSHGLOBALB:
                {
                    pushGlobalB(operand, globalReferenceSlots);
                    currentLocalSP++;
                    if (globalReferenceSlots.Contains(byte(operand)))
                    {
                        globalReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                case Instruction.PUSHGLOBALBB:
                {
                    pushGlobalBB(operand & 0xFF, operand >> 8, globalReferenceSlots);
                    currentLocalSP++;
                    if (globalReferenceSlots.Contains(byte(operand & 0xFF)))
                    {
                        globalReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                    currentLocalSP++;
                    if (globalReferenceSlots.Contains(byte(operand >> 8)))
                    {
                        globalReferenceSlots.Append(byte(currentLocalSP-1));
                    }
                }
                case Instruction.POPCOPYGLOBALB:
                {
                    if (globalReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        Die(0x0B); // instruction implies reference type
                    }
                    popCopyGlobalB(operand, globalReferenceSlots);
                    globalReferenceSlots = DeleteSlot(globalReferenceSlots, byte(currentLocalSP-1));
                    currentLocalSP--;
                }
                case Instruction.POPGLOBALB:
                {
                    popGlobalB(operand, globalReferenceSlots);
                    if (globalReferenceSlots.Contains(byte(currentLocalSP-1)))
                    {
                        globalReferenceSlots = DeleteSlot(globalReferenceSlots, byte(currentLocalSP-1));
                    }
                    currentLocalSP--;
                }
                case Instruction.INCGLOBALB:
                {
                    incGlobalB(operand, globalTypes[operand]);
                }
                case Instruction.DECGLOBALB:
                {
                    decGlobalB(operand, globalTypes[operand]);
                }
                
                case Instruction.SYSCALL0:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0, ref referenceR0)) { break; }
                }
                case Instruction.SYSCALL00:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0, ref referenceR0)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 0, ref referenceR0)) { break; }
                }
                case Instruction.SYSCALL01:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 0, ref referenceR0)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 1, ref referenceR0)) { break; }
                }
                case Instruction.SYSCALL10:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 1, ref referenceR0)) { break; }
                    if (!Z80Library.SysCall(byte(operand >> 8), 0, ref referenceR0)) { break; }
                }
                case Instruction.SYSCALL1:
                {
                    if (!Z80Library.SysCall(byte(operand & 0xFF), 1, ref referenceR0)) { break; }
                }
                case Instruction.SYSCALLB0:
                {
                    EmitWord(OpCode.LD_DE_nn, operand & 0xFF);    
                    Emit(OpCode.PUSH_DE);
                    currentLocalSP++;
                    if (!Z80Library.SysCall(byte(operand >> 8), 0, ref referenceR0)) { break; }
                }
                
                default:
                {
                    if (firstOpNotImplemented)
                    {
                        PrintLn(Instructions.ToString(instruction) + " not implemented in 0x" + methodIndex.ToHexString(4));
                    }
                    firstOpNotImplemented = false;
                    Emit(OpCode.NOP);
                    break;
                }
            } // switch
            
            if (methodIndex == 0xFFFF)
            {
                //if ((instruction == Instruction.RETFAST) || (instruction == Instruction.RETB) || (instruction == Instruction.RET0))
                //{
                    PrintLn();
                    Print("   " + Instructions.ToString(instruction) + " " + operand.ToHexString(4) + " " + currentLocalSP.ToString());
                //}
            }
        } // loop
        
        if (currentLocalSP != 0)
        {
            PrintLn();
            Print(methodIndex.ToHexString(4) + ": Stack mismatch: " + currentLocalSP.ToString());
            PrintLn();
        }
        
        // <uint,uint> instructionAddresses; // <hopperAddress,z80Address>
        // <uint,int>  jumpPatches;          // <hopperAddress,jumpOffset>
        // <uint,uint> jumpPatchLocations    // <hopperAddress,patchAddress>
        //PrintLn(methodIndex.ToString() + ":");
        if (success)
        {
            foreach (var kv in jumpPatches)
            {
                uint hopperJumpLocation = kv.key;
                int  offset = kv.value;
                
                uint hopperJumpTarget = uint(int(hopperJumpLocation) + offset);
                if (!instructionAddresses.Contains(hopperJumpTarget))
                {
                    if (firstPatchFailed)
                    {
                        if (firstPatchFailed)
                        {
                            PrintLn("Patch failed: " + hopperJumpLocation.ToHexString(4) + " " + offset.ToString() + " " + hopperJumpTarget.ToHexString(4));
                        }
                        firstPatchFailed = false;
                    }
                }
                else
                {
                    uint targetAddress    = instructionAddresses[hopperJumpTarget];
                    uint patchLocation    = jumpPatchLocations[hopperJumpLocation];
                
                    // PATCH
                    uint methodLength = output.Count - methodAddress;
                    if (!jumpPatch(methodIndex, patchLocation, targetAddress, methodAddress, methodLength))
                    {
                        success = false;
                    }
                }
            }
        }
        bool modified;
        <string,string> debugInfo = Code.GetMethodDebugInfo(methodIndex);
        <string,string> z80DebugInfo;
        foreach (var kv in debugInfo)
        {
            string hopperAddress = kv.key;
            string lineNumber    = kv.value;
            uint hopperIndex;
            if (UInt.TryParse(hopperAddress, ref hopperIndex))
            {
                if (success || instructionAddresses.Contains(hopperIndex))
                {
                    uint z80Index = instructionAddresses[hopperIndex];
                    z80DebugInfo["0x" + z80Index.ToHexString(4)] = lineNumber;
                    modified = true;
                }
            }
        }
        // save the modified debugInfo
        if (modified)
        {        
            Code.SetMethodDebugInfo(methodIndex, z80DebugInfo);
        }
        return success;
    }
    
    
    badArguments()
    {
        PrintLn("Invalid arguments for Z80GEN:");
        PrintLn("  Z80GEN <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
    }
    
    byte hexCheckSum(string values)
    {
        uint sum = 0;
        for (uint i = 0; i < values.Length / 2; i++)
        {
            string substr = values.Substring(i * 2, 2);
            uint b = 0;
            if (UInt.TryParse("0x" + substr, ref b))
            {
            }
            sum = sum + b;
        }
        sum = sum % 256;
        byte chk = byte(sum);
        chk = ~chk;
        chk++;
        return chk;
    }
    
    emitBuffer(file ihexFile, uint address, string buffer)
    {
        uint bytes = buffer.Length / 2;
        string ln = bytes.ToHexString(2) + address.ToHexString(4) + "00" + buffer;
        byte chk = hexCheckSum(ln);
        ihexFile.Append(":" + ln + chk.ToHexString(2) + Char.EOL);
    }
    
    writeIHex(file ihexFile, uint romAddress, <byte> output)
    {
        // https://en.wikipedia.org/wikie/Intel_HEX#Format
        
        uint byteCount = 0;
        uint index = 0;
        
        byte currentTick = 0;
        Parser.ProgressTick("i"); // writeIHex
        
        string buffer;
        uint emitAddress = 0;
        loop
        {
            if (index == output.Count)
            {
                // done
                break;
            }
            byte cb = output[index]; index++;
            
            buffer = buffer + cb.ToHexString(2);
            if (buffer.Length == 32)
            {
                emitBuffer(ihexFile, emitAddress + romAddress, buffer);
                emitAddress = emitAddress + 16;
                buffer = "";
            }
            
            if (byteCount % 8192 == 0)
            {
                Parser.ProgressTick("i"); // writeIHex
            }
            byteCount++;
            
        }
        if (buffer.Length != 0)
        {
            emitBuffer(ihexFile, emitAddress + romAddress, buffer);
            buffer = "";
        }
        
        ihexFile.Append(":00000001FF" + Char.EOL); // eof
        ihexFile.Flush();
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string ihexPath  = codePath.Replace(extension, ".hex");
                string symbolsPath = codePath.Replace(extension, ".sym");
                
                ihexPath = Path.GetFileName(ihexPath);
                ihexPath = Path.Combine("/Bin/", ihexPath);
                File.Delete(ihexPath);

                file ihexFile = File.Create(ihexPath);
                if (!ihexFile.IsValid())
                {
                    PrintLn("Failed to create '" + ihexPath + "'");
                    break;
                }
                
                Symbols.New();
                if (File.Exists(symbolsPath))
                {
                    if (Symbols.Import(symbolsPath, false))
                    {
                        CodeStream.InitializeSymbolShortcuts();
                    }
                    if (DefineExists("ROM_32K"))
                    {
                        romSize = 0x8000;
                    }
                    if (DefineExists("ROM_16K"))
                    {
                        romSize = 0x4000;
                    }
                    if (DefineExists("ROM_8K"))
                    {
                        romSize = 0x2000;
                    }
                    if (DefineExists("ROM_4K"))
                    {
                        romSize = 0x1000;
                    }
                    if (DefineExists("ROM_1K"))
                    {
                        romSize = 0x0400;
                    }
                }
                
                if (!ParseCode(codePath, true, true))
                {
                    break;
                }
                
                uint methodCount = Code.GetMethodCount();
                
                <byte> constantData = Code.GetConstantData();
                if (constantData.Count != 0)
                {
                    PrintLn("Unexpected constant data"); // reference types not supported
                    break;
                }
                entryIndex = Code.GetEntryIndex();
                <uint, uint> methodSizes = Code.GetMethodSizes();
                <uint,uint>  framelessMethodCandidates = Code.GetFramelessMethodCandidates();
                Parser.ProgressTick("g");
                
                // stack needs to exist before our first CALL
                // start pointing one byte beyond since it grows downward
                Emit(OpCode.DI);
                EmitWord(OpCode.LD_SP_nn, StackAddress + StackSize); 
                EmitWord(OpCode.CALL_nn, 0);
                Emit(OpCode.HALT);
                
                <byte> methodCode = Code.GetMethodCode(entryIndex);
                bool failed = !writeMethod(entryIndex, methodCode);
                Parser.ProgressTick("g");
                uint indexMax = 0;
                foreach (var sz in methodSizes)
                {
                    if (sz.key > indexMax)
                    {
                        indexMax = sz.key;
                    }
                }
                if (!failed)
                {
                    uint total = output.Count;
                    // if we emit the methods in increasing order of indices
                    // then we can find them again in the binary (for debug info)
                    uint count = 1;
                    uint progressCount;
                    for (uint index = 0; index <= indexMax; index++)
                    {
                        if (index == entryIndex)          { continue; }
                        if (!methodSizes.Contains(index)) { continue; }   
                        methodCode = Code.GetMethodCode(index);
                        uint startAddress = output.Count;
                        if (!writeMethod(index, methodCode))
                        {
                            failed = true;
                            break;
                        }
                        if (progressCount % 64 == 0)
                        {
                            Parser.ProgressTick("g");
                        }
                        progressCount++;
                        count++;
                        if (output.Count > 0xF000)
                        {
                            PrintLn();
                            PrintLn("0x"  + (output.Count).ToHexString(4) + " bytes Z80 assembly generated.", Colour.Red, Colour.Black);
                            PrintLn("Only on method " + count.ToString() + " of " + (methodSizes.Count).ToString() + ". Abandoning build.", Colour.Red, Colour.Black);
                            failed = true;
                            break;
                        }
                        uint length = output.Count - startAddress;
                        total += length;
                        if (false && (length > 500))
                        {
                            PrintLn();
                            Print("  0x" + index.ToHexString(4) + ": 0x" + startAddress.ToHexString(4) + " length: " + length.ToString() + " total: " + total.ToString() + " size: " + (methodCode.Count).ToString());
                        }
                    }
                }
                doCallPatches(failed);
                
                Parser.ProgressTick(".");
                writeIHex(ihexFile, 0x0000, output);
                string zcodePath = codePath.Replace(".code", ".zcode");
                File.Delete(zcodePath);
                if (!Code.ExportCode(zcodePath, false)) // after
                {
                    break;
                }
                if (failed)
                {
                    break;
                }
                codeSize = output.Count;
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    
                    Print("Success, " + codeSize.ToString() + " bytes of code, ", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
