program Compile
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define SHORT_CALLS  // use CALLB to save space
    
    uses "/Source/System/System"
    uses "/Source/System/Diagnostics"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    uses "Tokens/SysCalls"
    uses "Tokens/LibCalls"

    uses "Symbols"
    uses "Types"
    uses "Expression"
    uses "Constant"
    uses "Record"
    
    uses "Directives"
    
    uses "CodeGen/Instructions"
    uses "CodeGen/CodeStream"
    uses "CodeGen/Peephole"
    uses "CodeGen/Block"
    
    bool IsDebugger  { get { return false; } }
    
    uint iCurrentOverload;
    
    string CurrentUnit { get { return ""; } }
    
    uint spaces; 
    DebugComment(string caption, bool prev)
    {
        string content;
        for (uint i=0; i < spaces; i++)
        {
            content = content + "..";
        }
        <string,string> lineToken = CurrentToken;
        if (prev)
        {
            lineToken = PreviousToken;
        }
        content = content + caption + ":" + lineToken["line"] + "," + lineToken["pos"];
        if (lineToken["type"] == "Keyword")
        {
            content = content + ",'" + lineToken["lexeme"] + "'";
        }
        else
        {
            content = content + "," + lineToken["type"];
        }
        OutputDebug(content); // DebugComment
    } 
    
    bool compileIfStatement()
    {
        bool success = false;
        bool wasElse = false;
        <uint> jumpEnds;
        loop
        {
            CodeStream.InsertDebugInfo(false); // could be a 2nd 'else if'
            
            Parser.Advance(); // if
            
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            string ifCheckType = CompileExpression("bool");
            if (Parser.HadError)
            {
                break;
            }
            if ("bool" != ifCheckType)
            {
                Parser.Error("boolean expression expected, (was '" + ifCheckType + "')");
                break;
            }      
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            // if false jump past
            uint jumpPast = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.JZ);
            
            Block.PushBlock(false); // not a loop context
            compileBlock();
            Block.PopBlock();
            if (Parser.HadError)
            {
                break;
            }
            
            CodeStream.InsertDebugInfo(true);
            
            // jump end (past a potential "else" block)
            uint jumpEnd = CodeStream.NextAddress;
            jumpEnds.Append(jumpEnd);
            CodeStream.AddInstructionJump(Instruction.J);
// past:    
            uint pastAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(jumpPast, pastAddress);        
                        
            if (Parser.CheckKeyword("else"))
            {
                wasElse = true; // there was at least one else clause
                Advance(); // else
                if (Parser.CheckKeyword("if"))
                {
                    continue; // else if
                }   
                // final else block
                Block.PushBlock(false); // not a loop context
                compileBlock();
                Block.PopBlock();
            }
// end:     
            if (wasElse)
            {       
                foreach (var jump in jumpEnds)
                {
                    CodeStream.PatchJump(jump, CodeStream.NextAddress);
                }
            }
            else
            {
                // simple if with no "else" clause/s
                CodeStream.PopTail(3);
                CodeStream.PatchJump(jumpPast, pastAddress-3);
            }
            success = true;                    
            break;
        }
        return success;
    }
    
    bool compileReturn()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // return
            string returnType = "void";
            <string,variant> blockContext = Block.GetMethodBlock();
            uint returnBytes = 0;
            if (blockContext.Count != 0)
            {
                if (blockContext.Contains("returntype"))
                {
                    returnType = blockContext["returntype"];
                    string actualReturnType = CompileExpression(returnType);
                    if (actualReturnType != returnType)
                    {
                        if (Types.AutomaticUpCastTop(actualReturnType, returnType))
                        {
                            // ok
                        }
                        else
                        {
                            Parser.Error("invalid return type, (was '" + actualReturnType + "', expected '"+ returnType +"')");
                            break;
                        }
                    }
                    if (IsCDecl)
                    {
                        CodeStream.AddInstruction(Instruction.POPR0);
                    }
                    else
                    {
                        returnBytes = 1;
                    }
                }
            }
            if (CodeStream.CheckedBuild)
            {            
                // if you pop locals and the return value, sp == bp
                uint localsToPop = Block.GetLocalsToPop(false, false) + returnBytes;
                CodeStream.AddInstruction(Instruction.TESTBPB, byte(localsToPop));
            }
            
            // slotsToPop = locals + arguments
            uint slotsToPop = Block.GetLocalsToPop(true, false);
            if (!NoPackedInstructions && (slotsToPop == 0))
            {
                // if there is a return value, then it is already exactly where it needs to be
                CodeStream.AddInstruction(Instruction.RET0);
            }
            else if ((returnBytes > 0) && !IsCDecl)
            {
                if (!NoPackedInstructions && (slotsToPop < 256))
                {
                    CodeStream.AddInstruction(Instruction.RETRESB, byte(slotsToPop));
                }
                else
                {
                    CodeStream.AddInstruction(Instruction.RETRES, slotsToPop);
                }
            }
            else
            {
                if (IsCDecl && (returnBytes > 0))
                {
                    CodeStream.AddInstruction(Instruction.POPR0);
                }
                if (!NoPackedInstructions && (slotsToPop < 256))
                {
                    CodeStream.AddInstruction(Instruction.RETB, byte(slotsToPop));
                }
                else
                {
                    CodeStream.AddInstruction(Instruction.RET, slotsToPop);
                }
            }
            
            if (IsZ80)
            {
                <string, string> peekToken = Scanner.Peek();
                HopperToken tokenType = Token.GetType(peekToken);   
                if ((BlockDepth() > 2) || (tokenType != HopperToken.RBrace))
                {
                    uint localsToPop = Block.GetLocalsToPop(false, false);
                    if (localsToPop > 0)
                    {
                        Parser.Error("Z80 compiler requires single point of exit locals defined");
                        break;
                    }
                }
            }
            
            success = true;
            break;
        }
        return success;
    }
    
    bool compileBreak()
    {
        bool success = true;
        loop
        {
            Parser.Advance(); // break;
        
            if (IsZ80)
            {
                uint localsToPop = Block.GetBytesToPop(true, false);
                if (localsToPop > 0)
                {
                    Parser.Error("Z80 compiler does not allow 'break' when locals are popped");
                    success = false;
                    break;
                }
            }
            
            // - pop all locals till inner loop
            uint slotsToPop = Block.GetBytesToPop(true, false);
            if (slotsToPop > 0)
            {
                while (slotsToPop > 255)
                {
                    CodeStream.AddInstruction(Instruction.DECSP, 0xFE); // even numbered stack slots (254, not 255)
                    slotsToPop = slotsToPop - 254; 
                }
                if (slotsToPop > 0)
                {
                    CodeStream.AddInstruction(Instruction.DECSP, byte(slotsToPop));
                }
            }
                   
            // - jump to current inner loop 'exit'
            uint breakJump = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.J);
            if (!Block.AddBreakPatch(breakJump))
            {
                Parser.ErrorAtCurrent("'break' must be inside loop block");
                success = false;
            }
            break;
        } // loop
        
        return success;
    }
    
    bool compileContinue()
    {
        bool success = true;
        loop
        {
            Parser.Advance(); // continue;
            
            if (IsZ80)
            {
                uint localsToPop = Block.GetBytesToPop(true, true);
                if (localsToPop > 0)
                {
                    Parser.Error("Z80 compiler does not allow 'continue' when locals are popped");
                    success = false;
                    break;
                }
            }
            
            // - pop all locals till inner loop
            uint slotsToPop = Block.GetBytesToPop(true, true);
            if (slotsToPop > 0)
            {
                if (slotsToPop > 255)
                {
                    Die(0x0B); // limit
                }
                CodeStream.AddInstruction(Instruction.DECSP, byte(slotsToPop));
            }
            // - jump to current inner loop 'next'
            uint continueJump = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.J);
            if (!Block.AddContinuePatch(continueJump))
            {
                Parser.ErrorAtCurrent("'continue' must be inside loop block");
                success = false;
            }
            break;
        }
        
        return success;
    }
    
    bool compileWhile()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // while
            
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }

// continueAddress:    
            uint continueAddress = CodeStream.NextAddress;                    
            
            string whileCheckType = CompileExpression("bool");
            if ("bool" != whileCheckType)
            {
                Parser.Error("boolean expression expected, (was '" + whileCheckType + "')");
                break;
            }      
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            // if false jump exit
            uint jumpExit = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.JZ);
            
            Block.PushBlock(true); // loop block context
            
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            
            CodeStream.InsertDebugInfo(true);
            
            CodeStream.AddInstructionJump(Instruction.J, continueAddress);
// exit:            
            uint breakAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(jumpExit, breakAddress);
            
            Block.PopBlock(continueAddress, breakAddress);
            
            if (Parser.HadError)
            {
                break;
            }
            success = true;                    
            break;
        }
        return success;
    }
    
    bool compileLoop()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // loop

            Block.PushBlock(true); // loop context
            uint continueAddress = CodeStream.NextAddress;
            
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            CodeStream.InsertDebugInfo(true);
            
            CodeStream.AddInstructionJump(Instruction.J, continueAddress);
            
            uint breakAddress = CodeStream.NextAddress;
            Block.PopBlock(continueAddress, breakAddress);
            if (Parser.HadError)
            {
                break;
            }
            success = true;                    
            break;
        }
        return success;
    }
    
    bool compileBlockScope()
    {
        bool success = false;
        loop
        {
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            CodeStream.InsertDebugInfo(true);
            success = !Parser.HadError;
            break;
        }
        return success;
    }
    
    bool compileFor()
    {
        bool success = false;
        loop
        {
            Block.PushBlock(true); // new loop block context
            
            Parser.Advance(); // for
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            // initialization statement
            if (Parser.Check(HopperToken.SemiColon))
            {
                // empty initialization statement
                Parser.Consume(HopperToken.SemiColon);
            }
            else
            {
                if (!compileStatement(false, false)) 
                {
                    break;
                }
            }
            
            uint loopAddress = CodeStream.NextAddress;
            string exitCheckType = CompileExpression("bool");
            if ("bool" != exitCheckType)
            {
                Parser.Error("boolean expression expected, (was '" + exitCheckType + "')");
                break;
            }
            Parser.Consume(HopperToken.SemiColon);
            if (Parser.HadError)
            {
                break;
            }
            
            uint jumpExit = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.JZ);
            
            <byte> mainStream = CodeStream.CurrentStream;
            CodeStream.New();
            
            // increment statement (no semicolon)
            if (!Parser.Check(HopperToken.RParen)) // can be empty
            {
                if (!compileStatement(true, false)) 
                {
                    break;
                }
            }
            <byte> incrementStream = CodeStream.CurrentStream;
            CodeStream.New(mainStream);
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
            
            CodeStream.InsertDebugInfo(true);
            
            uint continueAddress = CodeStream.NextAddress;
            CodeStream.AppendCode(incrementStream);
            CodeStream.AddInstructionJump(Instruction.J, loopAddress);
// exit:                      
            uint breakAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(jumpExit, breakAddress);
            Block.PopBlock(continueAddress, breakAddress);
            
            success = true;
            break;
        } // loop
        
        
        return success;
    }
    
    bool compileForEachString(string identifier)
    {
        bool success = false;
        loop
        {
            Block.PushBlock(true); // new loop block context
            Block.AddLocal("string", identifier+ "_c");    // 'foreach' string collection object (expression in [top])
            CodeStream.AddInstructionPUSHI(0); // char: identifier
            CodeStream.AddInstructionPUSHI(0); // uint: identifier_i
            // kv has same type as collection if dictionary
            Block.AddLocal("char", identifier);            // 'foreach' string
            Block.AddLocal("uint", identifier+"_i");       // 'foreach' string
            
            
            bool isRef;
            byte identifierOffset = CodeStream.IntToByte(Block.GetOffset(identifier, ref isRef));
            byte iteratorOffset   = CodeStream.IntToByte(Block.GetOffset(identifier+"_i", ref isRef));
            byte collectionOffset = CodeStream.IntToByte(Block.GetOffset(identifier+"_c", ref isRef));
//next:            
            uint nextAddress = CodeStream.NextAddress;
            CodeStream.AddInstructionPushLocal(collectionOffset); // string collection object
            CodeStream.AddInstructionSysCall("String", "Length_Get", 0);
            CodeStream.AddInstructionPushLocal(iteratorOffset);
            CodeStream.AddInstruction(Instruction.EQ);
            uint jumpExit = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.JNZ);
            
            // load identifier using identifier_i
            CodeStream.AddInstructionPushLocal(collectionOffset); // string collection object
            CodeStream.AddInstructionPushLocal(iteratorOffset);
            CodeStream.AddInstructionSysCall("String", "GetChar", 0);
            
            // identifier <- collection[iterator]
            CodeStream.AddInstructionPopLocal(identifierOffset);
            
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
//continue:
            uint continueAddress = CodeStream.NextAddress;            
            CodeStream.InsertDebugInfo(true); 
            
            // iterator++            
            CodeStream.AddInstructionIncLocal(iteratorOffset, false);
            
            CodeStream.AddInstructionJump(Instruction.J, nextAddress);
// exit:            
            uint breakAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(jumpExit, breakAddress);
            Block.PopBlock(continueAddress, breakAddress);
            
            success = true;   
            break;
        }
        return success;
    }
    
    bool compileForEachList(string identifier, string iteratorType, string collectionType)
    {
        bool success = false;
        loop
        {
            Block.PushBlock(true); // new loop block context
            Block.AddLocal(collectionType, identifier+ "_c");    // 'foreach' list : list collection object (expression in [top])
            CodeStream.AddInstructionPUSHI(0); // iteratorType: identifier
            CodeStream.AddInstructionPUSHI(0); // uint: identifier_i
            
            Block.AddLocal(iteratorType, identifier);            // 'foreach' list
            Block.AddLocal("uint", identifier+"_i");             // 'foreach' list
            
            bool isReference = !Types.IsValueType(iteratorType);
            
            bool isRef;
            byte identifierOffset = CodeStream.IntToByte(Block.GetOffset(identifier, ref isRef));
            byte iteratorOffset   = CodeStream.IntToByte(Block.GetOffset(identifier+"_i", ref isRef));
            byte collectionOffset = CodeStream.IntToByte(Block.GetOffset(identifier+"_c", ref isRef));

// next:
            uint nextAddress = CodeStream.NextAddress;            
            CodeStream.AddInstructionPushLocal(collectionOffset); // list collection object
            CodeStream.AddInstructionSysCall("List", "Count_Get", 0); // foreach
            CodeStream.AddInstructionPushLocal(iteratorOffset);
            CodeStream.AddInstruction(Instruction.EQ);
            uint jumpExit = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.JNZ);
            
            // load identifier using identifier_i
            CodeStream.AddInstructionPushLocal(collectionOffset); // list collection object
            CodeStream.AddInstructionPushLocal(iteratorOffset);
            if (iteratorType == "variant")
            {
                // int type is not known at compile time
                CodeStream.AddInstructionSysCall("List", "GetItemAsVariant", 0); // foreach
            }
            else
            {
                // item type is known at compile time
                CodeStream.AddInstructionSysCall("List", "GetItem", 0); // foreach
            }
            
            // identifier <- collection[iterator]
            if (isReference)
            {
                CodeStream.AddInstruction(Instruction.COPYNEXTPOP);
            }
            CodeStream.AddInstructionPopLocal(identifierOffset);
            
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
// continue:
            uint continueAddress = CodeStream.NextAddress;            
            CodeStream.InsertDebugInfo(true);
            
            // iterator++            
            CodeStream.AddInstructionIncLocal(iteratorOffset, false);
            
            CodeStream.AddInstructionJump(Instruction.J, nextAddress);
// exit:            
            uint breakAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(jumpExit, breakAddress);
            Block.PopBlock(continueAddress, breakAddress);
            
            success = true;   
            break;
        }
        return success;
    }
    
    bool compileForEachArray(string identifier, string iteratorType, string collectionType)
    {
        bool success = false;
        loop
        {
            Block.PushBlock(true); // new loop block context
            Block.AddLocal(collectionType, identifier+ "_c");    // 'foreach' array : array collection object (expression in [top])
            CodeStream.AddInstructionPUSHI(0); // iteratorType: identifier
            CodeStream.AddInstructionPUSHI(0); // uint: identifier_i
            
            Block.AddLocal(iteratorType, identifier);            // 'foreach' array
            Block.AddLocal("uint", identifier+"_i");             // 'foreach' array
            
            bool isReference = !Types.IsValueType(iteratorType);
            if (isReference)
            {
                Die(0x0B); // how did an array end up with reference members?
            }
            
            bool isRef;
            byte identifierOffset = CodeStream.IntToByte(Block.GetOffset(identifier, ref isRef));
            byte iteratorOffset = CodeStream.IntToByte(Block.GetOffset(identifier+"_i", ref isRef));
            byte collectionOffset = CodeStream.IntToByte(Block.GetOffset(identifier+"_c", ref isRef));
            
            uint nextAddress = CodeStream.NextAddress;
// next:            
            CodeStream.AddInstructionPushLocal(collectionOffset); // array collection object
            CodeStream.AddInstructionSysCall0("Array", "Count_Get");
            CodeStream.AddInstructionPushLocal(iteratorOffset);
            CodeStream.AddInstruction(Instruction.EQ);
            uint jumpExit = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.JNZ);
            
            // load identifier using identifier_i
            CodeStream.AddInstructionPushLocal(collectionOffset); // array collection object
            CodeStream.AddInstructionPushLocal(iteratorOffset);
            if (CodeStream.Target6502 && IsWordValueType(iteratorType))
            {
                CodeStream.AddInstructionSysCall0("Array", "GetItemUInt");
            }
            else
            {
                CodeStream.AddInstructionSysCall0("Array", "GetItem");
            }
            
            // identifier <- collection[iterator]
            CodeStream.AddInstructionPopLocal(identifierOffset);
            
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
//continue:
            uint continueAddress = CodeStream.NextAddress;
            CodeStream.InsertDebugInfo(true); 
            
            // iterator++            
            CodeStream.AddInstructionIncLocal(iteratorOffset, false);
            
            CodeStream.AddInstructionJump(Instruction.J, nextAddress);
// exit:            
            uint breakAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(jumpExit, breakAddress);
            Block.PopBlock(continueAddress, breakAddress);
            
            success = true;   
            break;
        }
        return success;
    }
    
    bool compileForEachDictionary(string identifier, string iteratorType, string collectionType)
    {
        bool success = false;
        loop
        {
            Block.PushBlock(true); // new loop block context
            
            Block.AddLocal(collectionType, identifier+ "_c");    // 'foreach' dictionary : dictionary collection object (expression in [top])
            
            string keyType = Types.GetKeyFromCollection(collectionType);
            string valueType = Types.GetKeyFromCollection(collectionType);
            
            byte kt = Types.ToByte(keyType);
            byte vt = Types.ToByte(valueType);
            CodeStream.AddInstructionPUSHI(kt);
            CodeStream.AddInstructionPUSHI(vt);
            CodeStream.AddInstructionSysCall0("Pair", "New");
            CodeStream.AddInstructionPUSHI(0);
            
            Block.AddLocal(iteratorType, identifier); // 'foreach' dictionary : pair is same type as collection
            Block.AddLocal("uint", identifier+"_i");  // 'foreach' dictionary 
            
            bool isRef;
            byte identifierOffset = CodeStream.IntToByte(Block.GetOffset(identifier, ref isRef));
            byte iteratorOffset = CodeStream.IntToByte(Block.GetOffset(identifier+"_i", ref isRef));
            byte collectionOffset = CodeStream.IntToByte(Block.GetOffset(identifier+"_c", ref isRef));
                                    
            uint continueAddress = CodeStream.NextAddress;
// continue:            
            CodeStream.AddInstructionPushLocal(collectionOffset); // dictionary collection object
            CodeStream.AddInstructionPushLocal(iteratorOffset);
            CodeStream.AddInstructionSysCall0("Dictionary", "Next");
            
            CodeStream.AddInstructionPopLocal(iteratorOffset); // iterator (identifier_i)
            CodeStream.AddInstructionPopLocal(identifierOffset); // pair (identifier)
            
            uint jumpExit = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.JZ);
            
            Block.PushBlock(false); // for block locals
            compileBlock();
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
            
            CodeStream.InsertDebugInfo(true); 
            
            CodeStream.AddInstructionJump(Instruction.J, continueAddress);
// exit            
            uint breakAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(jumpExit, breakAddress);    
            Block.PopBlock(continueAddress, breakAddress);
            
            success = true;   
            break;
        }
        return success;
    }
        
    bool compileForEach()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // foreach
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            if (!Parser.CheckKeyword("var"))
            {
                Parser.Error("'var' expected");
            }
            Parser.Advance(); // var
            
            if (!Parser.Check(HopperToken.Identifier))
            {
                Parser.Error("identifier expected");
                break;
            }
            <string,string> currentToken = CurrentToken;
            string identifier = currentToken["lexeme"];
            Parser.Advance(); // identifier
                   
            if (!Parser.CheckKeyword("in"))
            {
                Parser.Error("'in' expected");
                break;
            }
            Parser.Advance(); // in
            
            string collectionType = CompileExpression("");
            if (Parser.HadError)
            {
                break;
            }
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            string iteratorType = Types.GetIteratorFromCollection(collectionType);
            if (Parser.HadError)
            {
                break;
            }
            if (collectionType == "string")
            {
                if (iteratorType != "char")
                {
                    Die(0x0B); // why not?
                }
                success = compileForEachString(identifier);
            }
            else if (Types.IsList(collectionType))
            {
                success = compileForEachList(identifier, iteratorType, collectionType);
            }
            else if (Types.IsRecord(collectionType)) // RECORD : foreach iteration
            {
                success = compileForEachList(identifier, iteratorType, collectionType);
            }
            else if (Types.IsArray(collectionType))
            {
                success = compileForEachArray(identifier, iteratorType, collectionType);
            }
            else if (Types.IsDictionaryOrPair(collectionType))
            {
                success = compileForEachDictionary(identifier, iteratorType, collectionType);
            }
            else
            {
                Die(0x0B); // how did we get past the check in GetIteratorFromCollection(..)?
            }
            break;
        } // loop
        
        
        return success;
    }
    bool compileFastSwitch(string switchType, byte upperBound)
    {
        bool success = false;
        loop
        {   
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            Parser.Consume(HopperToken.LBrace);
            if (Parser.HadError)
            {
                break;
            }
            
            uint defaultAddress;
            <byte,uint> caseOffsets;
            <uint> jumpEnds;
            
            uint switchJump = CodeStream.NextAddress;
            CodeStream.AddInstructionJump(Instruction.J);
            
            // needs to not be zero for the first case to not clash with how 'default' works so +3 is fine
            uint switchBaseline = switchJump;
            
            // compile all the cases into a new stream collecting cases and offsets
            bool defaultSeen = false;
            loop
            {
                if (Parser.Check(HopperToken.RBrace))
                {
                    success = true;
                    Parser.Advance(); // }
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent("unexpected EOF in 'switch'");
                    break;
                }
                
                bool isDefault = false;
                if (!Parser.CheckKeyword("case"))
                {
                    if (Parser.CheckKeyword("default"))
                    {
                        isDefault = true;       
                        if (defaultSeen)
                        {
                            Parser.ErrorAtCurrent("'default' can only occur once");
                            break;    
                        }
                        defaultSeen = true;
                    }
                    else
                    {
                        Parser.ErrorAtCurrent("'case' expected");
                        break;
                    }
                }
                if (defaultSeen && !isDefault)
                {
                    Parser.ErrorAtCurrent("'default' must be last case");
                    break;    
                }      
                
                loop
                {
                    Parser.Advance(); // "case" or "default"
// next:         
                    if (!isDefault)
                    {   
                        <byte> range;
                        if (switchType == "byte")
                        {
                            range = ParseRange("byte");
                            if (Parser.HadError)    
                            {
                                break;    
                            }
                        }
                        else if (switchType == "char")
                        {
                            range = ParseRange("char");
                            if (Parser.HadError)
                            {
                                break;
                            }
                        }
                        else
                        {
                            string actualType;
                            string caseConstant = ParseConstantExpression(switchType, ref actualType);
                            if (Parser.HadError)
                            {
                                break;
                            }
                            byte caseConstantByte;
                            if (switchType == "char")
                            {
                                char c = caseConstant[0];
                                caseConstantByte = byte(c);
                            }
                            else if (switchType == "bool")
                            {
                                caseConstantByte = 0;
                                if (caseConstant == "true")
                                {
                                    caseConstantByte = 1;
                                }
                            }
                            else
                            {
                                uint cc;
                                if (UInt.TryParse(caseConstant, ref cc))
                                {
                                    if (cc > upperBound)
                                    {
                                        Parser.Error("'case' constant '" + caseConstant + "' out of range");
                                    }
                                    else
                                    {
                                        caseConstantByte = byte(cc);
                                    }
                                }
                                else
                                {
                                    Parser.Error("unexpected 'case' constant '" + caseConstant + "'");
                                }
                            }
                            if (Parser.HadError)
                            {
                                break;
                            }
                            range.Append(caseConstantByte);
                        }
                        foreach (var caseByte in range)
                        {
                            if (caseOffsets.Contains(caseByte) || (caseByte > upperBound))
                            {
                                string caseName = caseByte.ToString();
                                if (switchType == "char") { caseName = "" + char(caseByte); }
                                if (switchType == "bool") { caseName = ((caseByte == 0) ? "false" : "true"); }
                                
                                Parser.Error("duplicate 'case' constant '" + caseName + "'");
                                break;
                            }
                            else
                            {
                                caseOffsets[caseByte] = CodeStream.NextAddress - switchBaseline;
                            }
                        }
                        
                    } // !isDefault
                    else
                    {
                        defaultAddress = CodeStream.NextAddress;
                    }
                    if (Parser.HadError)
                    {
                        break;
                    }
                    Parser.Consume(HopperToken.Colon);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    if (!isDefault)
                    {
                        if (Parser.CheckKeyword("case"))
                        {
                            continue; // multiple cases
                        }
                    }
                    break;
                } // loop: multiple "case"
                
                if (Parser.HadError)
                {
                    break;
                }
// match:       
                Block.PushBlock(false); // not loop context
                compileBlock();
                Block.PopBlock();
                
                uint jumpEnd = CodeStream.NextAddress;
                CodeStream.AddInstructionJump(Instruction.J);
                jumpEnds.Append(jumpEnd);
            } // loop
            
            // compile the jump table into main stream
            byte minByte = 255;
            byte maxByte = 0;
            uint maxOffset = 0;
            foreach (var kv in caseOffsets)
            {
                byte caseKey = kv.key;
                if (caseKey < minByte)
                {
                    minByte = caseKey;
                }
                if (caseKey > maxByte)
                {
                    maxByte = caseKey;
                }
                uint offset  = kv.value;
                if (offset > maxOffset)
                {
                    maxOffset = offset;
                }
            }
            
            uint switchAddress = CodeStream.NextAddress;
            CodeStream.PatchJump(switchJump, switchAddress);
            
            // needs to not be zero for the first case to not clash with how 'default' works so +3 is fine
            uint casesOffset = switchAddress - switchBaseline; 
            
            
            // if there are no cases, no switch (still works if there was a 'default', just fall through to it)
            if (caseOffsets.Count  == 0)
            {
                CodeStream.AddInstruction(Instruction.DECSP, 1); // do nothing with the switch
            }
            else
            {
                // expression has already been parsed, result is on the stack
                uint operand = byte(minByte) + (byte(maxByte) << 8);
                
                bool useJIXB = (maxOffset <= 255) && !NoPackedInstructions && !TargetMinimal;
                if (useJIXB)
                {
                    CodeStream.AddInstruction(Instruction.JIXB, operand);
                }
                else
                {
                    CodeStream.AddInstruction(Instruction.JIX, operand);
                }
                
                <byte> tableBytes;
                // not really part of the table but it works
                tableBytes.Append(byte(casesOffset & 0xFF));
                tableBytes.Append(byte(casesOffset >> 8));
                
                
                // 'default' slot is first: if switch is outside the range [minByte..maxByte]
                
                // jump table
                for (byte i = minByte; i <= maxByte; i++)
                {
                    uint offset;
                    if (caseOffsets.Contains(i))
                    {
                        offset = caseOffsets[i];
                    }
                    if (useJIXB)
                    {
                        // emit offset byte
                        tableBytes.Append(byte(offset));
                    }
                    else
                    {
                        // emit offset as uint
                        tableBytes.Append(byte(offset & 0xFF));
                        tableBytes.Append(byte(offset >> 8));
                    }
                }
                CodeStream.AppendCode(tableBytes);
            }
            if (defaultSeen)
            {
                CodeStream.AddInstructionJump(Instruction.J, defaultAddress);
            }
// end:             
            uint endAddress = CodeStream.NextAddress;
            foreach (var jumpEnd in jumpEnds)
            {
                uint ui = jumpEnd;
                CodeStream.PatchJump(ui, endAddress);
            }
            
            break;
        } // loop
        return success;
    }
    bool compileSwitch()
    {
        bool success = false;
        loop
        {
            <uint> jumpEnds;
            Parser.Advance(); // switch
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            string switchType = CompileExpression("");
            byte upperBound;
            if (!NoJIXInstructions && Types.IsByteRange(switchType, ref upperBound))
            {
                success = compileFastSwitch(switchType, upperBound);
                break;
            }
            
            uint unique = CodeStream.NextAddress;
            string switchName ="switch_" + unique.ToHexString(4);
            Block.PushBlock(false); // block for switch variable
            Block.AddLocal(switchType, switchName);   // switch variable
            
            bool isRef;
            byte switchOffset = CodeStream.IntToByte(Block.GetOffset(switchName, ref isRef));
            
            if (Parser.HadError)
            {
                break;
            }
            if (!Types.IsValueType(switchType) && (switchType != "string"))
            {
                Parser.ErrorAtCurrent("'switch' expression type must be value type or string");
                break;
            }
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            
            Parser.Consume(HopperToken.LBrace);
            if (Parser.HadError)
            {
                break;
            }
            bool defaultSeen = false;
            loop
            {
                if (Parser.Check(HopperToken.RBrace))
                {
                    success = true;
                    Parser.Advance(); // }
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent("unexpected EOF in 'switch'");
                    break;
                }
                
                bool isDefault = false;
                if (!Parser.CheckKeyword("case"))
                {
                    if (Parser.CheckKeyword("default"))
                    {
                        isDefault = true;       
                        if (defaultSeen)
                        {
                            Parser.ErrorAtCurrent("'default' can only occur once");
                            break;    
                        }
                        defaultSeen = true;
                    }
                    else
                    {
                        Parser.ErrorAtCurrent("'case' expected");
                        break;
                    }
                }
                if (defaultSeen && !isDefault)
                {
                    Parser.ErrorAtCurrent("'default' must be last case");
                    break;    
                }      
                <uint> jumpNexts;
                <uint> jumpMatches;
                
                loop
                {
                    CodeStream.InsertDebugInfo(false);
                    
                    Parser.Advance(); // "case" or "default"
// next:         
                    if (!isDefault)
                    {   
                        string actualType;
                        string caseConstant = ParseConstantExpression(switchType, ref actualType);
                        if (Parser.HadError)
                        {
                            break;
                        }
                        if (switchType == "string")
                        {
                            CodeStream.AddString(switchType, caseConstant);
                        }
                        else if (switchType == "char")
                        {
                                char c = caseConstant[0];
                                CodeStream.AddInstructionPUSHI(byte(c));   
                        }
                        else
                        {
                            uint cc;
                            if (UInt.TryParse(caseConstant, ref cc))
                            {
                                CodeStream.AddInstructionPUSHI(cc);
                            }
                            else
                            {
                                Parser.Error("unexpected 'case' constant '" + caseConstant + "'");                
                            }
                        }
                    } // !isDefault
                    
                    Parser.Consume(HopperToken.Colon);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    
                    if (!isDefault)
                    {
                        CodeStream.AddInstructionPushLocal(switchOffset); // switch variable
                        // compare with case constant
                        if (switchType == "string")
                        {
                            CodeStream.AddInstructionSysCall("String", "Compare", 0);
                            CodeStream.AddInstructionPUSHI(0);
                        }
                        CodeStream.AddInstruction(Instruction.EQ); // => 1
                        uint jumpNext = CodeStream.NextAddress;
                        jumpNexts.Append(jumpNext);
                        CodeStream.AddInstructionJump(Instruction.JZ);
                        
                        if (Parser.CheckKeyword("case"))
                        {
                            uint jumpMatch = CodeStream.NextAddress;
                            CodeStream.AddInstructionJump(Instruction.J);
                            jumpMatches.Append(jumpMatch);
                            
                            uint nextAddress = CodeStream.NextAddress;
                            CodeStream.PatchJump(jumpNexts[0], nextAddress);  
                            jumpNexts.Clear();
                            
                            continue; // multiple cases
                        }
                    }
                    break;
                } // loop: multiple "case"
                
                if (Parser.HadError)
                {
                    break;
                }
// match:       
                foreach (var jumpMatch in jumpMatches)
                {        
                    uint nextAddress = CodeStream.NextAddress;
                    CodeStream.PatchJump(jumpMatch, nextAddress);   
                }
                     
                Block.PushBlock(false); // not loop context
                compileBlock();
                Block.PopBlock();
                
                CodeStream.InsertDebugInfo(true); 
                
                uint jumpEnd = CodeStream.NextAddress;
                CodeStream.AddInstructionJump(Instruction.J);
                jumpEnds.Append(jumpEnd);
// next:        
                // next case will be after the block if there was one
                foreach (var jumpNext in jumpNexts)
                {        
                    uint nextAddress = CodeStream.NextAddress;
                    CodeStream.PatchJump(jumpNext, nextAddress);   
                }
            } // loop
// end:         
            uint endAddress = CodeStream.NextAddress;
            foreach (var jumpEnd in jumpEnds)
            {
                uint ui = jumpEnd;
                CodeStream.PatchJump(ui, endAddress);
            }
            Block.PopBlock();
            break;
        } // loop
        return success;
    }
    
    bool compileIncrementDecrement(string variableName, HopperToken tokenType)
    {
        bool success = false;
        loop
        {
            uint iOverload;
            bool isSetter;
            
            Parser.Advance(); // ++ or --
            string qualifiedName;
            string variableType = Types.GetTypeString(variableName, false, ref qualifiedName);
            if (Parser.HadError)
            {
                break;
            }
            
            bool isMember;
            byte iMember;
            string qualifiedThis;
            if ((variableType.Length == 0) && variableName.Contains('.'))
            {
                // this?
                <string> parts = variableName.Split('.');
                if (parts.Count == 2)
                {
                    string thisVariable = parts[0];
                    string memberName   = parts[1];
                    string thisTypeString = Types.GetTypeString(thisVariable, false, ref qualifiedThis);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    if (Record.FindMember(thisTypeString, thisVariable, memberName, ref iMember, ref variableType))
                    {
                        isMember = true;
                    }
                    if (Parser.HadError)
                    {
                        break;
                    }
                }
            }
            
            if (variableType.Length == 0)
            {
                // perhaps it is a setter
                string setterMethod = variableName + "_Set";
                setterMethod = Types.QualifyMethodName(setterMethod);
                uint fIndex;
                if (!Symbols.GetFunctionIndex(setterMethod, ref fIndex))
                {
                    Parser.ErrorAtCurrent("undefined identifier '" + variableName + "'");   
                    break;
                }
                <uint> overloads = Symbols.GetFunctionOverloads(fIndex);
                if (overloads.Count != 1)
                {
                    Parser.ErrorAtCurrent("setter method should only have one overload");   
                    break;
                }
                iOverload = overloads[0];
                < < string > > arguments = Symbols.GetOverloadArguments(iOverload); 
                
                if (arguments.Count != 1)
                {
                    Parser.ErrorAtCurrent("setter method should only have one argument");   
                    break;
                }
                <string> argument = arguments[0];
                variableType = argument[1];   
                isSetter = true;
                Symbols.OverloadToCompile(iOverload);
            }
            
            if (!Types.IsNumericType(variableType))
            {
                Parser.ErrorAtCurrent("++ and -- operations only legal for numeric types");
                break;
            }
            if (!isSetter && !isMember && ((variableType == "uint") || (variableType == "byte") || (variableType == "int")))
            {
                if (!Symbols.GlobalMemberExists(qualifiedName))
                {
                    bool isRef;
                    int offset = Block.GetOffset(variableName, ref isRef);
                    if ((offset > -129) && (offset < 128) && !isRef)
                    {
                        byte operand =  CodeStream.IntToByte(offset);
                        if (tokenType == HopperToken.Increment)
                        {
                            CodeStream.AddInstructionIncLocal(operand, (variableType == "int"));
                        }
                        else
                        {
                            CodeStream.AddInstructionDecLocal(operand, (variableType == "int"));
                        }
                        success = true;           
                        break;
                    }
                }
            }
            if (isSetter)
            {
                if (!callGetter(variableName + "_Get", variableType))
                {
                    break;
                }
            }
            else if (isMember)
            {
                CodeStream.AddInstructionPushVariable(qualifiedThis);
                CodeStream.AddInstructionPUSHI(iMember);
                CodeStream.AddInstructionPushVariable(qualifiedThis);
                CodeStream.AddInstructionPUSHI(iMember);
                CodeStream.AddInstructionSysCall0("List", "GetItem");
            }
            else
            {
                CodeStream.AddInstructionPushVariable(qualifiedName);
            }
            CodeStream.AddInstructionPUSHI(byte(1));
            if (tokenType == HopperToken.Increment)
            {
                switch (variableType)
                {
                    case "long":
                    {
                        CodeStream.AddInstructionSysCall("UInt", "ToLong", 0);
                        CodeStream.AddInstructionSysCall("Long", "Add", 0);
                    }
                    case "float":
                    {
                        CodeStream.AddInstructionSysCall("UInt", "ToFloat", 0);
                        CodeStream.AddInstructionSysCall("Float", "Add", 0);
                    }
                    default:
                    {
                        if (Types.IsSignedIntType(variableType))
                        {
                            CodeStream.AddInstruction(Instruction.ADDI);
                        }
                        else
                        {
                            CodeStream.AddInstruction(Instruction.ADD);
                        }
                    }
                }
            }
            else if (tokenType == HopperToken.Decrement)
            {
                switch (variableType)
                {
                    case "long":
                    {
                        CodeStream.AddInstructionSysCall0("UInt", "ToLong");
                        CodeStream.AddInstructionSysCall0("Long", "Sub");
                    }
                    case "float":
                    {
                        CodeStream.AddInstructionSysCall0("UInt", "ToFloat");
                        CodeStream.AddInstructionSysCall0("Float", "Sub");
                    }
                    default:
                    {
                        if (Types.IsSignedIntType(variableType))
                        {
                            CodeStream.AddInstruction(Instruction.SUBI);
                        }
                        else
                        {
                            CodeStream.AddInstruction(Instruction.SUB);
                        }
                    }
                }
            }
            if (isSetter)
            {
                // call setter method with expression result on stack as argument
                string returnType = CompileMethodCall(variableName + "_Set", "", "");
                if (Parser.HadError)
                {
                    break;
                }
                if (returnType != "void")
                {
                    Die(0x0B);
                }
            }
            else if (isMember)
            {
                CodeStream.AddInstructionSysCall0("List", "SetItem");
            }
            else
            {
                CodeStream.AddInstructionPopVariable(variableType, qualifiedName);
            }
            success = true;           
            break;
        }
        return success;
    } 
    
    bool callGetter(string getterMethod, string variableType)
    {
        bool success;
        loop
        {
            // call getter
            getterMethod = Types.QualifyMethodName(getterMethod);
            uint fgIndex;
            if (!Symbols.GetFunctionIndex(getterMethod, ref fgIndex))
            {
                Parser.ErrorAtCurrent("property needs getter for operation");   
                break;
            }
            <uint> goverloads = Symbols.GetFunctionOverloads(fgIndex);
            if (goverloads.Count != 1)
            {
                Parser.ErrorAtCurrent("getter method should only have one overload");   
                break;
            }
            uint igOverload = goverloads[0];
            < < string > > garguments = Symbols.GetOverloadArguments(igOverload); 
            
            if (garguments.Count == 1)
            {
                Parser.ErrorAtCurrent("getter method should only have zero arguments");   
                break;
            }
            string greturnType = Symbols.GetOverloadReturnType(igOverload);
            if (greturnType != variableType)
            {
                Parser.ErrorAtCurrent("getter method has invalid return type");   
                break;
            }
            Symbols.OverloadToCompile(igOverload);
            Symbols.AddFunctionCall(igOverload);
            
            // call the getter
            if (Symbols.IsSysCall(igOverload))
            {
                byte iSysCall = Symbols.GetSysCallIndex(igOverload);
                byte iSysOverload = Symbols.GetSysCallOverload(igOverload);
                if (TryUserSysCall(getterMethod, iSysOverload))
                {
                    // done
                }
                else if (!NoPackedInstructions && (iSysOverload == 0))
                {
                    CodeStream.AddInstruction(Instruction.SYSCALL0, iSysCall);
                }
                else if (!NoPackedInstructions && (iSysOverload == 1))
                {
                    CodeStream.AddInstruction(Instruction.SYSCALL1, iSysCall);
                }
                else if (!NoPackedInstructions && (iSysOverload == 2))
                {
                    CodeStream.AddInstruction(Instruction.SYSCALL2, iSysCall);
                }
                else
                {
                    CodeStream.AddInstructionPUSHI(iSysOverload);
                    CodeStream.AddInstruction(Instruction.SYSCALL, iSysCall);
                }
            }
            else if (Symbols.IsLibCall(igOverload))
            {
                byte iLibCall = Symbols.GetLibCallIndex(igOverload);
                byte iLibOverload = Symbols.GetLibCallOverload(igOverload);
                if (!NoPackedInstructions && (iLibOverload == 0))
                {
                    CodeStream.AddInstruction(Instruction.LIBCALL0, iLibCall);
                }
                else if (!NoPackedInstructions && (iLibOverload == 1))
                {
                    CodeStream.AddInstruction(Instruction.LIBCALL1, iLibCall);
                }
                else
                {
                    CodeStream.AddInstructionPUSHI(iLibOverload);
                    CodeStream.AddInstruction(Instruction.LIBCALL, iLibCall);
                }
            }
            else
            {
                if (CodeStream.IsShortCalls && (igOverload < 256))
                {
                    CodeStream.AddInstruction(Instruction.CALLB, byte(igOverload));
                }
                else
                {
                    CodeStream.AddInstruction(Instruction.CALL, igOverload);
                }
            }
            if (IsCDecl)
            {
                CDeclPostCALL(igOverload); // getter
            }
            success = true;
            break;
        } // loop
        return success;
    }
    bool compileAssignment(string variableName, bool ignoreZero)
    {
        bool success = false;
        loop
        {
            <string,string> leftToken   = PreviousToken;
            HopperToken leftTokenType   = Token.GetType(leftToken); 
            HopperToken assignOperation = HopperToken.Assign;
            if (Parser.Check(HopperToken.Assign))
            {
                Parser.Advance(); // =
            }
            else if (Parser.Check(HopperToken.AssignAdd))
            {
                Parser.Advance(); // +=
                assignOperation = HopperToken.AssignAdd;
            }
            else if (Parser.Check(HopperToken.AssignSubtract))
            {
                Parser.Advance(); // -=
                assignOperation = HopperToken.AssignSubtract;
            }
            else if (Parser.Check(HopperToken.AssignMultiply))
            {
                Parser.Advance(); // *=
                assignOperation = HopperToken.AssignMultiply;
            }
            else if (Parser.Check(HopperToken.AssignDivide))
            {
                Parser.Advance(); // /=
                assignOperation = HopperToken.AssignDivide;
            }
            else if (Parser.Check(HopperToken.AssignModulus))
            {
                Parser.Advance(); // %=
                assignOperation = HopperToken.AssignModulus;
            }
            else if (Parser.Check(HopperToken.AssignBitAnd))
            {
                Parser.Advance(); // &=
                assignOperation = HopperToken.AssignBitAnd;
            }
            else if (Parser.Check(HopperToken.AssignBitOr))
            {
                Parser.Advance(); // |=
                assignOperation = HopperToken.AssignBitOr;
            }
            else
            {
                Parser.ErrorAtCurrent("'=' expected"); 
            }
            if (Parser.HadError)
            {
                break;
            }
            
            string qualifiedName;
            string variableType;
            if (leftTokenType == HopperToken.Discarder)
            {
                if (assignOperation != HopperToken.Assign)
                {
                    Parser.ErrorAtCurrent("'=' expected for '_' discard"); 
                }
            }
            else
            {
                // uses Blocks, respects namespaces, Parser.Error on failure  
                variableType = Types.GetTypeString(variableName, false, ref qualifiedName);
            }
            if (Parser.HadError)
            {
                break;
            }
            
            bool isSetter = false;
            bool isMember = false;
            string recordThis;
            
            bool isStringAppend = false;
            uint iOverload;
            
            if (ignoreZero) // only from compileLocalDeclaration(..) where +=, -=, etc. are not legal
            {
                ignoreZero = Types.IsValueType(variableType);
                if (ignoreZero)
                {
                    ignoreZero = Parser.PeekTokenType() == HopperToken.SemiColon;
                }
                if (ignoreZero)
                {
                    <string,string> currentToken = Parser.CurrentToken;
                    HopperToken tokenType = Token.GetType(currentToken);   
                    if ((variableType == "bool") 
                     && (tokenType == HopperToken.Bool)
                     && (currentToken["lexeme"] == "false"))
                    {
                        // "bool value;" is the same as "bool value = false;"
                        Parser.Advance(); // 'false'
                        success = true;        
                        break;
                    }
                    else if (((variableType == "byte") || (variableType == "int") || (variableType == "uint")) 
                          && (tokenType == HopperToken.Integer)
                          && (currentToken["lexeme"] == "0"))
                    {
                        // "uint value;" is the same as "uint value = 0;"
                        Parser.Advance(); // '0'
                        success = true;        
                        break;
                    }
                }
            }
            if (variableName.Contains('.') && (variableType.Length == 0) && (leftTokenType != HopperToken.Discarder))
            {
                <string> parts = variableName.Split('.');
                if (parts.Count == 2)
                {
                    recordThis        = parts[0];
                    string memberName = parts[1];
                    
                    string qualifiedThis;
                    string thisTypeString = Types.GetTypeString(recordThis, false, ref qualifiedThis);
                    byte iMember;
                    if (Record.FindMember(thisTypeString, qualifiedThis, memberName, ref iMember, ref variableType))
                    {
                        CodeStream.AddInstructionPushVariable(qualifiedThis);
                        CodeStream.AddInstructionPUSHI(iMember);
                        if (assignOperation != HopperToken.Assign)
                        {
                            CodeStream.AddInstructionPushVariable(qualifiedThis);
                            CodeStream.AddInstructionPUSHI(iMember);
                        }
                        isMember = true;
                    }
                    if (Parser.HadError)
                    {
                        break;
                    }
                }
            }
            
            if ((variableType.Length == 0) && (leftTokenType != HopperToken.Discarder))
            {
                // perhaps it is a setter
                string setterMethod = variableName + "_Set";
                setterMethod = Types.QualifyMethodName(setterMethod);
                uint fIndex;
                if (!Symbols.GetFunctionIndex(setterMethod, ref fIndex))
                {
                    Parser.ErrorAt(leftToken, "undefined method identifier");   
                    break;
                }
                
                <uint> overloads = Symbols.GetFunctionOverloads(fIndex);
                if (overloads.Count != 1)
                {
                    Parser.ErrorAt(leftToken, "setter method should only have one overload");   
                    break;
                }
                iOverload = overloads[0];
                < < string > > arguments = Symbols.GetOverloadArguments(iOverload); 
                
                if (arguments.Count != 1)
                {
                    Parser.ErrorAt(leftToken, "setter method should only have one argument");   
                    break;
                }
                <string> argument = arguments[0];
                variableType = argument[1];   
                isSetter = true;
                Symbols.OverloadToCompile(iOverload);
            }
            
            if (assignOperation != HopperToken.Assign)
            {
                if ((assignOperation == HopperToken.AssignBitAnd) || (assignOperation == HopperToken.AssignBitOr))
                {
                    if (!Types.IsBitwiseType(variableType))
                    {
                        Parser.ErrorAtCurrent("bitwise operations only legal for 'uint', 'int', 'flags' and 'byte', (not '" + variableType + "')");
                        break;
                    }
                }
                else if ((assignOperation == HopperToken.AssignAdd) && (variableType == "string"))
                {
                    isStringAppend = true;   
                }
                else if (!Types.IsNumericType(variableType))
                {
                    Parser.ErrorAtCurrent("operation only legal for numeric types");
                    break;
                }
                else if ((assignOperation == HopperToken.AssignModulus) && (variableType == "float"))
                {
                    Parser.ErrorAtCurrent("operation only legal for integral numeric types");
                    break;
                }
                
                if (isSetter)
                {
                    if (!callGetter(variableName + "_Get", variableType))
                    {
                        break;
                    }
                }
                else if (isMember)
                {
                    CodeStream.AddInstructionSysCall0("List", "GetItem");
                }
                else
                {
                    CodeStream.AddInstructionPushVariable(qualifiedName);
                }
            }
            
            string expressionType = CompileExpression(variableType);
            if (Parser.HadError)
            {
                break;
            }
            if ((leftTokenType == HopperToken.Discarder) && (expressionType == "void"))
            {
                Parser.ErrorAt(leftToken, "type mismatch in discard assignment, expect expression, was statement'");       
                break;
            }
            if (isStringAppend)
            {
                if ((expressionType != "string") && (expressionType != "char"))
                {
                    Parser.ErrorAtCurrent("operation only legal for char and string types");
                    break;
                }
            }
            else if ((expressionType != variableType) && (leftTokenType != HopperToken.Discarder))
            {
                if (Types.CanInferArrayCast(expressionType, variableType))
                {
                    // ok
                    //PrintLn("Assignment: " + expressionType + "->" + variableType + " " + variableName);
                }
                else if (!Types.AutomaticUpCastTop(expressionType, variableType))
                {
                    bool isVerified = false;
                    if ((expressionType == "variant") || (expressionType == "K") || (expressionType == "V"))
                    {
                        if (Types.IsSimpleType(variableType))
                        {
                            Types.VerifyTopType(variableType, "");
                            isVerified = true;
                        }
                        else if (Types.IsList(variableType))
                        {
                            Types.VerifyTopType("list", "");
                            string variableValueType = Types.GetValueFromCollection(variableType);
                            if (Types.IsSimpleType(variableValueType))
                            {    
                                Types.VerifyTopValueType(variableValueType, "list");
                                isVerified = true;
                            }
                        }
                        else if (Types.IsDictionaryOrPair(variableType))
                        {
                            Types.VerifyTopType("dictionary", "");
                            string variableKeyType = Types.GetKeyFromCollection(variableType);
                            string variableValueType = Types.GetValueFromCollection(variableType);
                            if (Types.IsSimpleType(variableKeyType))
                            {
                                Types.VerifyTopType(variableKeyType, "Key");
                                if (Types.IsSimpleType(variableValueType))
                                {    
                                    Types.VerifyTopValueType(variableValueType, "dictionary");
                                    isVerified = true;
                                }
                            }
                        }
                    }
                    if (!isVerified)
                    {
                        if (expressionType == "variant")
                        {
                            // TODO : runtime type check

//PrintLn();
//Print("compileAssignment TODO A: runtime type check: " + variableType + " " + variableName + " <- " + expressionType);

                        }
                        else if (expressionType == "V")
                        {
                            // TODO : resolve "V" to type
//PrintLn();
//Print("compileAssignment TODO D: resolve 'V': " + variableType + " " + variableName + " <- " + expressionType);
                        }
                        else if (expressionType == "V[]")
                        {
                            if (!variableType.EndsWith("[]"))
                            {
                                Parser.ErrorAt(leftToken, "type mismatch in assignment, dynamic array expected");       
                                break;
                            }
                            string valueType = variableType.Replace("[]", "");
                            if (!Types.IsValueType(valueType))
                            {
                                Parser.ErrorAt(leftToken, "arrays can only contain value types");       
                                break;
                            }
                        }
                        else if (expressionType == "K")
                        {
                            // TODO : resolve "K" to type
//PrintLn();
//Print("compileAssignment TODO E: resolve 'K': " + variableType + " " + variableName+ " <- " + expressionType);
                        }
                        
                        else if (variableType == "variant")
                        {
                            if (Types.IsValueType(expressionType))
                            {
                                // box value types before assigning them to a variant                                            
                                byte vt = Types.ToByte(expressionType);
                                CodeStream.AddInstructionPUSHI(vt);
                                CodeStream.AddInstructionSysCall0("Variant", "Box");
                            }
                            else
                            {
                                // a variant can have any reference type assigned to it
                            }
                        }
                        else
                        {
                            Parser.ErrorAt(leftToken, "type mismatch in assignment, expect '" + variableType + "', was '" + expressionType + "'");       
                            break;
                        }
                    }
                }
            }
            
            switch (assignOperation)
            {
                case HopperToken.AssignAdd:
                {
                    if (variableType == "string")
                    {
                        if (expressionType == "string")
                        {
                            CodeStream.AddInstructionSysCall("String", "Append", 0);
                        }
                        else
                        {
                            // string Append(string,char)
                            CodeStream.AddInstructionSysCall("String", "Append", 1);
                        }
                    }
                    else if (variableType == "float")
                    {
                        CodeStream.AddInstructionSysCall("Float", "Add", 0);
                    }
                    else if (variableType == "long")
                    {
                        CodeStream.AddInstructionSysCall("Long", "Add", 0);
                    }
                    else if (Types.IsSignedIntType(variableType))
                    {
                        CodeStream.AddInstruction(Instruction.ADDI);
                    }
                    else
                    {
                        CodeStream.AddInstruction(Instruction.ADD);
                    }
                }
                case HopperToken.AssignSubtract:
                {
                    if (variableType == "float")
                    {
                        CodeStream.AddInstructionSysCall0("Float", "Sub");
                    }
                    else if (variableType == "long")
                    {
                        CodeStream.AddInstructionSysCall0("Long", "Sub");
                    }
                    else if (Types.IsSignedIntType(variableType))
                    {
                        CodeStream.AddInstruction(Instruction.SUBI);
                    }
                    else
                    {
                        CodeStream.AddInstruction(Instruction.SUB);
                    }
                }
                case HopperToken.AssignMultiply:
                {
                    if (variableType == "float")
                    {
                        CodeStream.AddInstructionSysCall0("Float", "Mul");
                    }
                    else if (variableType == "long")
                    {
                        CodeStream.AddInstructionSysCall0("Long", "Mul");
                    }
                    else if (Types.IsSignedIntType(variableType))
                    {
                        CodeStream.AddInstruction(Instruction.MULI);
                    }
                    else
                    {
                        CodeStream.AddInstruction(Instruction.MUL);
                    }
                }
                case HopperToken.AssignDivide:
                {
                    if (variableType == "float")
                    {
                        CodeStream.AddInstructionSysCall0("Float", "Div");
                    }
                    else if (variableType == "long")
                    {
                        CodeStream.AddInstructionSysCall0("Long", "Div");
                    }
                    else if (Types.IsSignedIntType(variableType))
                    {
                        CodeStream.AddInstruction(Instruction.DIVI);
                    }
                    else
                    {
                        CodeStream.AddInstruction(Instruction.DIV);
                    }
                }
                case HopperToken.AssignModulus:
                {
                    if (variableType == "long")
                    {
                        CodeStream.AddInstructionSysCall0("Long", "Mod");
                    }
                    else if (Types.IsSignedIntType(variableType))
                    {
                        CodeStream.AddInstruction(Instruction.MODI);
                    }
                    else
                    {
                        CodeStream.AddInstruction(Instruction.MOD);
                    }
                }
                case HopperToken.AssignBitAnd:
                {
                    CodeStream.AddInstruction(Instruction.BITAND);
                }
                case HopperToken.AssignBitOr:
                {
                    CodeStream.AddInstruction(Instruction.BITOR);
                }
            } // switch
            if (leftTokenType == HopperToken.Discarder)
            {
                CodeStream.AddInstruction(Instruction.DECSP, 1); // discard the stack slot
            }
            else if (isMember)
            {
                CodeStream.AddInstructionSysCall0("List", "SetItem"); // compileAssignment: record.member = ..
            }
            else if (!isSetter)
            {
                CodeStream.AddInstructionPopVariable(variableType, qualifiedName);
            }
            else
            {
                // call setter method with expression result on stack as argument
                string returnType = CompileMethodCall(variableName + "_Set", "", "");
                if (Parser.HadError)
                {
                    break;
                }
                if (returnType != "void")
                {
                    Die(0x0B);
                }
            }
            success = true;
            break;
        }    
        return success;
    }
    
    bool compileLocalDeclaration()
    {
        bool success = false;
        loop
        {
            string variableType = Types.ParseType();
            if (Parser.HadError)
            {
                break;
            }
            if (!Parser.Check(HopperToken.Identifier))
            {
                if (!Parser.Check(HopperToken.DottedIdentifier))
                {
                    Parser.ErrorAtCurrent("identifier expected");
                    break;
                }
            }
            <string,string> idToken   = Parser.CurrentToken;
            string identifier = idToken["lexeme"];
            
            char firstCharacter = identifier[0];
            if (firstCharacter.IsUpper())
            {
                Parser.ErrorAtCurrent("public identifier for local declaration is invalid");
                break;
            }
            Parser.Advance(); // identifier
            
            if (    !Parser.Check(HopperToken.Assign)
                 && !Parser.Check(HopperToken.SemiColon)
               )
            {
                Parser.ErrorAtCurrent("';' or '=' expected");
                break;
            }
            if (false && IsZ80 && !DefiningLocals)
            {
                Parser.ErrorAtCurrent("Z80 compiler does not support block local declarations");
                break;
                /*    
                if (Types.IsArray(variableType))
                {
                    Parser.ErrorAtCurrent("ambiguous stack slot for array type, declare earlier in method");
                    break;
                }
                if ("string" == variableType)
                {
                    Parser.ErrorAtCurrent("ambiguous stack slot for string type, declare earlier in method");
                    break;
                }
                */
            }
            
            // to reserve slot
            InitializeVariable(variableType, false); // local
            if (HadError)
            {
                break;
            }
            if (Block.LocalExists(identifier))
            {
                Parser.ErrorAtCurrent("'" + identifier + "' already exists in this scope");
                break;
            }
            Block.AddLocal(variableType, identifier); // local declaration
            if (Parser.Check(HopperToken.SemiColon))
            {
                if (variableType == "variant")
                {
                    Parser.ErrorAtCurrent("uninitialized variant illegal");
                    break;
                }
                success = true;
                break;               
            }
            success = compileAssignment(identifier, true);
            break;
        } // loop
        return success;
    }
    
    bool compileStatement(bool noSemiColon, bool debugInfoInsert)
    {
        bool success = false;
        <string,string> currentToken = Parser.CurrentToken;
        string tokenString = currentToken["lexeme"];
        HopperToken tokenType = Token.GetType(currentToken);
        if (debugInfoInsert)
        {
            CodeStream.InsertDebugInfo(false);
        }
        
        switch (tokenType)
        {
            case HopperToken.Keyword:
            {
                if (tokenString == "if")
                {
                    success = compileIfStatement();
                    noSemiColon = true;
                }
                else if (tokenString == "return")
                {
                    success = compileReturn();
                }
                else if (tokenString == "break")
                {
                    success = compileBreak();
                }
                else if (tokenString == "continue")
                {
                    success = compileContinue();
                }
                else if (tokenString == "while")
                {
                    success = compileWhile();
                    noSemiColon = true;
                }
                else if (tokenString == "loop")
                {
                    success = compileLoop();
                    noSemiColon = true;
                }
                else if (tokenString == "for")
                {
                    success = compileFor();
                    noSemiColon = true;
                }
                else if (tokenString == "foreach")
                {
                    success = compileForEach();
                    noSemiColon = true;
                }
                else if (tokenString == "switch")
                {
                    success = compileSwitch();
                    noSemiColon = true;
                }
                else
                {
                    // simple type
                    success = compileLocalDeclaration();
                }
            }
            case HopperToken.LT:
            {
                // compound type
                success = compileLocalDeclaration();
            }
            default:
            {
                if (   (tokenType == HopperToken.Identifier) 
                    || (tokenType == HopperToken.DottedIdentifier)
                    || (tokenType == HopperToken.Discarder)
                   )
                {
                    bool isDotted    = (tokenType == HopperToken.DottedIdentifier);
                    bool isDiscarder = (tokenType == HopperToken.Discarder);
                    HopperToken nextTokenType = Parser.PeekTokenType();
                    if (isDiscarder && (nextTokenType != HopperToken.Assign))
                    {
                        Parser.ErrorAtCurrent("'=' expected");
                    }
                    else if (Types.IsEnum(tokenString) || Types.IsFlags(tokenString))
                    {
                        success = compileLocalDeclaration();
                    }
                    else if (nextTokenType == HopperToken.Identifier)
                    {
                        success = compileLocalDeclaration();
                    }
                    else if ((tokenString == "V") && (nextTokenType == HopperToken.LBracket))
                    {
                        success = compileLocalDeclaration(); // V[] result in Slice
                    }
                    else
                    {
                        Advance();
                        <string,string> idToken   = Parser.PreviousToken;
                        tokenString = idToken["lexeme"];
                        tokenType = Token.GetType(Parser.CurrentToken);
                        if (   (tokenType == HopperToken.Assign)
                            || (tokenType == HopperToken.AssignAdd)
                            || (tokenType == HopperToken.AssignSubtract)
                            || (tokenType == HopperToken.AssignMultiply)
                            || (tokenType == HopperToken.AssignDivide)
                            || (tokenType == HopperToken.AssignModulus)
                            || (tokenType == HopperToken.AssignBitAnd)
                            || (tokenType == HopperToken.AssignBitOr)
                           )
                        {
                            // assignment
                            success = compileAssignment(tokenString, false);
                        }
                        else if (tokenType == HopperToken.LBracket)
                        {
                            // array member assignment
                            Advance(); // [
                            loop
                            {
                                string collectionVariable = tokenString;
                                string qualifiedName;
                                string collectionType = Types.GetTypeString(collectionVariable, true, ref qualifiedName);
                                if (Parser.HadError)
                                {
                                    break;
                                }
                                bool isArray = false;
                                bool isList = true;
                                bool isDictionary = false;
                                if (Types.IsArray(collectionType))
                                {
                                    // push first argument: the array
                                    CodeStream.AddInstructionPushVariable(qualifiedName);
                                                                    
                                    // second argument, the index
                                    string indexType = CompileExpression("uint");
                                    if (Parser.HadError)
                                    {
                                        break;
                                    }
                                    
                                    if (indexType != "uint")
                                    {
                                        if (Types.AutomaticUpCastTop(indexType, "uint"))
                                        {
                                            indexType = "uint";
                                        }                     
                                    }
                                    if (indexType == "int")
                                    {
                                        CompileDynamicCast(indexType, "uint");
                                        indexType = "uint";
                                    }
                                    if (indexType != "uint")
                                    {
                                        Parser.ErrorAtCurrent("array index type invalid");
                                        break;
                                    }
                                    isArray = true;
                                }
                                else if (Types.IsList(collectionType))
                                {
                                    // push first argument: the list
                                    CodeStream.AddInstructionPushVariable(qualifiedName);
                                    
                                    // second argument, the index
                                    string indexType = CompileExpression("uint");
                                    
                                    if (Parser.HadError)
                                    {
                                        break;
                                    }
                                    
                                    if (indexType != "uint")
                                    {
                                        if (Types.AutomaticUpCastTop(indexType, "uint"))
                                        {
                                            indexType = "uint";
                                        }                     
                                    }
                                    if (indexType != "uint")
                                    {
                                        Parser.ErrorAtCurrent("list index type invalid");
                                        break;
                                    }
                                    isList = true;
                                }
                                else if (Types.IsDictionaryOrPair(collectionType))
                                {
                                    // push first argument: the dictionary
                                    CodeStream.AddInstructionPushVariable(qualifiedName);
                                    
                                    // <string,string>
                                    string keyType = Types.GetKeyFromCollection(collectionType);
                                    
                                    // second argument, the key
                                    string actualType = CompileExpression(keyType);
                                    if (Parser.HadError)
                                    {
                                        break;
                                    }
                                    if (keyType != actualType)
                                    {
                                        if ((keyType == "string") && (actualType != "string"))
                                        {
                                            Parser.ErrorAtCurrent("dictionary key type should be 'string', (not '" + actualType +"')");
                                            break;
                                        }
                                        if (Types.AutomaticUpCastTop(actualType, keyType))
                                        {
                                            actualType = keyType;
                                        }
                                        if ((actualType == "int") && (keyType == "uint"))
                                        {
                                            CompileDynamicCast(actualType, keyType);
                                            actualType = keyType;
                                        }
                                        if (keyType != actualType)
                                        {
                                            Parser.ErrorAtCurrent("dictionary key type should be '" + keyType + "', (not '" + actualType +"')");
                                            break;
                                        }
                                    }
                                    isDictionary = true;
                                }
                                else
                                {
                                    Parser.ErrorAtCurrent("identifier not array, dictionary or list type");
                                    break;
                                }
                                
                                Parser.Consume(HopperToken.RBracket);
                                if (Parser.HadError)
                                {
                                    break;
                                }
                                Parser.Consume(HopperToken.Assign);
                                if (Parser.HadError)
                                {
                                    break;
                                }
                                
                                // final argument: value
                                string expressionType = CompileExpression(collectionType);
                                if (Parser.HadError)
                                {
                                    break;
                                }
                                string valueType = Types.GetValueFromCollection(collectionType);
                                
                                if (expressionType != valueType)
                                {
                                    if (valueType == "variant")
                                    {
                                        // a variant value container can contain anything
                                        if (Types.IsValueType(expressionType))
                                        {
                                            // box value types before adding to collection as variant                                            
                                            byte vt = Types.ToByte(expressionType);
                                            CodeStream.AddInstructionPUSHI(vt);
                                            CodeStream.AddInstructionSysCall0("Variant", "Box");
                                        }
                                    }
                                    else if (!Types.AutomaticUpCastTop(expressionType, valueType))
                                    {
                                        Parser.ErrorAtCurrent("type mismatch in assignment, expect '" + valueType + "', was '" + expressionType + "'");       
                                        break;
                                    }
                                }                          
                                if (isArray)
                                {           
                                    if (CodeStream.Target6502 && IsWordValueType(valueType))
                                    {
                                        CodeStream.AddInstructionSysCall0("Array", "SetItemUInt");
                                    }
                                    else
                                    {
                                        CodeStream.AddInstructionSysCall0("Array", "SetItem");
                                    }
                                }
                                else if (isDictionary)
                                {
                                    CodeStream.AddInstructionSysCall0("Dictionary", "Set");   
                                }
                                else if (isList)
                                {
                                    CodeStream.AddInstructionSysCall0("List", "SetItem"); // compileStatement: list[i] = ..
                                }
                                else
                                {
                                    Die(0x0B); // what's this? string?
                                }
                                success = true;
                                break;
                            }
                        }
                        else if ((tokenType == HopperToken.Increment) || (tokenType == HopperToken.Decrement))
                        {
                            // ++ or --
                            success = compileIncrementDecrement(tokenString, tokenType);
                        }
                        else if (tokenType == HopperToken.LParen)
                        {
                            // method call
                            string returnType = CompileMethodCall(tokenString, "", "");
                            if (returnType != "void")
                            {
                                Parser.ErrorAtCurrent("function cannot be used as method (return value must be consumed)");
                            }
                            else
                            {
                                success = true;
                            }
                        }
                        else
                        {
                            if (!Parser.HadError)
                            {
                                Parser.ErrorAtCurrent("'(' or '=' expected");
                            }
                        }
                    }
                }
                else
                {
                    // failed
                }
            }
        } // switch (tokenType)
        if (success && !noSemiColon)
        {
            /*
            if (!Parser.Check(HopperToken.SemiColon))
            {
                DumpPrevious();
                DumpCurrent();
            }
            */
            Parser.Consume(HopperToken.SemiColon);
        }
        return success;
    }
                                                                 
    compileBlock()
    {
        loop
        {
            if (!Parser.Check(HopperToken.LBrace))
            {
                Parser.ErrorAtCurrent('{');
                break;
            }
            
            Parser.Advance(); // {
            //CodeStream.InsertDebugInfo(true);
            loop
            {
                // next statement ..
                if (Parser.HadError)
                {
                    break;
                }
                if (Parser.Check(HopperToken.Directive))
                {
                    // preprocessor directives (#ifdef, #ifndef, #else, #endif")
                    Directives.Directive();
                }
                else
                {
                    // not directive
                    bool allDefined = Directives.IsAllDefined();
                    if (!allDefined)
                    {
                        loop
                        {
                            if (Parser.Check(HopperToken.Directive))
                            {
                                break;
                            }
                            if (Parser.Check(HopperToken.EOF))
                            {
                                break;
                            }
                            Parser.Advance(); // gobble gobble
                        }
                    }
                    else if (Parser.Check(HopperToken.RBrace))
                    {
                        Advance(); // }
                        //CodeStream.InsertDebugInfo(true);
                        break; // end of method
                    }
                    else
                    {      
                        <string,string> currentToken = Parser.CurrentToken;
                        HopperToken tokenType = Token.GetType(currentToken);
                        if (   (tokenType == HopperToken.Keyword)           // simple type, "if", "while", ...
                            || (tokenType == HopperToken.LT)                // compound type
                            || (tokenType == HopperToken.Identifier)        // assignment, procedure call
                            || (tokenType == HopperToken.Discarder)         // assignment   
                            || (tokenType == HopperToken.DottedIdentifier) 
                            )
                        {
                            if (!compileStatement(false, true))
                            {
                                if (!Parser.HadError)
                                {
                                    Parser.ErrorAtCurrent("bad statement?");
                                }
                                break;
                            }
                        }
                        else if (tokenType == HopperToken.LBrace)
                        {
                            CodeStream.InsertDebugInfo(false);
                            if (!compileBlockScope())
                            {
                                if (!Parser.HadError)
                                {
                                    Parser.ErrorAtCurrent("bad 'block' statement?");
                                }
                                break;
                            }
                        }
                        else
                        {
                            Parser.ErrorAt(currentToken, "keyword or identifier expected");
                            break;
                        }
                    }
                }   
            } // loop
            break;
        } // loop
    }

    bool compile()
    {
        
        <byte> globalCode = initializeGlobals();
        
        bool success = false;
        bool isMain = true;
        uint progressCount = 0;
        loop
        {
            if (HadError)
            {
                break;
            }
            // compile fIndex
            <string, string> startToken = Symbols.GetOverloadStart(iCurrentOverload);
            Scanner.Reset(startToken);
            Parser.Reset();
            Directives.New();
            CodeStream.New();
            
            if (globalCode.Count != 0)
            {
                CodeStream.AppendCode(globalCode);
                globalCode.Clear();
            }
            
            Types.SetCurrentMethod(iCurrentOverload);
                                                                                                                                                                    
            Parser.Advance(); // load first token
            
            if (Parser.CheckKeyword("system"))
            {
                // no need to compile system calls
                Symbols.OverloadWasCompiled(iCurrentOverload);         
                if (!Symbols.OverloadNextToCompile(ref iCurrentOverload))
                {
                    success = true; // all done
                    break;
                }
                continue;
            }
            else if (Parser.CheckKeyword("library"))
            {
                // no need to compile system calls
                Symbols.OverloadWasCompiled(iCurrentOverload);         
                if (!Symbols.OverloadNextToCompile(ref iCurrentOverload))
                {
                    success = true; // all done
                    break;
                }
                continue;
            }
                              
            <string,string> braceToken = Parser.CurrentToken; // for CodeGen location
            
            //CodeStream.InsertDebugInfo(true);
            CodeStream.AddInstruction(Instruction.ENTER);
            
            if (!isMain) // already pushed with globals
            {
                Block.PushBlock(false); // new block context
            }
            
            <string,variant> blockContext = Block.Top();
            < < string > > arguments = Symbols.GetOverloadArguments(iCurrentOverload);
            blockContext["arguments"] = arguments;
            blockContext["iOverload"] = iCurrentOverload.ToString();
            string returnType = Symbols.GetOverloadReturnType(iCurrentOverload);
            if (returnType != "void")
            {                    
                blockContext["returntype"] = returnType;
            }
            Block.ReplaceTop(blockContext);
                  
            compileBlock();
            
            if (Parser.HadError)
            {
                break;
            }
            if (progressCount % 16 == 0)
            {
                Parser.ProgressTick("h"); // Hopper compiler
            }
            progressCount++;
            
            // check that #ifdef nesting is zero
            if (Directives.IsStillOpen)
            {
                Parser.ErrorAtCurrent("'#endif' expected before end of method");
                break;
            }
            
            if (returnType != "void")
            {
                Instruction lastInstruction = CodeStream.GetLastInstruction();
                if ((lastInstruction != Instruction.RET0)
                 && (lastInstruction != Instruction.RETRESB)
                 && (lastInstruction != Instruction.RETRES)
                   )
                {
                    if (!IsCDecl || (lastInstruction != Instruction.RETB)) // CDECL TODO
                    {
                        PrintLn(Instructions.ToString(lastInstruction));
                        Parser.ErrorAtCurrent("'return' expected");
                        break;
                    }
                }
            }
            else
            {
                
                <string,string> previousToken = Parser.PreviousToken;
                HopperToken tokenType = Token.GetType(previousToken);
                if (tokenType != HopperToken.RBrace)
                {
                    Parser.ErrorAt(previousToken, "'}' expected in compile()!!");
                    Die(0x0B);
                }
                
                
                CodeStream.InsertDebugInfo(true);
                
                if (CodeStream.CheckedBuild)
                {
                    // if you pop locals, sp == bp
                    uint localsToPop = Block.GetLocalsToPop(false, false);
                    CodeStream.AddInstruction(Instruction.TESTBPB, byte(localsToPop));
                }

                uint slotsToPop = Block.GetLocalsToPop(true, isMain);
                if (!NoPackedInstructions && (slotsToPop == 0))
                {
                    CodeStream.AddInstruction(Instruction.RET0);
                }
                else if (!NoPackedInstructions && (slotsToPop < 256))
                {
                    CodeStream.AddInstruction(Instruction.RETB, byte(slotsToPop));
                }
                else
                {
                    CodeStream.AddInstruction(Instruction.RET, slotsToPop);
                }
            }
            if (!isMain)
            {
                Block.PopBlock();
            }
            else
            {
                Block.Export(0);
                
                // pop "main" locals and arguments but keep globals
                <string,variant> mainContext = Block.Top();
                < <string> > empty;
                mainContext["locals"] = empty;
                mainContext["arguments"] = empty;
                Block.ReplaceTop(mainContext);
            }
            
            <byte> codeStream = CodeStream.CurrentStream;
            <string,string> debugInfo = CodeStream.DebugInfo;
            Symbols.SetCodeStream(iCurrentOverload, codeStream, debugInfo);
            CodeStream.ClearDebugInfo();
            
            
            Symbols.OverloadWasCompiled(iCurrentOverload);         
            if (!Symbols.OverloadNextToCompile(ref iCurrentOverload))
            {
                success = true; // all done
                break;
            }
            isMain = false;
        }
        
        return success;
    }
    
    <byte> initializeGlobals()
    {
        <string,variant> top = Block.Top();
        < <string> > globals = top["globals"];
        
        
        // globals
        //   <string> gNames;
        //   <string,uint> gIndex;
        //   <uint, string> gTypes;
        // code location of initialization code:
        //   <uint, long> gStartPos;
        //   <uint, uint> gStartLine;
        //   <uint, string> gSourcePath;
        
        CodeStream.New();
        if (IsCDecl)
        {
            // first instructions to the runtime indicate we are using CDecl
            CodeStream.AddInstruction(Instruction.PUSHR0);
            CodeStream.AddInstruction(Instruction.POPR0);
        }
                             
        uint gCount = Symbols.GetGlobalCount();
        for (uint gIndex = 0; gIndex < gCount; gIndex++)
        {
            <string> global;                     
            string variableType = Symbols.GetGlobalType(gIndex);
            string identifier   = Symbols.GetGlobalName(gIndex);
            global.Append(variableType);
            global.Append(identifier);
            globals.Append(global);
            
            // namespace required in case global is initialized from constant/s
            <string> parts = identifier.Split('.');
            Types.CurrentNamespace = parts[0];
            
            // for reference times, initialize
            // to reserve slot
            InitializeVariable(variableType, false); // global
            if (HadError)
            {
                break;
            }
            
            // compile gIndex
            <string, string> startToken = Symbols.GetGlobalStart(gIndex);
            if (startToken.Count != 0)
            {
                // execute initialization code if there is any
                Scanner.Reset(startToken);
                Parser.Reset();
                Directives.New();
                
                Parser.Advance(); // load first token
                
                string actualType = CompileExpression(variableType);
                if (Parser.HadError)
                {
                    Parser.Error("failure compiling global initializer");
                    break;
                }
                if (actualType != variableType)
                {
                    if (Types.CanInferArrayCast(actualType, variableType))
                    {
                        // ok
                        //PrintLn("Global: " + actualType + "->" + variableType + " " + identifier);
                    }
                    else if (Types.AutomaticUpCastTop(actualType, variableType))
                    {
                        // ok
                    }
                    else
                    {
                        Parser.Error("type mismatch for initializer, (was '" + actualType + "', expected '"+ variableType +"')");
                        break;
                    }
                }
                uint globalAddress = Symbols.GetGlobalAddress(identifier);
                if (!NoPackedInstructions && (globalAddress < 256))
                {
                    CodeStream.AddInstruction(Instruction.POPGLOBALB, byte(globalAddress));
                }
                else
                {
                    CodeStream.AddInstruction(Instruction.POPGLOBAL, globalAddress);
                }
            }
        }
        top["globals"] = globals;
        Block.ReplaceTop(top);
        
        <byte> code = CodeStream.CurrentStream;
        return code;
    }
    
    badArguments()
    {
        PrintLn("Invalid arguments for COMPILE:");
        PrintLn("  COMPILE <object json>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -o : optimized (less runtime checks, peephole optimization on)");
        PrintLn("    -x : use experimental features");
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            bool checkedBuild = true;
            bool touchesTree;
            bool argIsExperimental;
          
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length == 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        case "-o":
                        {
                            checkedBuild = false;   
                        }
                        case "-t":
                        {
                            touchesTree = true;   
                        }
                        case "-x":
                        {
                            argIsExperimental = true;   
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            
            string jsonPath = args[0];
            string ext = ".sym";
            if (!File.Exists(ref jsonPath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            CodeStream.CheckedBuild = checkedBuild;
            
            long startTime = Millis;
            loop
            {
                SysCalls.New();
                LibCalls.New();
                Symbols.New();
                if (!Symbols.Import(jsonPath))
                {
                    break;
                }
                CodeStream.InitializeSymbolShortcuts();
                if (argIsExperimental)
                {
                    IsExperimental = argIsExperimental;
                }
                
                uint mIndex;
                if (!Symbols.GetFunctionIndex("Hopper", ref mIndex))
                {
                    Parser.Error("where is 'Hopper'?");
                    break;
                }
                <uint> mOverloads = Symbols.GetFunctionOverloads(mIndex);
                if (mOverloads.Count != 1)
                {
                    Parser.Error("'Hopper' has overloads?");
                    break;
                }
                
                Scanner.New();
                
                iCurrentOverload = mOverloads[0];
                Symbols.AddFunctionCall(iCurrentOverload); // yup, main is called at least once

                Block.PushBlock(false); // new block context
                if (!compile())
                {
                    break;
                }
                Block.PopBlock();
                
                string extension = Path.GetExtension(jsonPath);
                string codePath = jsonPath.Replace(extension, ".code");
                if (!Symbols.ExportCode(codePath))
                {
                    break;
                }
                
                if (touchesTree)
                {
                    string touchPath = jsonPath.Replace(extension, ".txt");
                    ExportTouchTree(touchPath);
                }
                
                if (!IsInteractive())
                {
                    PrintLn();
                    Print("Success.", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            } // main loop
            break;
        } // argument loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
