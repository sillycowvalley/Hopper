program Translate
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define TRANSLATE
    
    uses "/Source/System/System"
    uses "/Source/System/Diagnostics"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    uses "Tokens/Token"
    
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    uses "Tokens/SysCalls"
    uses "Tokens/LibCalls"
    uses "Symbols"
    
    uses "Types"
    uses "Directives"
    
    uses "CodeGen/Block"
    uses "CodeGen/SourceStream"
    uses "TranslateExpression"
    
    bool isMain;
    
    bool IsDebugger { get { return false; } }
    bool InMain     { get { return isMain; } }
    
    bool isExperimental;
    bool IsExperimental { get { return isExperimental; } }
    bool NoPackedInstructions { get { return false; } } // to keep peephole code happy (even though it is not used)
    
    uint iCurrentOverload;
    string collectedContent;
    
    bool translateIfStatement()
    {
        bool success = false;
        string content;
        loop
        {
            Parser.Advance(); // if
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            string ifCheckType;
            string expressionContent = TranslateExpression("bool", ref ifCheckType);
            if ("bool" != ifCheckType)
            {
                Parser.Error("boolean expression expected, (was '" + ifCheckType + "')");
                break;
            }    
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            content = content + "if (" + expressionContent + ")";
            SourceStream.NewLine();
            SourceStream.Append(content);
            content = "";
            
            Block.PushBlock(false); // not a loop context
            translateBlock(false);
            Block.PopBlock();
            if (Parser.HadError)
            {
                break;
            }
            if (Parser.CheckKeyword("else"))
            {
                Advance(); // else
                if (Parser.CheckKeyword("if"))
                {
                    content = "else ";
                    continue; // else if
                }   
                // final else block
                SourceStream.NewLine();
                SourceStream.Append("else");
            
                Block.PushBlock(false); // not a loop context
                translateBlock(false);
                Block.PopBlock();
            }
            success = true;                    
            break;
        }
        return success;
    }
    
    bool translateReturn()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // return
            SourceStream.NewLine();
            SourceStream.Append("return");
            
            string returnType = "void";
            <string,variant> blockContext = Block.GetMethodBlock();
            uint returnBytes = 0;
            if (blockContext.Count != 0)
            {
                if (blockContext.Contains("returntype"))
                {
                    string actualReturnType;
                    string returnExpression = TranslateExpression(returnType, ref actualReturnType);
                    SourceStream.Append(" " + returnExpression);        
                }
            }
            success = true;
            break;
        }
        return success;
    }
    
    bool translateBreak()
    {
        bool success = true;
        
        Parser.Advance(); // break;
        SourceStream.NewLine();
        SourceStream.Append("break;");
        
        return success;
    }
    
    bool translateContinue()
    {
        bool success = true;
        
        Parser.Advance(); // break;
        SourceStream.NewLine();
        SourceStream.Append("continue;");
        
        return success;
    }
    
    bool translateWhile()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // while
            
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            string whileCheckType;
            string whileExpression = TranslateExpression("bool", ref whileCheckType);
            if ("bool" != whileCheckType)
            {
                Parser.Error("boolean expression expected, (was '" + whileCheckType + "')");
                break;
            }  
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            SourceStream.NewLine();
            SourceStream.Append("while (" + whileExpression + ")");
            
            Block.PushBlock(false); // for block locals
            translateBlock(false);
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
            success = true;                    
            break;
        }
        return success;
    }
    
    
    bool translateFor()
    {
        bool success = false;
        loop
        {
            
            Parser.Advance(); // for
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            string initializationContent;
            
            // initialization statement
            if (Parser.Check(HopperToken.SemiColon))
            {
                // empty initialization statement
                Parser.Consume(HopperToken.SemiColon);
            }
            else
            {
                collectedContent = "";
                if (!translateStatement(false, true)) 
                {
                    break;
                }
                initializationContent = collectedContent;
            }
            
            string exitCheckType;
            string exitCheckContent = TranslateExpression("bool", ref exitCheckType);
            if ("bool" != exitCheckType)
            {
                Parser.Error("boolean expression expected, (was '" + exitCheckType + "')");
                break;
            }
            Parser.Consume(HopperToken.SemiColon);
            if (Parser.HadError)
            {
                break;
            }
            
            string incrementContent;
            
            // increment statement (no semicolon)
            if (!Parser.Check(HopperToken.RParen)) // can be empty
            {
                collectedContent = "";
                if (!translateStatement(true, true)) 
                {
                    break;
                }
                incrementContent = collectedContent;
            }
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            SourceStream.NewLine();
            SourceStream.Append("for (" + initializationContent + "; " + exitCheckContent + "; " + incrementContent + ")");
            
            Block.PushBlock(false); // for block locals
            translateBlock(false);
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
            
            success = true;
            break;
        } // loop
        return success;
    }
    
    bool translateLoop()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // loop
            
            SourceStream.NewLine();
            SourceStream.Append("for (;;)");
            
            Block.PushBlock(false); // for block locals
            translateBlock(false);
            Block.PopBlock();
            
            if (Parser.HadError)
            {
                break;
            }
            success = true;                    
            break;
        }
        return success;
    }
    bool translateSwitch()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // switch
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            string switchType;
            string switchExpression = TranslateExpression("", ref switchType);
            if (Parser.HadError)
            {
                break;
            }
            if (!Types.IsValueType(switchType) && (switchType != "string"))
            {
                Parser.ErrorAtCurrent("'switch' expression type must be value type or string");
                break;
            }
            
            
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            SourceStream.NewLine();
            SourceStream.Append("switch (" + switchExpression + ")");
            
            
            Parser.Consume(HopperToken.LBrace);
            if (Parser.HadError)
            {
                break;
            }
            SourceStream.NewLine();
            SourceStream.Append("{");
            
            bool defaultSeen = false;
            loop
            {
                if (Parser.Check(HopperToken.RBrace))
                {
                    success = true;
                    Parser.Advance(); // }
                    SourceStream.NewLine();
                    SourceStream.Append("} // switch");
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent("unexpected EOF in 'switch'");
                    break;
                }
                
                bool isDefault = false;
                if (!Parser.CheckKeyword("case"))
                {
                    if (Parser.CheckKeyword("default"))
                    {
                        isDefault = true;       
                        if (defaultSeen)
                        {
                            Parser.ErrorAtCurrent("'default' can only occur once");
                            break;    
                        }
                        defaultSeen = true;
                    }
                    else
                    {
                        Parser.ErrorAtCurrent("'case' expected");
                        break;
                    }
                }
                if (defaultSeen && !isDefault)
                {
                    Parser.ErrorAtCurrent("'default' must be last case");
                    break;    
                }   
                
                loop
                {
                    Parser.Advance(); // "case" or "default"
                    if (!isDefault)
                    {   
                        string caseType;
                        string caseConstant = TranslateExpression("", ref caseType);
                        if (Parser.HadError)
                        {
                            break;
                        }
                        SourceStream.NewLine();
                        SourceStream.Append("case " + caseConstant + ":");
                    } // !isDefault   
                    else
                    {
                        SourceStream.NewLine();
                        SourceStream.Append("default:");
                    }
                    Parser.Consume(HopperToken.Colon);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    
                    if (!isDefault)
                    {
                        if (Parser.CheckKeyword("case"))
                        {
                            continue; // multiple cases
                        }
                    }
                    break;
                } // loop: multiple "case"     
            
                if (Parser.HadError)
                {
                    break;
                }

                     
                Block.PushBlock(false); // not loop context
                translateBlock(true);
                Block.PopBlock();
                
                
 
            } // loop

            break;
        } // loop
        return success;
    }
    
    bool translateIncrementDecrement(string variableName, HopperToken tokenType, bool collectContent)
    {
        string content;
        bool success = false;
        loop
        {
            Parser.Advance(); // ++ or --
            string qualifiedName;
            string variableType = Types.GetTypeString(variableName, true, ref qualifiedName);
            if (Parser.HadError)
            {
                break;
            }
            if (!Types.IsNumericType(variableType))
            {
                Parser.ErrorAtCurrent("++ and -- operations only legal for numeric types");
                break;
            }
            
            if (tokenType == HopperToken.Increment)
            {
                content = TranslateIdentifier(qualifiedName) + "++";
            }
            else if (tokenType == HopperToken.Decrement)
            {
                content = TranslateIdentifier(qualifiedName) + "--";
            }
            success = true;           
            if (collectContent)
            {
                collectedContent = content;
            }
            else
            {
                SourceStream.NewLine();
                SourceStream.Append(content);
            }
            break;
        }
        return success;
    } 
    
    
    bool translateLocalDeclaration(bool collectContent)
    {
        string content;
        bool success = false;
        loop
        {
            string variableType = Types.ParseType();
            if (Parser.HadError)
            {
                break;
            }
            if (!Parser.Check(HopperToken.Identifier))
            {
                if (!Parser.Check(HopperToken.DottedIdentifier))
                {
                    Parser.ErrorAtCurrent("identifier expected");
                    break;
                }
            }
            <string,string> idToken   = Parser.CurrentToken;
            string identifier = idToken["lexeme"];
            
            char firstCharacter = identifier[0];
            if (firstCharacter.IsUpper())
            {
                Parser.ErrorAtCurrent("public identifier for local declaration is invalid");
                break;
            }
            Parser.Advance(); // identifier
            
            if (!Parser.Check(HopperToken.Assign) && !Parser.Check(HopperToken.SemiColon))
            {
                Parser.ErrorAtCurrent("';' or '=' expected");
                break;
            }
            
            content = TranslateType(variableType) + " ";
            Block.AddLocal(variableType, identifier);  // local declaration
            if (Parser.Check(HopperToken.SemiColon))
            {
                if (variableType == "bool")
                {
                    content = content + TranslateIdentifier(identifier) + " = false";
                }
                else if (IsSimpleType(variableType))
                {
                    content = content + TranslateIdentifier(identifier) + " = 0";
                }
                else
                {
                    content = content + TranslateIdentifier(identifier) + " = (" + variableType + ")0"; // enums?
                }
                success = true;
            }
            else
            {
                collectedContent = ""; // for clarity
                success = translateAssignment(identifier, true);
                if (success)
                {
                    content = content + collectedContent;
                }
            }
            if (success)
            {
                if (collectContent)
                {
                    collectedContent = content;
                }
                else
                {
                    SourceStream.NewLine();
                    SourceStream.Append(content);
                }
            }
            break;
        } // loop
        
        return success;
    }
    
    bool translateAssignment(string variableName, bool collectContent)
    {
        bool success = false;
        loop
        {
            <string,string> leftToken = PreviousToken;
            HopperToken leftTokenType = Token.GetType(leftToken); 
            Parser.Consume(HopperToken.Assign);
            if (Parser.HadError)
            {
                break;
            }
            
            string qualifiedName;
            string variableType;
            if (leftTokenType != HopperToken.Discarder)
            {
                // uses Blocks, respects namespaces, Parser.Error on failure
                variableType = Types.GetTypeString(variableName, false, ref qualifiedName);
            }
            if (Parser.HadError)
            {
                break;
            }
            
            bool isSetter = false;
            uint iOverload;
            
            string setterMethod;
            if ((variableType.Length == 0) && (leftTokenType != HopperToken.Discarder))
            {
                // perhaps it is a setter
                setterMethod = variableName + "_Set";
                setterMethod = Types.QualifyMethodName(setterMethod);
                uint fIndex;
                if (!Symbols.GetFunctionIndex(setterMethod, ref fIndex))
                {
                    Parser.ErrorAt(leftToken, "undefined method identifier");   
                    break;
                }
                
                <uint> overloads = Symbols.GetFunctionOverloads(fIndex);
                if (overloads.Count != 1)
                {
                    Parser.ErrorAt(leftToken, "setter method should only have one overload");   
                    break;
                }
                iOverload = overloads[0];
                < < string > > arguments = Symbols.GetOverloadArguments(iOverload); 
                
                if (arguments.Count != 1)
                {
                    Parser.ErrorAt(leftToken, "setter method should only have one argument");   
                    break;
                }
                <string> argument = arguments[0];
                variableType = argument[1];   
                isSetter = true;
                Symbols.OverloadToCompile(iOverload);
            }
            string expressionType;
            string expressionContent = TranslateExpression(variableType, ref expressionType);
            if (Parser.HadError)
            {
                break;
            }
            string content;
            if (leftTokenType == HopperToken.Discarder)
            {
                content = expressionContent;
            }
            else if (!isSetter)
            {
                content = TranslateIdentifier(qualifiedName) + " = " + expressionContent;
            }
            else
            {
                content = TranslateIdentifier(setterMethod) + "(" + expressionContent + ")";
            }
            if (collectContent)
            {
                collectedContent = collectedContent + content;
            }
            else
            {
                SourceStream.Append(content);
            }
            
            success = true;
            break;
        }    
        return success;
    }
                
                
    
    bool translateStatement(bool noSemiColon, bool collectContent)
    {
        bool success = false;
        <string,string> currentToken = Parser.CurrentToken;
        string tokenString = currentToken["lexeme"];
        HopperToken tokenType = Token.GetType(currentToken);
        
        switch (tokenType)
        {
            case HopperToken.Keyword:
            {
                if (tokenString == "if")
                {
                    success = translateIfStatement();
                    noSemiColon = true;
                }
                else if (tokenString == "return")
                {
                    success = translateReturn();
                }
                else if (tokenString == "break")
                {
                    success = translateBreak();
                }
                else if (tokenString == "continue")
                {
                    success = translateContinue();
                }
                else if (tokenString == "while")
                {
                    success = translateWhile();
                    noSemiColon = true;
                }
                else if (tokenString == "loop")
                {
                    success = translateLoop();
                    noSemiColon = true;
                }
                else if (tokenString == "for")
                {
                    success = translateFor();
                    noSemiColon = true;
                }
                else if (tokenString == "switch")
                {
                    success = translateSwitch();
                    noSemiColon = true;
                }
                else
                {
                    // simple type
                    success = translateLocalDeclaration(collectContent);
                }
            }
            default:
            {
                if ((tokenType == HopperToken.Identifier) || (tokenType == HopperToken.DottedIdentifier))
                {
                    bool isDotted = (tokenType == HopperToken.DottedIdentifier);
                    if (Types.IsEnum(tokenString) || Types.IsFlags(tokenString))
                    {
                        success = translateLocalDeclaration(collectContent);
                    }
                    else if (Parser.PeekTokenType() == HopperToken.Identifier)
                    {
                        success = translateLocalDeclaration(collectContent);
                    }
                    else
                    {
                        Advance();
                        <string,string> idToken   = Parser.PreviousToken;
                        tokenString = idToken["lexeme"];
                        tokenType = Token.GetType(Parser.CurrentToken);
                        if (tokenType == HopperToken.Assign)
                        {
                            // assignment
                            if (!collectContent)
                            {
                                SourceStream.NewLine();
                            }
                            success = translateAssignment(tokenString, collectContent);
                        }
                        else if ((tokenType == HopperToken.Increment) || (tokenType == HopperToken.Decrement))
                        {
                            // ++ or --
                            if (!collectContent)
                            {
                                SourceStream.NewLine();
                            }
                            success = translateIncrementDecrement(tokenString, tokenType, collectContent);
                        }
                        else if (tokenType == HopperToken.LParen)
                        {
                            // method call
                            string returnType;
                            string content = TranslateMethodCall(tokenString, "", "", "", ref returnType);
                            if (returnType != "void")
                            {
                                Parser.ErrorAtCurrent("function cannot be used as method (return value must be consumed)");
                            }
                            else
                            {
                                success = true;
                            }
                            SourceStream.NewLine();
                            SourceStream.Append(content);
                            if (!Parser.HadError)
                            {
                                success = true;
                            }
                        }
                        else
                        {
                            if (!Parser.HadError)
                            {
                                Parser.ErrorAtCurrent("'(' or '=' expected");
                            }
                        }
                    }
                }
                else
                {
                    // failed
                }
            }
        } // switch (tokenType)
        if (success && !noSemiColon)
        {
            /*
            if (!Parser.Check(HopperToken.SemiColon))
            {
                DumpPrevious();
                DumpCurrent();
            }
            */
            Parser.Consume(HopperToken.SemiColon);
            SourceStream.Append(";");
        }
        return success;
    }
           
    translateBlock(bool insertBreak)
    {
        loop
        {
            if (!Parser.Check(HopperToken.LBrace))
            {
                Parser.ErrorAtCurrent('{');
                break;
            }
            
            SourceStream.NewLine();
            SourceStream.Append("{", -1);
            
            
            Parser.Advance(); // {
            loop
            {
                // next statement ..
                if (Parser.HadError)
                {
                    break;
                }
                if (Parser.Check(HopperToken.Directive))
                {
                    // preprocessor directives (#ifdef, #ifndef, #if, #else, #endif")
                    Directives.Directive();
                }
                else
                {
                    // not directive
                    bool allDefined = Directives.IsAllDefined();
                    if (!allDefined)
                    {
                        loop
                        {
                            if (Parser.Check(HopperToken.Directive))
                            {
                                break;
                            }
                            if (Parser.Check(HopperToken.EOF))
                            {
                                break;
                            }
                            Parser.Advance(); // gobble gobble
                        }
                    }
                    else if (Parser.Check(HopperToken.RBrace))
                    {
                        Advance(); // }
                        
                        if (insertBreak)
                        {
                            SourceStream.NewLine();
                            SourceStream.Append("break;");
                        }
                        SourceStream.NewLine();
                        SourceStream.Append("}", -1);
                        break; // end of method
                    }
                    else
                    {      
                        <string,string> currentToken = Parser.CurrentToken;
                        HopperToken tokenType = Token.GetType(currentToken);
                        if (   (tokenType == HopperToken.Keyword)           // simple type, "if", "while", ...
                            || (tokenType == HopperToken.LT)                // compound type
                            || (tokenType == HopperToken.Identifier)        // assignment, procedure call
                            || (tokenType == HopperToken.DottedIdentifier) 
                            )
                        {
                            string collectContent;
                            if (!translateStatement(false, false))
                            {
                                if (!Parser.HadError)
                                {
                                    Parser.ErrorAtCurrent("bad statement?");
                                }
                                break;
                            }
                        }
                        else if (tokenType == HopperToken.LBrace)
                        {
                            Parser.ErrorAt(currentToken, "unexpected '{'");
                            break;
                        }
                        else
                        {
                            Parser.ErrorAt(currentToken, "keyword or identifier expected");
                            break;
                        }
                    }
                }   
            } // loop
            break;
        } // loop
    }
    
    bool translate()
    {
        SourceStream.New();
        initializeGlobals();
        
        translateNamedTypes();
        
        bool success = false;
        isMain = true;
        loop
        {
            // compile fIndex
            <string, string> startToken = Symbols.GetOverloadStart(iCurrentOverload);
            Scanner.Reset(startToken);
            Parser.Reset();
            Directives.New();
            
            Types.SetCurrentMethod(iCurrentOverload);
            string methodName = GetMethodNameFromOverload(iCurrentOverload);
            if (isMain)
            {
                methodName = "HopperEntryPoint";
            }
            string returnType = GetOverloadReturnType(iCurrentOverload);
            
            string headerContent;
            
            bool isExternal = methodName.StartsWith("External.") 
                           //|| methodName.StartsWith("HRScreen.") 
                           || methodName.StartsWith("HRWire.") 
                           || methodName.StartsWith("HRSPI.") 
                           || methodName.StartsWith("HRNeoPixel.") 
                           //|| methodName.StartsWith("HRGraphics.")
                           || methodName.Contains(".Inlined");
            
            < < string > > arguments = GetOverloadArguments(iCurrentOverload);
            bool firstarg = true;
            bool hadReference;
            foreach (var argument in arguments)
            {
                string reference = argument[0];
                string argtype   = argument[1];
                string argname   = argument[2];
                if (!firstarg)
                {
                    headerContent = headerContent + ", ";
                }
                string refContent = " ";
                if (reference == "ref")
                {
                    refContent = " & ";
                    hadReference = true;
                }
                headerContent = headerContent + TranslateType(argtype) + refContent + TranslateIdentifier(argname); 
                firstarg = false;   
            }
            headerContent = headerContent + ")";
            if (hadReference)
            {
                headerContent = TranslateType(returnType) + " " + TranslateIdentifier(methodName) + "_R" + "(" + headerContent;
            }
            else
            {
                headerContent = TranslateType(returnType) + " " + TranslateIdentifier(methodName) + "(" + headerContent;
            }
            
            if (!isExternal)
            {
                Parser.Advance(); // load first token
                isExternal = Parser.CheckKeyword("|system|library|");
            }
            if (isExternal)
            {
                // no need to translate system calls or External methods
                Symbols.OverloadWasCompiled(iCurrentOverload);         
                if (!Symbols.OverloadNextToCompile(ref iCurrentOverload))
                {
                    success = true; // all done
                    break;
                }
                continue;
            }
            
            SourceStream.AppendHeader(headerContent + ";");
            
            SourceStream.NewLine();
            SourceStream.NewLine();
            if (isMain)
            {
                SourceStream.Append(headerContent, -1);
            }
            else
            {
                SourceStream.Append(headerContent);
            }
            
            <string,string> braceToken = Parser.CurrentToken; // for CodeGen location
            
            if (!isMain) // already pushed with globals
            {
                Block.PushBlock(false); // new block context
            }
            
            <string,variant> blockContext = Block.Top();
            arguments = Symbols.GetOverloadArguments(iCurrentOverload);
            blockContext["arguments"] = arguments;
            blockContext["iOverload"] = iCurrentOverload.ToString();
            returnType = Symbols.GetOverloadReturnType(iCurrentOverload);
            if (returnType != "void")
            {                    
                blockContext["returntype"] = returnType;
            }
            Block.ReplaceTop(blockContext);
                     
            translateBlock(false);
            
            if (Parser.HadError)
            {
                break;
            }
            Parser.ProgressTick("t"); // translate
            
            // check that #ifdef nesting is zero
            if (Directives.IsStillOpen)
            {
                Parser.ErrorAtCurrent("'#endif' expected before end of method");
                break;
            }
            
            
            <string,string> previousToken = Parser.PreviousToken;
            HopperToken tokenType = Token.GetType(previousToken);
            if (tokenType != HopperToken.RBrace)
            {
                Parser.ErrorAt(previousToken, "'}' expected in translate()!!");
                Die(0x0B);
            }
            
            if (!isMain)
            {
                Block.PopBlock();
            }
            else
            {
                Block.Export(0);
                
                // pop "main" locals and arguments but keep globals
                <string,variant> mainContext = Block.Top();
                < <string> > empty;
                mainContext["locals"] = empty;
                mainContext["arguments"] = empty;
                Block.ReplaceTop(mainContext);
            }
            
            Symbols.OverloadWasCompiled(iCurrentOverload);         
            if (!Symbols.OverloadNextToCompile(ref iCurrentOverload))
            {
                success = true; // all done
                break;
            }
            isMain = false;
        }
        return success;
    }   
    
    translateNamedTypes()
    {
        <string, <string, uint> > eValues = GetEnums();
        foreach (var kv in eValues)
        {
            string enumName = kv.key;
            
            <string, uint> enumMembers = GetEnumMembers(enumName);
            
            uint iDot;
            if (enumName.IndexOf('.', ref iDot))
            {
                enumName = enumName.Substring(iDot+1);
            }
            AppendHeader("enum " + enumName + " {");
            foreach (var kv2 in enumMembers)
            {
                string member = kv2.key;
                uint   value = kv2.value;
                if (member.LastIndexOf('.', ref iDot))
                {
                    member = member.Substring(iDot+1);
                }
                AppendHeader("    e" + member + " = 0x" + value.ToHexString(4) + ",");   
            }
            AppendHeader("};");
            AppendHeader("");
        }
        
        eValues = GetFlags();
        foreach (var kv in eValues)
        {
            string enumName = kv.key;
            
            <string, uint> enumMembers = GetFlagMembers(enumName);
            
            uint iDot;
            if (enumName.IndexOf('.', ref iDot))
            {
                enumName = enumName.Substring(iDot+1);
            }
            AppendHeader("enum " + enumName + " {");
            foreach (var kv2 in enumMembers)
            {
                string member = kv2.key;
                uint   value = kv2.value;
                if (member.LastIndexOf('.', ref iDot))
                {
                    member = member.Substring(iDot+1);
                }
                AppendHeader("    e" + member + " = 0x" + value.ToHexString(4) + ",");   
            }
            AppendHeader("};");
            AppendHeader("");
        }
    }
    
    initializeGlobals()
    {
        <string,variant> top = Block.Top();
        < <string> > globals = top["globals"];
        
        
        // globals
        //   <string> gNames;
        //   <string,uint> gIndex;
        //   <uint, string> gTypes;
        // code location of initialization code:
        //   <uint, long> gStartPos;
        //   <uint, uint> gStartLine;
        //   <uint, string> gSourcePath;
        
        
                             
        uint gCount = Symbols.GetGlobalCount();
        for (uint gIndex = 0; gIndex < gCount; gIndex++)
        {
            <string> global;                     
            string variableType = Symbols.GetGlobalType(gIndex);
            string identifier   = Symbols.GetGlobalName(gIndex);
            global.Append(variableType);
            global.Append(identifier);
            globals.Append(global);
            
            if (!Types.IsValueType(variableType) && !Types.IsDelegate(variableType))
            {
                Parser.ErrorAtCurrent("'" + variableType + "' not implemented in initializeGlobals");
                break;
            }
            
            SourceStream.NewLine();
            SourceStream.Append(TranslateType(variableType) + " " + TranslateIdentifier(identifier));
            
            // compile gIndex
            <string, string> startToken = Symbols.GetGlobalStart(gIndex);
            if (startToken.Count != 0)
            {
                // execute initialization code if there is any
                Scanner.Reset(startToken);
                Parser.Reset();
                Directives.New();
                
                Parser.Advance(); // load first token
                
                string actualType;
                string content = TranslateExpression(variableType, ref actualType);
                if (Parser.HadError)
                {
                    Parser.Error("failure compiling global initializer");
                    break;
                }
                SourceStream.Append(" = " + content); // initialized
            }
            else if (variableType == "bool")
            {
                SourceStream.Append(" = false");
            }
            else if (IsSimpleType(variableType))
            {
                SourceStream.Append(" = 0");
            }
            else
            {
                SourceStream.Append(" = (" + variableType + ")0"); // enums?
            }
            SourceStream.Append(";");
        }
        top["globals"] = globals;
        Block.ReplaceTop(top);
        
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for TRANSLATE:");
        PrintLn("  TRANSLATE <object json>");
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length == 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                BadArguments();
                break;
            }
            string jsonPath = args[0];
            string ext = ".sym";
            if (!File.Exists(ref jsonPath, ref ext, "/Debug/Obj/"))
            {
                BadArguments();
            }
            
            long startTime = Millis;
            loop
            {
                SysCalls.New();
                LibCalls.New();
                Symbols.New();
                if (!Symbols.Import(jsonPath))
                {
                    break;
                }
                
                string extension = Path.GetExtension(jsonPath);
                string codePath = jsonPath.Replace(extension, ".cpp");
                string headerpath = jsonPath.Replace(extension, ".h");
                
                
                uint mIndex;
                if (!Symbols.GetFunctionIndex("Hopper", ref mIndex))
                {
                    Parser.Error("where is 'Hopper'?");
                    break;
                }
                <uint> mOverloads = Symbols.GetFunctionOverloads(mIndex);
                if (mOverloads.Count != 1)
                {
                    Parser.Error("'Hopper' has overloads?");
                    break;
                }
                
                Scanner.New();
                
                iCurrentOverload = mOverloads[0];
                Symbols.AddFunctionCall(iCurrentOverload); // yup, main is called at least once
                Block.PushBlock(false); // new block context
                if (!translate())
                {
                    break;
                }
                Block.PopBlock();
                if (!SourceStream.Export(headerpath, codePath))
                {
                    break;
                }
                
                string headerDestination = Path.GetFileName(headerpath);
                headerDestination = Path.Combine("/Runtimes/Arduino/HopperPortable", headerDestination);
                string codeDestination   = Path.GetFileName(codePath);
                codeDestination = Path.Combine("/Runtimes/Arduino/HopperPortable", codeDestination);
                
                if (!File.Copy(headerpath, headerDestination, true))
                {
                    break;
                }
                if (!File.Copy(codePath, codeDestination, true))
                {
                    break;
                }
                
                PrintLn();
                Print("Success.", Colour.ProgressText, Colour.ProgressFace);
                long elapsedTime = Millis - startTime;
                float seconds = elapsedTime / 1000.0;
                PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
                
                success = true; 
                break;
            } // main loop
            break;
        } // argument loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
