program DASM
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define ASSEMBLER
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "CODEGEN/Asm6502"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/SysCalls"
    uses "Tokens/LibCalls"
    uses "Tokens/Parser"
    
    uses "Symbols"
    
    bool ogMode;
    bool OGMode    { get { return ogMode; } }
    
    uint instructionCount = 0;
    
    <uint, long> profileHits;
    
    string pathLoaded;
    <string> sourceLines;
    string getSourceLine(string path, string lnum)
    {
        if (pathLoaded != path)
        {
            file sourceFile = File.Open(path);
            if (sourceFile.IsValid())
            {
                sourceLines.Clear();
                pathLoaded = path;
                loop
                {
                    string ln = sourceFile.ReadLine();
                    if (ln.Length == 0)
                    {
                        if (!sourceFile.IsValid())
                        {
                            break;
                        }
                    }
                    sourceLines.Append(ln);
                }
            }
        }
        string sourceLine;
        uint iline;
        if (UInt.TryParse(lnum, ref iline))
        {
            if (iline > 0)
            {
                iline--;
            }
            if (sourceLines.Count > iline)
            {
                sourceLine = sourceLines[iline];
            }
        }
        return sourceLine;
    }
    
    <byte> readIHex(file hexFile, ref uint org)
    {
        bool first = true;
        <byte> code;
        uint byteCount = 0;
        Parser.ProgressTick("i");  // readIHex
        loop
        {
            string ln = hexFile.ReadLine();
            if (!hexFile.IsValid()) { break; }
            string len = ln.Substring(1,2);
            uint length;
            _ = UInt.TryParse("0x" + len, ref length);
            if (length == 0) { continue; }
            if (first)
            {
                string orgString = ln.Substring(3,4);
                _ = UInt.TryParse("0x" + orgString, ref org);
            }
            ln = ln.Substring(9);
            while (length > 0)
            {
                string br = ln.Substring(0, 2);
                ln = ln.Substring(2);
                uint b;
                _ = UInt.TryParse("0x" + br, ref b);
                code.Append(byte(b));
                length--;
            }
            first = false;
            if (byteCount % 8192 == 0)
            {
                Parser.ProgressTick("i");  // readIHex
            }
            byteCount += 16;
        }
        return code;
    }
    
    // Helper method to render jump table in pretty format (for disassembly)
    RenderJumpTablePretty(file hasmFile, <byte> code, ref uint index, ref uint address, 
                          ref uint codeSize, uint tableSizeInWords, 
                          <uint,uint> methodAddresses, string commentPrefix)
    {
        string previousComment;
        for (byte i = 0; i < tableSizeInWords; i++)
        {
            uint tableEntry = code[index] + code[index+tableSizeInWords] << 8; 
            string comment = "";
            if (methodAddresses.Contains(tableEntry))
            {
                uint methodIndex = methodAddresses[tableEntry];
                <string,variant> methodSymbols = Code.GetMethodSymbols(methodIndex);
                if (methodSymbols.Count != 0)
                {
                    string nm = methodSymbols["name"];
                    comment = "// -> " + nm + "()";
                    if (false && (comment == previousComment))
                    {
                        comment = "// ->            ''";
                    }
                    else
                    {
                        previousComment = comment;
                    }
                }
            }
            hasmFile.Append("    0x" + address.ToHexString(4) + " 0x" + i.ToHexString(2) + " 0x" + 
                                       tableEntry.ToHexString(4) + "    " + comment + Char.EOL); 
            index++;
            address++;
            codeSize++;
        }
        index    += tableSizeInWords;
        address  += tableSizeInWords;
        codeSize += tableSizeInWords;
    }
    
    // Helper method to render jump table as raw data (for code generation)
    RenderJumpTableRaw(file outputFile, <byte> code, ref uint index, ref uint address, ref uint codeSize, uint tableSizeInWords)
    {
        uint bytesWritten = 0;
        
        // Dump LSBs first
        for (byte i = 0; i < tableSizeInWords; i++)
        {
            if (bytesWritten % 16 == 0)
            {
                if (bytesWritten > 0)
                {
                    outputFile.Append(Char.EOL);
                }
                outputFile.Append("0x" + address.ToHexString(4) + " ");
            }
            else if (bytesWritten % 8 == 0)
            {
                outputFile.Append(" ");
            }
            outputFile.Append(" 0x" + code[index].ToHexString(2));
            index++;
            address++;
            bytesWritten++;
        }
        
        codeSize += bytesWritten;
        outputFile.Append(Char.EOL);
        
        bytesWritten = 0;
            
        // Dump MSBs
        for (byte i = 0; i < tableSizeInWords; i++)
        {
            if (bytesWritten % 16 == 0)
            {
                if (bytesWritten > 0)
                {
                    outputFile.Append(Char.EOL);
                }
                outputFile.Append("0x" + address.ToHexString(4) + " ");
            }
            else if (bytesWritten % 8 == 0)
            {
                outputFile.Append(" ");
            }
            outputFile.Append(" 0x" + code[index].ToHexString(2));
            index++;
            address++;
            bytesWritten++;
        }
        
        if (bytesWritten % 16 != 0)
        {
            outputFile.Append(Char.EOL);
        }
        codeSize += bytesWritten;
    }
    
    BadArguments()
    {
        PrintLn("Invalid arguments for 65DASM:");
        PrintLn("  65DASM <hexe file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -p         : include profile hits");
        PrintLn("    -og        : traditional syntax to keep the OG's happy");
        PrintLn("    -c         : clean (no comments)");
    }
    
    {
        bool success = false;
        bool includeHits;
        bool noComments;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if (((arg.Length == 2) || (arg.Length == 3)) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        case "-p":
                        {
                            includeHits = true;
                        }
                        case "-c":
                        {
                            noComments = true;
                        }
                        case "-og":
                        {
                            ogMode = true;
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                BadArguments();
                break;
            }
            string ext = ".hex";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Bin/"))
            {
                BadArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string hasmPath  = codePath.Replace(extension, ".lst");
                hasmPath = Path.GetFileName(hasmPath);
                hasmPath = Path.Combine("/Debug/", hasmPath);
                File.Delete(hasmPath);

                file hasmFile = File.Create(hasmPath);
                if (!hasmFile.IsValid())
                {
                    PrintLn("Failed to create '" + hasmPath + "'");
                    break;
                }
                
                string symbolsPath  = codePath.Replace(extension, ".code");
                symbolsPath = Path.GetFileName(symbolsPath);
                symbolsPath = Path.Combine("/Debug/Obj", symbolsPath);
                string jsonPath  = symbolsPath.Replace(".code", ".sym");
                
                if (File.Exists(symbolsPath))
                {
                    if (!ParseCode(symbolsPath, false, true))
                    {
                        break;
                    }
                }
                Symbols.New();
                string description;
                uint romSize = 0x8000;
                bool isHopperBIOSApplet = false;
                if (Symbols.Import(jsonPath))
                {
                    if (DefineExists("CPU_6502"))
                    {
                        description = " for 6502";
                    }
                    if (DefineExists("CPU_65C02S"))
                    {
                        description = " for 65C02S";
                    }
                    if (DefineExists("CPU_65UINO"))
                    {
                        description = " for 65uino";
                        romSize = 0x1000;
                    }
                    if (DefineExists("ROM_48K"))
                    {
                        description += " (48K ROM)";
                        romSize = 0xC000;
                    }
                    if (DefineExists("ROM_32K"))
                    {
                        description += " (32K ROM)";
                        romSize = 0x8000;
                    }
                    if (DefineExists("ROM_16K"))
                    {
                        description += " (16K ROM)";
                        romSize = 0x4000;
                    }
                    if (DefineExists("ROM_8K"))
                    {
                        description += " (8K ROM)";
                        romSize = 0x2000;
                    }
                    if (DefineExists("ROM_4K"))
                    {
                        description += " (4K ROM)";
                        romSize = 0x1000;
                    }
                    if (DefineExists("ROM_1K"))
                    {
                        description += " (1K ROM)";
                        romSize = 0x0400;
                    }
                    if (DefineExists("HOPPER_BIOS_APPLET"))
                    {
                        isHopperBIOSApplet = true;
                    }
                }
                if (includeHits)
                {
                    if (File.Exists("/Temp/Profile.csv"))
                    {
                        file hitFile = File.Open("/Temp/Profile.csv");
                        loop
                        {
                            string ln = hitFile.ReadLine();
                            if (!hitFile.IsValid()) { break ; }
                            <string> parts = ln.Split(",");
                            uint address;
                            if (UInt.TryParse(parts[0], ref address))
                            {
                                long l;
                                _ = Long.TryParse(parts[1], ref l);
                                profileHits[address] = l;
                            }
                        }
                    }
                    else
                    {
                        includeHits = false;
                    }
                }
                
                uint org;
                uint codeSize = 0;
                uint address = 0;
                file hexFile = File.Open(codePath);
                <byte> code = readIHex(hexFile, ref org);
                
                uint resetVector;
                uint constantSize;
                if (!isHopperBIOSApplet)
                {
                    resetVector = code[code.Count-4] + (code[code.Count-3] << 8);
                    address = resetVector;
                    constantSize = resetVector - org;
                }
                else
                {
                    address = code[1] + code[2] << 8;
                    constantSize = address - 0x800;
                }
                
                uint index = constantSize;
                if (constantSize > 0)
                {
                    string ascii;
                    hasmFile.Append("// constant data" + Char.EOL);
                    uint i;
                    loop
                    {
                        if (i == constantSize) { break; }
                        byte b = code[i];
                        codeSize++;
                        if (i % 16 == 0)
                        {
                            hasmFile.Append(Char.EOL + "0x" + (i + org).ToHexString(4) + " ");
                        }
                        else if (i % 8 == 0)
                        {
                            hasmFile.Append(" ");
                        }
                        hasmFile.Append(" 0x" + b.ToHexString(2));   
                        if ((b > 32) && (b < 128))
                        {
                            ascii += char(b);
                        }
                        else
                        {
                            ascii += '.';
                        }
                        if (i % 16 == 15)
                        {
                            hasmFile.Append("  // " + ascii);
                            ascii = "";
                        }
                        i++;
                    }
                    if ((i % 16) <= 8)
                    {
                        hasmFile.Append(" ");
                    }
                    while (i % 16 != 0)
                    {
                        hasmFile.Append("     ");
                        i++;    
                    }
                    hasmFile.Append("  // " + ascii + Char.EOL);
                }
                              
                <uint, uint> methodSizes = Code.GetMethodSizes();
                <uint, uint> reserveds   = GetReservedDefines();
                
                uint indexMax = 0;
                foreach (var sz in methodSizes)
                {
                    if (sz.key > indexMax)
                    {
                        indexMax = sz.key;
                    }
                }
                <uint,uint> methodAddresses; // <address,index>
                uint methodAddress = address;
                for (uint mi = 0; mi <= indexMax; mi++)
                {
                    if (!methodSizes.Contains(mi)) { continue; }   
                    uint methodSize = methodSizes[mi];
                    
                    loop
                    {
                        uint methodEnd     = methodAddress + methodSize - 1;
                        bool updated;
                        foreach (var kv in reserveds)
                        {
                            uint reservedStart = kv.key;
                            if ((reservedStart >= methodAddress) && (reservedStart <= methodEnd))
                            {
                                // reserved section starts within this method
                                methodAddress = reservedStart + kv.value;
                                updated = true;
                            }
                        }
                        if (updated) { continue; }
                        break;
                    }
                    methodAddresses[methodAddress] = mi;
                    methodAddress += methodSize;
                }
                
                <string,string> debugInfo;
                <string,string> labelInfo;
                uint doffset = 0;
                string src;
                string srcName;
                
                OpCode jumpIndexinstruction = GetJMPIndexInstruction();
                      
                uint commentColumn = 48;  
                string commentPrefix = "// ";
                if (OGMode)
                {
                    commentPrefix = "; ";
                    commentColumn = 36;
                }
                uint vectorsSize = 6;
                if (isHopperBIOSApplet)
                {
                    vectorsSize = 0;
                }
                uint tableSizeInWords;
                loop
                {
                    if (index == code.Count-vectorsSize) { break; }
                    
                    OpCode instruction = OpCode(code[index]);
                    uint length      = Asm6502.GetInstructionLength(instruction);
                    
                    // Check if this is a valid instruction
                    AddressingModes mode = Asm6502.GetAddressingMode(instruction);
                    if (mode == AddressingModes.None)
                    {
                        string hexPrefix = "0x";
                        if (OGMode)
                        {
                            hexPrefix = "";
                        }
                        // Invalid opcode - mark it in the disassembly
                        string badOpDisassembly = hexPrefix + address.ToHexString(4);
                        badOpDisassembly += " ";
                        badOpDisassembly += " " + hexPrefix + (byte(instruction)).ToHexString(2);
                        badOpDisassembly += "           ";  // padding
                        badOpDisassembly += "  .BYTE " + hexPrefix + (byte(instruction)).ToHexString(2);
                        
                        string badOpComment = commentPrefix + "INVALID OPCODE!";
                        hasmFile.Append(badOpDisassembly.Pad(' ', commentColumn) + badOpComment + Char.EOL);
                        
                        index    += 1;  // skip just the bad byte
                        address  += 1;
                        codeSize += 1;
                        continue;  // skip normal processing
                    }
                    
                    instructionCount++;
                    
                    uint operand;
                    string operandString;
                    if (length == 2)
                    {
                        operand = code[index+1];
                    }
                    else if (length == 3)
                    {
                        operand = code[index+1] + code[index+2] << 8; 
                    }
                    if ((instruction == OpCode.CPX_n) || (instruction == OpCode.CPY_n))
                    {
                        tableSizeInWords = operand + 1;
                    }

                    if (methodAddresses.Contains(address))
                    {
                        uint methodIndex = methodAddresses[address];
                        
                        <string,variant> methodSymbols = Code.GetMethodSymbols(methodIndex);
                        if (methodSymbols.Count != 0)
                        {
                            src = methodSymbols["source"];
                            srcName = Path.GetFileName(src);
                            string ln = methodSymbols["line"];
                            string nm = methodSymbols["name"];
                            debugInfo = methodSymbols["debug"];
                            labelInfo.Clear();
                            if (methodSymbols.Contains("labels"))
                            {
                                labelInfo = methodSymbols["labels"];
                            }
                            doffset = address;
                            hasmFile.Append("" + Char.EOL); 
                            hasmFile.Append(commentPrefix + src + ":" + ln + Char.EOL);  
                            
                            string mname = commentPrefix + "####  " + nm + "()  ####";
                            mname = mname.Pad(' ', 80);
                            mname = mname + "0x" + methodIndex.ToHexString(4) + Char.EOL;
                            hasmFile.Append(mname);  
                            hasmFile.Append("" + Char.EOL); 
                            Parser.ProgressTick(".");
                        }
                    } // next method
                    
                    uint delta = (address-doffset);
                    string debugAddress = delta.ToString();
                    if (labelInfo.Contains(debugAddress))
                    {
                        string label = labelInfo[debugAddress];
                        if (!OGMode)
                        {
                            hasmFile.Append("        ");
                        }
                        hasmFile.Append("              " + label + ":" + Char.EOL);    
                    }
                    string comment;
                    
                    if (debugInfo.Contains(debugAddress))
                    {
                        string debugLine = debugInfo[debugAddress];
                        string sourceLine = getSourceLine(src, debugLine);
                        if (sourceLine.Length != 0)
                        {
                            comment = sourceLine.Trim();
                            if (comment.Length < 34)
                            {
                                comment = comment.Pad(' ', 34);
                                comment = comment + srcName + ":" + debugLine;
                            }
                        }
                        else
                        {
                            comment = src + ":" + debugLine;  
                        }
                    }
                    
                    string disassembly = Asm6502.Disassemble(address, instruction, operand);
                    if (includeHits)
                    {
                        string hits = "          ";
                        if (profileHits.Contains(address))
                        {
                            hits = ((profileHits[address]).ToString()).Pad(' ', 10);
                        }
                        disassembly = hits + disassembly;
                    }
                    if (noComments)
                    {
                        comment = "";
                    }
                    if (comment.Length != 0)
                    {
                        comment = comment.Replace("//", "  ");
                        comment = commentPrefix + comment;
                    }
                    if (comment.Length != 0)
                    {
                        hasmFile.Append(disassembly.Pad(' ', commentColumn) + comment + Char.EOL);
                    }
                    else
                    {
                        hasmFile.Append(disassembly + Char.EOL);
                    }                  
                    index    += length;
                    address  += length;
                    codeSize += length;
                    
                    if ((instruction == OpCode.JMP_inn) && (operand == 0x0020)) // ZP.JumpTable
                    {
                        RenderJumpTablePretty(hasmFile, code, ref index, ref address, ref codeSize, tableSizeInWords, methodAddresses, commentPrefix);
                        //RenderJumpTableRaw(hasmFile, code, ref index, ref address, ref codeSize, tableSizeInWords);
                    }
                }
                if (!isHopperBIOSApplet)
                {
                    hasmFile.Append("" +  Char.EOL);
                    uint vector = code[index] + code[index+1] << 8;
                    hasmFile.Append("0xFFFA 0x" + vector.ToHexString(4) + " // NMI vector" + Char.EOL);
                    vector = code[index+2] + code[index+3] << 8;
                    hasmFile.Append("0xFFFC 0x" + vector.ToHexString(4) + " // Reset vector" + Char.EOL);
                    vector = code[index+4] + code[index+5] << 8;
                    hasmFile.Append("0xFFFE 0x" + vector.ToHexString(4) + " // IRQ vector" + Char.EOL);
                    
                    codeSize += 6;
                }
                              
                Parser.ProgressTick(".");
                hasmFile.Flush();
                if (!Parser.IsInteractive())
                {
                    PrintLn();
                    Print("Success, " + codeSize.ToString() + " bytes of code", Colour.ProgressText, Colour.ProgressFace);
                    if (description.Contains("ROM"))
                    {
                        description = description.Replace("ROM)", "ROM");
                        Print(description, Colour.ProgressText, Colour.ProgressFace);
                        if (codeSize < romSize)
                        {
                            Print(" : ", Colour.ProgressText, Colour.ProgressFace);
                            Print((romSize - codeSize).ToString() + " bytes free", Colour.Ocean, Colour.ProgressFace);   
                        }
                        if (romSize < codeSize)
                        {
                            Print(" : ", Colour.ProgressText, Colour.ProgressFace);
                            Print((codeSize - romSize).ToString() + " bytes overrun", Colour.Red, Colour.ProgressFace);   
                        }
                        Print("),", Colour.ProgressText, Colour.ProgressFace);
                    }
                    else
                    {
                        Print(description + ",", Colour.ProgressText, Colour.ProgressFace);
                    }
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                    PrintLn("  " + instructionCount.ToString() + " instructions disassembled. ", Colour.ProgressText, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
