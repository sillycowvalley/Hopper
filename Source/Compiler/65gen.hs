program Generate
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define ASSEMBLER
    
    uses "/Source/System/System"
    uses "/Source/System/Screen"
    
    uses "JSON/JSON"
    uses "JSON/Code"
    
    uses "Tokens/Token"
    uses "Tokens/Scanner"
    uses "Tokens/Parser"
    
    uses "Symbols"
    
    uses "CODEGEN/Asm6502"
    
    uint romSize = 0;
    long codeSize = 0;
    
    <byte> output;
    <uint,uint> patches;         // <callLocation,methodIndex>
    <uint,uint> splitPatchesLSB; // <callLSBLocation,methodIndex>
    <uint,uint> splitPatchesMSB; // <callMSBLocation,methodIndex>
    <uint,uint> methods; // <methodIndex,address>
    
    <uint,uint> reserveds;
    
    bool NoPackedInstructions { get { return false; } }
    
    badArguments()
    {
        PrintLn("Invalid arguments for 65GEN:");
        PrintLn("  65GEN <code file>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -b export as .bin rather than .hex");
        PrintLn("    -c export as .c for RetroShields");
    }
    
    writeMethod(uint methodIndex, <byte> code, uint romAddress)
    {
        uint methodAddress;
        uint methodEnd;
        loop
        {
            methodAddress = output.Count + romAddress;
            methodEnd     = methodAddress + code.Count - 1;
            bool updated;
            foreach (var kv in reserveds)
            {
                uint reservedStart = kv.key;
                if ((reservedStart >= methodAddress) && (reservedStart <= methodEnd))
                {
                    // reserved section starts within this method
                    uint reservedEnd   = kv.key + kv.value;
                    while (output.Count + romAddress < reservedEnd)
                    {
                        output.Append(0xEA);
                    }
                    updated = true;
                }
            }
            if (updated) { continue; }
            break;
        }
        
        methods[methodIndex] = methodAddress;
        
        OpCode callInstruction      = GetJSRInstruction();
        OpCode jumpInstruction      = GetJMPInstruction();
        OpCode ijmpInstruction      = GetiJMPInstruction();
        OpCode jumpIndexinstruction = GetJMPIndexInstruction();
        
        byte tableEntries;
        uint tableLoadLSB;
        uint tableLoadMSB;
        
        uint index = 0;
        loop
        {
            
            if (index == code.Count) { break; }
            
            OpCode instruction = OpCode(code[index]);
            
            uint instructionLength = Asm6502.GetInstructionLength(instruction);
            
            if ((instruction == OpCode.LDA_nnY) || (instruction == OpCode.LDA_nnX))
            {
                tableLoadLSB = tableLoadMSB;
                tableLoadMSB = output.Count;
            }
            else if ((instruction == OpCode.CPY_n) || (instruction == OpCode.CPX_n))
            {
                tableEntries = code[index+1]+1;
            }
            if (instruction == callInstruction)
            {
                uint address = code[index+1] + code[index+2] << 8;
                patches[output.Count+1] = address;
            }
            else if (instruction == ijmpInstruction)
            {
                uint address = code[index+1] + code[index+2] << 8;
                patches[output.Count+1] = address;
                code[index] = byte(jumpInstruction);
            }
            else if (instruction == jumpInstruction)
            {
                uint address = code[index+1] + (code[index+2] << 8);
                address += methodAddress;
                code[index+1] = address.GetByte(0);
                code[index+2] = address.GetByte(1);
            }
            else if (instruction == jumpIndexinstruction)
            {
                code[index] = byte(OpCode.JMP_inn);
                // fix the last two LDA nnnn,Y instructions
                uint address = index + methodAddress + 3;
                output[tableLoadLSB+1] = address.GetByte(0);
                output[tableLoadLSB+2] = address.GetByte(1);
                address += tableEntries;
                output[tableLoadMSB+1] = address.GetByte(0);
                output[tableLoadMSB+2] = address.GetByte(1);
            }
            
            for (uint i=0; i < instructionLength; i++)
            {
                output.Append(code[index+i]);
            }
            index += instructionLength;
            
            if (instruction == jumpIndexinstruction)
            {
                uint tableSizeInWords = tableEntries;  
                
                // LSBs
                for (uint i = 0; i < tableSizeInWords; i++)
                {
                    uint mIndex = code[index] + (code[index+tableSizeInWords] << 8);
                    splitPatchesLSB[output.Count] = mIndex;
                    splitPatchesMSB[output.Count+tableSizeInWords] = mIndex;
                    output.Append(code[index]);
                    index++;
                }
                // MSBs
                for (uint i = 0; i < tableSizeInWords; i++)
                {
                    output.Append(code[index]);
                    index++;
                }
            }
        }
    }
    doCallPatches()
    {
        // <uint,uint> patches; // <callLocation,methodIndex>
        // <uint,uint> methods; // <methodIndex,address>
        foreach (var kv in patches)
        {
            uint patchAddress  = kv.key;
            uint targetMethod  = kv.value;
            uint targetAddress = methods[targetMethod];
            output.SetItem(patchAddress,   byte(targetAddress & 0xFF));
            output.SetItem(patchAddress+1, byte(targetAddress >> 8));
        }
        foreach (var kv in splitPatchesLSB)
        {
            uint patchAddress  = kv.key;
            uint targetMethod  = kv.value;
            uint targetAddress = methods[targetMethod];
            output.SetItem(patchAddress,   byte(targetAddress & 0xFF));
        }
        foreach (var kv in splitPatchesMSB)
        {
            uint patchAddress  = kv.key;
            uint targetMethod  = kv.value;
            uint targetAddress = methods[targetMethod];
            output.SetItem(patchAddress,   byte(targetAddress >> 8));
        }
        
    }
    
    byte hexCheckSum(string values)
    {
        uint sum = 0;
        for (uint i = 0; i < values.Length / 2; i++)
        {
            string substr = values.Substring(i * 2, 2);
            uint b = 0;
            if (UInt.TryParse("0x" + substr, ref b))
            {
            }
            sum = sum + b;
        }
        sum = sum % 256;
        byte chk = byte(sum);
        chk = ~chk;
        chk++;
        return chk;
    }
    
    emitBuffer(file ihexFile, uint address, string buffer)
    {
        uint bytes = buffer.Length / 2;
        string ln = bytes.ToHexString(2) + address.ToHexString(4) + "00" + buffer;
        byte chk = hexCheckSum(ln);
        ihexFile.Append(":" + ln + chk.ToHexString(2) + Char.EOL);
    }
    
    writeIHex(file ihexFile, uint romAddress, <byte> output, <byte> vectors)
    {
        // https://en.wikipedia.org/wikie/Intel_HEX#Format
        
        uint byteCount = 0;
        uint index = 0;
        
        byte currentTick = 0;
        Parser.ProgressTick("i"); // writeIHex
        
        string buffer;
        uint emitAddress = 0;
        loop
        {
            if (index == output.Count)
            {
                // done
                break;
            }
            byte cb = output[index]; index++;
            
            buffer = buffer + cb.ToHexString(2);
            if (buffer.Length == 32)
            {
                emitBuffer(ihexFile, emitAddress + romAddress, buffer);
                emitAddress = emitAddress + 16;
                buffer = "";
            }
            
            if (byteCount % 8192 == 0)
            {
                Parser.ProgressTick("i"); // writeIHex
            }
            byteCount++;
            
        }
        if (buffer.Length != 0)
        {
            emitBuffer(ihexFile, emitAddress + romAddress, buffer);
            buffer = "";
        }
        
        // 6502 Vectors:
        foreach (var vb in vectors)
        {
            buffer = buffer + vb.ToHexString(2);
        }
        emitBuffer(ihexFile, 0xFFFA /*- romAddress*/, buffer);
        
        
        ihexFile.Append(":00000001FF" + Char.EOL); // eof
        ihexFile.Flush();
    }
    
    writeSrc(file srcFile, uint romAddress, <byte> output, <byte> vectors)
    {
        srcFile.Append("#define ROM_START   0x" + romAddress.ToHexString(4) + Char.EOL);
        srcFile.Append("#define ROM_END     0xFFFF" + Char.EOL);
        if (Architecture == CPUArchitecture.W65C02)
        {
            srcFile.Append("#define CPU_65C02S" + Char.EOL);
        }
        srcFile.Append("" + Char.EOL);
        
        srcFile.Append("PROGMEM const unsigned char rom_bin[] = {");
        uint address = romAddress;
        uint length  = output.Count;
        uint index   = 0;
        loop
        {
            byte b = 0;
            if (address >= 0xFFFA)
            {
                index = address - 0xFFFA;
                b = vectors[index];
            }
            else if (index < length)
            {
                b = output[index];
            }
            string prefix;
            if (index % 16 == 0)
            {
                prefix = Char.EOL + "    ";
            }
            if (index % 16 == 8)
            {
                prefix = "  ";
            }
            srcFile.Append(prefix + "0x" + b.ToHexString(2) + ", ");    
            if (address == 0xFFFF) { break; } 
            address++;
            index++;
        }
        
        srcFile.Append("};" + Char.EOL);
        srcFile.Flush();
    }
    
    writeBin(file binFile, uint romAddress, <byte> output, <byte> vectors)
    {
        uint address = romAddress;
        uint length  = output.Count;
        uint index   = 0;
        loop
        {
            byte b = 0xEA;
            if (address >= 0xFFFA)
            {
                index = address - 0xFFFA;
                b = vectors[index];
            }
            else if (index < length)
            {
                b = output[index];
            }
            binFile.Append(b);    
            if (address == 0xFFFF) { break; } 
            address++;
            index++;
        }
        binFile.Flush();
    }
    
    {
        bool exportBin;
        bool exportC;
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length >= 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        case "-b":
                        {
                            exportBin = true;
                        }
                        case "-c":
                        {
                            exportC = true;
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            string ext = ".code";
            string codePath = args[0];
            if (!File.Exists(ref codePath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                string extension = Path.GetExtension(codePath);
                string ihexPath  = codePath.Replace(extension, ".hex");
                string jsonPath  = codePath.Replace(extension, ".sym");
                
                ihexPath = Path.GetFileName(ihexPath);
                ihexPath = Path.Combine("/Bin/", ihexPath);
                File.Delete(ihexPath);
                
                Symbols.New();
                if (!Symbols.Import(jsonPath))
                {
                    break;
                }
                
                romSize = 0x8000;
                
                if (DefineExists("CPU_6502"))
                {
                    Architecture = CPUArchitecture.M6502;
                }
                if (DefineExists("CPU_65C02S"))
                {
                    Architecture = CPUArchitecture.W65C02;
                }
                if (DefineExists("CPU_65UINO"))
                {
                    Architecture = CPUArchitecture.M6502;
                    romSize = 0x1000;
                }
                if (DefineExists("ROM_48K"))
                {
                    romSize = 0xC000;
                }
                if (DefineExists("ROM_32K"))
                {
                    romSize = 0x8000;
                }
                if (DefineExists("ROM_16K"))
                {
                    romSize = 0x4000;
                }
                if (DefineExists("ROM_8K"))
                {
                    romSize = 0x2000;
                }
                if (DefineExists("ROM_4K"))
                {
                    romSize = 0x1000;
                }
                if (DefineExists("ROM_1K"))
                {
                    romSize = 0x0400;
                }
                if (DefineExists("EXPORT_BIN"))
                {
                    exportBin = true;
                }
                if (DefineExists("EXPORT_C"))
                {
                    exportC = true;
                }
                
                long startAddress = 0x10000 - romSize; 
                uint romAddress = uint(startAddress);
                
                file ihexFile = File.Create(ihexPath);
                if (!ihexFile.IsValid())
                {
                    PrintLn("Failed to create '" + ihexPath + "'");
                    break;
                }
                
                if (!ParseCode(codePath, true, false))
                {
                    break;
                }
                
                uint methodCount = Code.GetMethodCount();
                
                <byte> constantData = Code.GetConstantData();
                foreach (var b in constantData)
                {
                    output.Append(b);
                }
                
                uint entryIndex = Code.GetEntryIndex();
                
                <uint, uint> methodSizes = Code.GetMethodSizes();
                
                Parser.ProgressTick(".");
                //byte arch = byte(Architecture);
                //output.Append(0);    // version
                //output.Append(arch); // CPU
                
                reserveds = GetReservedDefines();
                
                <byte> methodCode = Code.GetMethodCode(entryIndex);
                writeMethod(entryIndex, methodCode, romAddress);
                Parser.ProgressTick(".");
                uint indexMax = 0;
                foreach (var sz in methodSizes)
                {
                    if (sz.key > indexMax)
                    {
                        indexMax = sz.key;
                    }
                }
                // if we emit the methods in increasing order of indices
                // then we can find them again in the binary (for debug info)
                for (uint index = 0; index <= indexMax; index++)
                {
                    if (index == entryIndex)          { continue; }
                    if (!methodSizes.Contains(index)) { continue; }   
                    methodCode = Code.GetMethodCode(index);
                    writeMethod(index, methodCode, romAddress);   
                    Parser.ProgressTick(".");
                }
                doCallPatches();
                Parser.ProgressTick(".");
                
                uint iIndex;
                uint nIndex;
                uint nmiVector = 0;
                uint irqVector = 0;
                if (Symbols.GetFunctionIndex("IRQ", ref iIndex))
                {
                    <uint> mOverloads = Symbols.GetFunctionOverloads(iIndex);
                    iIndex = mOverloads[0];
                    irqVector = methods[iIndex];
                }
                if (Symbols.GetFunctionIndex("NMI", ref nIndex))
                {
                    <uint> mOverloads = Symbols.GetFunctionOverloads(nIndex);
                    nIndex = mOverloads[0];
                    nmiVector = methods[nIndex];
                }
                                
                // 6502 vectors
                <byte>vectors;
                vectors.Append(byte(nmiVector & 0xFF));
                vectors.Append(byte(nmiVector >> 8));
                vectors.Append(byte(methods[entryIndex] & 0xFF));
                vectors.Append(byte(methods[entryIndex] >> 8));
                vectors.Append(byte(irqVector & 0xFF));
                vectors.Append(byte(irqVector >> 8));
                
                writeIHex(ihexFile, romAddress, output, vectors);
                
                // Export for RetroShield:
                if (exportC)
                {
                    string srcPath = ihexPath.Replace(".hex", ".c");
                    file srcFile = File.Create(srcPath);
                    if (!srcFile.IsValid())
                    {
                        PrintLn("Failed to create '" + srcPath + "'");
                        break;
                    }
                    writeSrc(srcFile, romAddress, output, vectors);
                }
                
                // export .bin file for Dave:
                if (exportBin)
                {
                    string binPath = ihexPath.Replace(".hex", ".bin");
                    file binFile = File.Create(binPath);
                    if (!binFile.IsValid())
                    {
                        PrintLn("Failed to create '" + binPath + "'");
                        break;
                    }
                    writeBin(binFile, romAddress, output, vectors);
                }
                
                if (!Parser.IsInteractive())
                {
                    codeSize = output.Count;
                    
                    PrintLn();
                    Print("Success, " + codeSize.ToString() + " bytes of code, ", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() +"s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            }
            break;
        }
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
