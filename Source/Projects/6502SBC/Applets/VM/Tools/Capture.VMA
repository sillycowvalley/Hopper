; CAPTURE.VMA - Minimal echo program until Ctrl+Z
.CONST
    ; Zero page marshalling registers
    ZP.ACC       0x10
    ZP.TOP       0x12
    ZP.NEXT      0x16
    ZP.STR       0x1E
    
    ; BIOS syscalls
    Arg.Count           0x36
    Arg.Get             0x37
    Serial.WaitForChar  0x0E
    Print.String        0x11
    Print.Char          0x12
    Print.Hex           0x13
    Print.NewLine       0x14
    FOpen              0x30
    FClose             0x31
    FPutC              0x34
    
    ; Control characters
    CtrlZ        0x1A
    
    ; Global variables
    GP.FileHandle  0x00   ; 1 Byte file handle
    GP.Count       0x01   ; Word (16-bit counter)

.DATA
msg_usage "Usage: CAPTURE <filename>\n"

msg_prompt "Paste text, Ctrl+Z to save, Ctrl+C to abort\n"

msg_capturing "Capturing:     "

msg_cannot "Cannot create file\n"

str_mode "w"

.FUNC DisplayCount
    ENTER 0
    
    ; Print 4 backspaces to erase previous count
    PUSHB 0x08          ; Backspace character
    POPA
    SYSCALL Print.Char
    SYSCALL Print.Char
    SYSCALL Print.Char
    SYSCALL Print.Char
    
    ; Print count as 4 hex digits
    PUSHGW GP.Count
    ; Print high byte
    POPA
    SYSCALL Print.Hex
    
    ; Print low byte
    POPA
    SYSCALL Print.Hex
    
    LEAVE
    RET

.MAIN
    ; Check argument count
    SYSCALL Arg.Count
    ; A contains count (0=VM, 1=program, 2=filename)
    PUSHA
    PUSHB 3             ; Need at least 3 arguments
    LTB                 ; Pops both, pushes 1 if A < 3, else 0
    BZF get_filename    ; Skip usage message
    
show_usage:
    ; No filename - print usage and exit
    PUSHD msg_usage
    POPZW ZP.STR
    SYSCALLX Print.String
    HALT
    
get_filename:
    ; Get filename argument (index 2)
    PUSHB 2
    POPA
    SYSCALL Arg.Get
    ; ZP.STR now points to filename
    
    ; Open file for writing
    PUSHD str_mode
    POPZW ZP.NEXT
    SYSCALLX FOpen
    ; ZP.TOP now contains file handle (or NULL if failed)
    
    ; Save file handle to global variable
    PUSHZB ZP.TOP       ; 0x01 if good, 0x00 if not
    DUPB
    POPGB  GP.FileHandle
    
    ; Check if file opened successfully
    BZF file_error      ; Branch if 0 (handle was NULL)
    
    ; Display prompt
    PUSHD msg_prompt
    POPZW ZP.STR
    SYSCALLX Print.String
    
    PUSHD msg_capturing
    POPZW ZP.STR
    SYSCALLX Print.String
    
    ; Initialize counter to 0
    PUSHW0
    POPGW GP.Count
    
    ; Display initial count
    CALL DisplayCount
    
    ; Main echo loop
echo_loop:
    ; Get character from keyboard
    SYSCALL Serial.WaitForChar
    ; Character now in A register
    
    ; Check if Ctrl+Z
    PUSHA                ; Push A to stack
    PUSHB CtrlZ          ; Push Ctrl+Z constant
    EQB                  ; Compare bytes, pushes 1 if equal, 0 if not
    BNZF close_file      ; Branch if equal (result is 1)
    
    ; Write character to file
    PUSHA                ; Push character again (still in A)
    POPZB ZP.ACC         ; Move character to ZP.ACC for FPutC
    PUSHGB GP.FileHandle ; Get file handle from global
    POPZB ZP.NEXT        ; Move to ZP.NEXT for FPutC
    SYSCALLX FPutC
    
    ; Increment counter
    PUSHGW GP.Count
    PUSHW1
    ADDW
    DUPW                ; Duplicate new count
    POPGW GP.Count      ; Save to global
    
    ; Check if low 4 bits are zero (count % 16 == 0)
    DROPB               ; Drop high byte
    PUSHB 0x0F
    ANDB                ; Mask low 4 bits
    BNZF skip_display   ; Branch if not zero (not the 16th character)
    
    CALL DisplayCount
skip_display:
    BRAR echo_loop

close_file:
    ; Display final count
    CALL DisplayCount
    
    ; Print newline
    SYSCALLX Print.NewLine
    
    ; Close the file
    PUSHGB GP.FileHandle
    POPZB ZP.NEXT
    SYSCALLX FClose
    HALT

file_error:
    ; Print error message
    PUSHD msg_cannot
    POPZW ZP.STR
    SYSCALLX Print.String
    HALT