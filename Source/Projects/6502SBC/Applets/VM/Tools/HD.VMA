.CONST
    ZP.ACC       0x10
    ZP.TOP       0x12
    ZP.NEXT      0x16
    ZP.STR       0x1E
    
    ZP.IDX       0x1A
    
    ZP.BUF       0x80
    
    Mem.Allocate  0x00
    Mem.Free      0x01
    
    Print.String  0x11
    Print.Char    0x12
    Print.Hex     0x13
    Print.NewLine 0x14
    
    FOpen         0x30
    FClose        0x31
    FGetC         0x32 
    Arg.Get       0x37
    
    fileHandle     0
    byteCount     -1
    hexAddress    -2
    
    counter        0
    counter2      -1

.DATA
    STR0 "r"
    
.FUNC PrintAddress
    ENTER 0
    
    ; Address is at BP+5 (high), BP+6 (low)
    PUSHLB 5             ; High byte
    POPA
    SYSCALL Print.Hex
    
    PUSHLB 6             ; Low byte
    POPA
    SYSCALL Print.Hex
    
    PUSHB ':'
    POPA
    SYSCALL Print.Char
    
    PUSHB ' '
    POPA
    SYSCALL Print.Char
    
    LEAVE
    RET
    
.FUNC PrintASCII
    ENTER 2
    
    PUSHB ' '
    POPA
    SYSCALL Print.Char
    
    ; 16 - bytecount = number of slots to pad with spaces
    PUSHB 16
    PUSHLB 5
    SUBB
    
    ; 3x
    DUPB
    DUPB
    ADDB
    ADDB
    POPLB counter

more_spaces:
    PUSHLB counter
    BZF spaces_done
    
    PUSHB ' '
    POPA
    SYSCALL Print.Char
    
    PUSHLB counter
    PUSHB1
    SUBB
    POPLB counter
    
    BRAR more_spaces
    
spaces_done:

    ; reuse the counter
    PUSHLB 5
    POPLB counter
    
    PUSHB0
    POPLB counter2
    
more_ascii:
    PUSHLB counter
    BZF ascii_done
    
    PUSHB '.'
    POPA
    SYSCALL Print.Char
    
    INCLB counter2
    PUSHLB counter2
    PUSHB 8
    EQB
    BZF no_extra
    
    PUSHB ' '
    POPA
    SYSCALL Print.Char
    
no_extra:
    PUSHLB counter
    PUSHB1
    SUBB
    POPLB counter
    
    BRAR more_ascii
    
ascii_done:
    ; Clean up 2 bytes
    DROPW
    LEAVE
    RET

.FUNC ProcessFile
    ENTER 4              ; Locals: fileHandle(1), byteCount(1), hexAddress(2)
    
    ; Save file handle
    PUSHZB ZP.TOP
    POPLB fileHandle
    
    ; Initialize byte count to 0
    PUSHB0
    POPLB byteCount
    
    ; Initialize address to 0
    PUSHW0
    POPLW hexAddress
    
main_loop: 
    ; Check if we need to print address (byte_count == 0)
    PUSHLB byteCount
    PUSHB0
    EQB
    BZF read_byte
    
    ; Print current address
    PUSHLW hexAddress
    CALL PrintAddress
    DROPW ; Clean the argument
    
read_byte:
    ; Set up file handle for FGetC
    PUSHLB fileHandle
    POPZB ZP.NEXT
    SYSCALL FGetC
    
    ; Check for EOF (-1)
    PUSHZW ZP.TOP
    PUSHW 0xFFFF         ; -1 as unsigned 16-bit
    EQW
    BNZF end_loop        ; If EOF, exit
    
    ; Print the byte as hex
    PUSHZB ZP.TOP        ; Get the byte we just read
    POPA
    SYSCALL Print.Hex
    
    PUSHB ' '
    POPA
    SYSCALL Print.Char
    
    ; Increment byte count
    INCLB byteCount
    
    ; Check if we've read 8 bytes
    PUSHLB byteCount
    PUSHB 8
    EQB
    BZF skip_space
    
    PUSHB ' '
    POPA
    SYSCALL Print.Char
skip_space:

    ; Check if we've read 16 bytes
    PUSHLB byteCount
    PUSHB 16
    EQB
    BZR main_loop        ; If not 16 yet, continue reading
    
    PUSHLB byteCount
    CALL PrintASCII
    DROPB ; Clean the argument
    
    ; Reset byte count and advance address
    PUSHB0
    POPLB byteCount
    
    PUSHLW hexAddress
    PUSHW 16
    ADDW
    POPLW hexAddress
    
    SYSCALL Print.NewLine
    
    BRAR main_loop       ; Go back to check if we need to print address

end_loop:

    PUSHLW hexAddress
    PUSHLB byteCount
    CALL PrintASCII
    DROPW DROPB ; Clean the argument

    ; Clean up 4 bytes
    DROPW DROPW
    LEAVE
    RET

.MAIN
    ; Get filename argument
    PUSHB 2
    POPA
    SYSCALL Arg.Get
    
    ; Set up file mode ("r")
    PUSHD STR0
    POPZW ZP.NEXT
    
    ; Open file
    SYSCALL FOpen
    
    ; Check if file opened successfully
    PUSHZW ZP.TOP
    PUSHW0
    NEW
    BZF file_error
    
    PUSHZW ZP.TOP ; save the file handle
    
    PUSHW 16
    POPZW ZP.ACC
    SYSCALL Mem.Allocate
    PUSHZW ZP.IDX
    POPZW  ZP.BUF
    
    CALL ProcessFile
    
    PUSHZW ZP.BUF
    POPZW  ZP.IDX
    
    SYSCALL Mem.Free
    
    POPZW ZP.NEXT ; restore the file handle
    SYSCALL FClose

file_error:
    HALT
