program Assemble
{
    #define JSON_EXPRESS // .code and .json are generated by us so assume .json files have no errors
    #define SHORT_CALLS  // use CALLB to save space
    #define ASSEMBLER
    
    uses "/Source/System/System"
    uses "/Source/System/Diagnostics"
    uses "/Source/System/Screen"
    uses "/Source/System/Keyboard"
    
    uses "/Source/Compiler/Tokens/Token"
    uses "/Source/Compiler/Tokens/Scanner"
    uses "/Source/Compiler/Tokens/Parser"
    
    uses "/Source/Compiler/Symbols"
    uses "/Source/Compiler/Types"
    uses "/Source/Compiler/Constant"
    
    uses "/Source/Compiler/Directives"
    
    uses "/Source/Compiler/CodeGen/Block"
    uses "Asm6809"
    
    <string,uint> labelLocations;
    <uint,string> labelBranches;
    
    bool IsDebugger           { get { return false; } }
    bool NoPackedInstructions { get { return false; } }
    
    bool isExperimental;
    bool IsExperimental { get { return isExperimental; } }
    
    uint iCurrentOverload;
    uint iHopper;
    uint iNMI;
    uint iIRQ;
    
    badArguments()
    {
        PrintLn("Invalid arguments for 6809ASM:");
        PrintLn("  6809ASM <object json>");
        PrintLn("    -g <c> <r> : called from GUI, not console");
        PrintLn("    -x         : use experimental features");
    }
    
    <byte> initializeGlobals()
    {
        <string,variant> top = Block.Top();
        < <string> > globals = top["globals"];
        
        
        // globals
        //   <string> gNames;
        //   <string,uint> gIndex;
        //   <uint, string> gTypes;
        // code location of initialization code:
        //   <uint, long> gStartPos;
        //   <uint, uint> gStartLine;
        //   <uint, string> gSourcePath;
        
        Asm6502.New();
        
        uint gCount = Symbols.GetGlobalCount();
        for (uint gIndex = 0; gIndex < gCount; gIndex++)
        {
            <string> global;                     
            string variableType = Symbols.GetGlobalType(gIndex);
            string identifier   = Symbols.GetGlobalName(gIndex);
            global.Append(variableType);
            global.Append(identifier);
            globals.Append(global);
            
        }
        top["globals"] = globals;
        Block.ReplaceTop(top);
        
        <byte> code = Asm6502.CurrentStream;
        return code;
        
    }
    
    bool assembleConstantExpression(ref uint immediateValue)
    {
        bool hasImmediate;
        string actualType;
        string value;
        loop
        {
            <string,string> currentToken = Parser.CurrentToken;
            HopperToken tokenType = Token.GetType(currentToken);
            if (tokenType == HopperToken.LParen)
            {
                Parser.Advance(); // (
                currentToken = Parser.CurrentToken;
                value = ParseConstantExpression("uint", ref actualType, true);
                if (Parser.HadError)
                {
                    break;
                }
                <string,string> previousToken = Parser.PreviousToken;
                if (previousToken["pos"] == currentToken["pos"])
                {
                    Parser.Error("simple (nn) considered dangerous, did you mean [..]?");
                }
                Parser.Consume(HopperToken.RParen);
            }
            else
            {
                value = ParseConstantExpression("uint", ref actualType, true);
                if (Parser.HadError)
                {
                    break;
                }
            }
            if ((actualType == "uint") || (actualType == "byte"))
            {
                hasImmediate = UInt.TryParse(value, ref immediateValue);
            }
            break;
        } // loop
        return hasImmediate;
    }
    
    bool assembleBlockScope()
    {
        bool success = false;
        loop
        {
            Block.PushBlock(false); // for block locals
            assembleBlock();
            Block.PopBlock();
            Asm6502.InsertDebugInfo(true);
            success = !Parser.HadError;
            break;
        }
        return success;
    }
    
    bool assembleSwitchStatement()
    {
        bool success = false;
        loop
        {
            OpCode opcodeJSR = GetJSRInstruction();
            OpCode opcodeJMP = GetJMPInstruction();
            bool tableCandidate;
            
            <byte,uint> jumpRecords; // <caseLabel,methodIndex>
            uint defaultIndex;
            
            <uint> caseLabels;
            <uint> jumpEnds;
            
            uint jumpToTable = Asm6502.NextAddress;
            uint fakeJump = jumpToTable + 3;
            Asm6502.AppendCode(byte(opcodeJMP));
            Asm6502.AppendCode(byte(fakeJump & 0xFF));
            Asm6502.AppendCode(byte(fakeJump >> 8));
            
            Parser.Advance(); // switch
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            <string,string> currentToken = Parser.CurrentToken;
            HopperToken tokenType = Token.GetType(currentToken);
            if (tokenType != HopperToken.Register)
            {
                Parser.Error("register expected");
                break;
            }  
            char registerName = (currentToken["lexeme"]).GetChar(0);
            Parser.Advance();
            
            tableCandidate = ((registerName == 'X') || (registerName == 'Y')); // JMP nnnn
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            Parser.Consume(HopperToken.LBrace);
            if (Parser.HadError)
            {
                break;
            }
            bool defaultSeen = false;
            loop
            {
                if (Parser.Check(HopperToken.RBrace))
                {
                    success = true;
                    Parser.Advance(); // }
                    break;
                }
                if (Parser.Check(HopperToken.EOF))
                {
                    Parser.ErrorAtCurrent("unexpected EOF in 'switch'");
                    break;
                }
                <byte> currentCaseLabels;
                bool   isDefault = false;
                
                if (!Parser.CheckKeyword("case"))
                {
                    if (Parser.CheckKeyword("default"))
                    {
                        isDefault = true;       
                        if (defaultSeen)
                        {
                            Parser.ErrorAtCurrent("'default' can only occur once");
                            break;    
                        }
                        defaultSeen = true;
                    }
                    else
                    {
                        Parser.ErrorAtCurrent("'case' expected");
                        break;
                    }
                }
                if (defaultSeen && !isDefault)
                {
                    Parser.ErrorAtCurrent("'default' must be last case");
                    break;    
                }      
                <uint> jumpNexts;
                <uint> jumpMatches;
                
                loop
                {
                    Asm6502.InsertDebugInfo(false);
                    
                    Parser.Advance(); // "case" or "default"
// next:         
                    if (!isDefault)
                    {   
                        string actualType;
                        string caseConstant = ParseConstantExpression("byte", ref actualType, true);
                        if (Parser.HadError)
                        {
                            break;
                        }
                        
                        uint cc;
                        if (UInt.TryParse(caseConstant, ref cc))
                        {
                            if (cc > 255)
                            {
                                IE();
                            }
                            Asm6502.AddInstructionCMP(registerName, byte(cc));
                        }
                        else
                        {
                            Parser.Error("unexpected 'case' constant '" + caseConstant + "'");   
                            break;             
                        }
                        if (caseLabels.Contains(cc))
                        {
                            Parser.Error("duplicate 'case' constant '" + caseConstant + "'");
                            break;
                        }
                        caseLabels.Append(cc);
                        currentCaseLabels.Append(byte(cc));
                    
                    } // !isDefault
                    
                    Parser.Consume(HopperToken.Colon);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    
                    if (!isDefault)
                    {
                        // compare with case constant
                        Asm6502.AppendCode(GetBInstruction("Z"));
                        Asm6502.AppendCode(+3);
            
                        uint jumpNext = Asm6502.NextAddress;
                        jumpNexts.Append(jumpNext);
                        Asm6502.AddInstructionJ();
                        
                        if (Parser.CheckKeyword("case"))
                        {
                            uint jumpMatch = Asm6502.NextAddress;
                            Asm6502.AddInstructionJ();
                            jumpMatches.Append(jumpMatch);
                            
                            uint nextAddress = Asm6502.NextAddress;
                            Asm6502.PatchJump(jumpNexts[0], nextAddress);  
                            jumpNexts.Clear();
                            
                            continue; // multiple cases
                        }
                    }
                    break;
                } // loop: multiple "case"
                
                if (Parser.HadError)
                {
                    break;
                }
// match:       
                foreach (var jumpMatch in jumpMatches)
                {        
                    uint nextAddress = Asm6502.NextAddress;
                    Asm6502.PatchJump(jumpMatch, nextAddress);   
                }
                 
                uint beforeBlock = Asm6502.NextAddress;
                    
                Block.PushBlock(false); // not loop context
                assembleBlock();
                Block.PopBlock();
                
                uint afterBlock = Asm6502.NextAddress;
                uint blockSize  = afterBlock - beforeBlock;
                
                if (tableCandidate)
                {
                    if (blockSize != 3)
                    {
                        tableCandidate = false;
                    }
                    else
                    {
                        OpCode opCode  = OpCode(Asm6502.GetCodeByte(afterBlock - blockSize));
                        uint methodIndex = Asm6502.GetCodeByte(afterBlock - blockSize+1) + (Asm6502.GetCodeByte(afterBlock - blockSize+2) << 8);
                        if (opCode == opcodeJSR)
                        {
                            if (isDefault)
                            {
                                defaultIndex = methodIndex;
                            }
                            else
                            {
                                foreach (var caseLabel in currentCaseLabels)
                                {
                                    jumpRecords[caseLabel] = methodIndex;
                                }
                            }
                        }
                        else
                        {
                            tableCandidate = false;
                        }
                    }
                }
                
                Asm6502.InsertDebugInfo(true); 
                
                uint jumpEnd = Asm6502.NextAddress;
                Asm6502.AddInstructionJ();
                jumpEnds.Append(jumpEnd);
// next:        
                // next case will be after the block if there was one
                foreach (var jumpNext in jumpNexts)
                {        
                    uint nextAddress = Asm6502.NextAddress;
                    Asm6502.PatchJump(jumpNext, nextAddress);   
                }
            } // loop
// end:         
            uint endAddress = Asm6502.NextAddress;
            foreach (var jumpEnd in jumpEnds)
            {
                uint ui = jumpEnd;
                Asm6502.PatchJump(ui, endAddress);
            }
            if (tableCandidate && (defaultIndex == 0))
            {
                tableCandidate = false;
            }
            if (tableCandidate && (jumpRecords.Count <= 8))
            {
                tableCandidate = false;
            }
            
            if (tableCandidate)
            {
                tableCandidate = false;
                currentToken   = Parser.CurrentToken;
                tokenType      = Token.GetType(currentToken);
                if (tokenType == HopperToken.Keyword)
                {
                    tableCandidate = (currentToken["lexeme"] == "return");
                }
                else if (tokenType == HopperToken.RBrace)
                {
                    tableCandidate = (Block.BlockDepth() == 2); // program | unit + current method
                }
            }
            if (tableCandidate)
            {   
                <uint> jumpList;
                uint i = 0;
                uint iLastNonDefault = 0;
                for (; i < 256; i++)
                {
                    if (!jumpRecords.Contains(byte(i)))
                    {
                        jumpList.Append(defaultIndex);
                    }
                    else
                    {
                        uint jumpIndex = jumpRecords[i];
                        jumpList.Append(jumpIndex);
                        if (jumpIndex != defaultIndex)
                        {
                            iLastNonDefault = i;
                        }
                    }
                }
                
                uint tableAddress = Asm6502.NextAddress;
                Asm6502.PatchJump(jumpToTable, tableAddress);
                
                if (iLastNonDefault < 0xFF)
                {
                    iLastNonDefault++;
                    EmitInstruction((registerName == 'X') ? "CPX" : "CPY", byte(iLastNonDefault));    
                    EmitInstruction("BCC", int(+3));
                }
                else
                {
                    EmitInstruction((registerName == 'X') ? "CPX" : "CPY", byte(iLastNonDefault));    
                    EmitInstruction("BEQ", int(+5));
                    EmitInstruction("BCC", int(+3));
                }
                
                EmitInstructionAbsolute("iJMP", defaultIndex, AddressingModes.Absolute);
                
                uint loadLSBTableAddress = Asm6502.NextAddress;
                EmitInstructionAbsolute("LDA", 0, (registerName == 'X') ? AddressingModes.AbsoluteX : AddressingModes.AbsoluteY);
                EmitInstructionZeroPage("STA", byte(SwitchJumpAddress+0), AddressingModes.ZeroPage);
                
                uint loadMSBTableAddress = Asm6502.NextAddress;
                EmitInstructionAbsolute("LDA", 0, (registerName == 'X') ? AddressingModes.AbsoluteX : AddressingModes.AbsoluteY);
                EmitInstructionZeroPage("STA", byte(SwitchJumpAddress+1), AddressingModes.ZeroPage);
                
                Asm6502.AppendCode(GetJMPIndexInstruction());
                Asm6502.AppendCode(byte(SwitchJumpAddress & 0xFF));
                Asm6502.AppendCode(byte(SwitchJumpAddress >> 8));
                
                uint tableDataAddress = Asm6502.NextAddress;
                Asm6502.PatchJump(loadLSBTableAddress, tableDataAddress, true);
                
                // LSBs
                for (uint ii=0; ii <= iLastNonDefault; ii++)
                {
                    uint methodIndex = jumpList[ii];
                    Asm6502.AppendCode(byte(methodIndex & 0xFF));
                }
                // MSBs
                tableAddress = Asm6502.NextAddress;
                Asm6502.PatchJump(loadMSBTableAddress, tableAddress, true);
                for (uint ii=0; ii <= iLastNonDefault; ii++)
                {
                    uint methodIndex = jumpList[ii];
                    Asm6502.AppendCode(byte(methodIndex >> 8));
                }
            }
            break;
            
        } // loop
        return success;
    }
    
    bool assembleIfStatement()
    {
        bool success = false;
        bool wasElse = false;
        <uint> jumpEnds;
        loop
        {
            Asm6502.InsertDebugInfo(false); // could be a 2nd 'else if'
            
            Parser.Advance(); // if
            
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            
            <string,string> currentToken = Parser.CurrentToken;
            string conditionString = currentToken["lexeme"];
            string bitBranchInstruction;
            byte zeroPageAddress;
            HopperToken tokenType = Token.GetType(currentToken);
            if (tokenType == HopperToken.Instruction) // BBRn or BBSn
            {
                if (AddressingModes.ZeroPageRelative == Asm6502.GetAddressingModes(conditionString))
                {
                    // BBSn or BBRn : flip the condition
                    bitBranchInstruction = conditionString;
                    conditionString = "";
                    Parser.Advance(); // bitBranchInstruction
                    
                    Parser.Consume(HopperToken.Comma);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    
                    uint immediateValue;
                    if(!assembleConstantExpression(ref immediateValue))
                    {
                        break;
                    }
                    if (immediateValue > 255)
                    {
                        Parser.Error("invalid zero page address (0x" + immediateValue.ToHexString(4) + ")");
                        break;
                    }
                    zeroPageAddress = byte(immediateValue);
                }
            }
            if (bitBranchInstruction.Length == 0)
            {
                if (tokenType != HopperToken.Condition)
                {
                    Parser.Error("condition expected");
                    break;
                }  
                Parser.Advance(); // conditionString
            }
            
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            
            if (bitBranchInstruction.Length != 0)
            {
                Asm6502.EmitInstructionZeroPageRelative(bitBranchInstruction, zeroPageAddress, +3);
            }
            else
            {
                Asm6502.AppendCode(GetBInstruction(conditionString));
                Asm6502.AppendCode(+3);
            }
            
            // if false jump past
            uint jumpPast = Asm6502.NextAddress;
            Asm6502.AddInstructionJ();
                       
            Block.PushBlock(false); // not a loop context
            assembleBlock();
            Block.PopBlock();
            if (Parser.HadError)
            {
                break;
            }
            
            Asm6502.InsertDebugInfo(true);
            
            // jump end (past a potential "else" block)
            uint jumpEnd = Asm6502.NextAddress;
            jumpEnds.Append(jumpEnd);
            Asm6502.AddInstructionJ();
// past:    
            uint pastAddress = Asm6502.NextAddress;
            Asm6502.PatchJump(jumpPast, pastAddress);        
                        
            if (Parser.CheckKeyword("else"))
            {
                wasElse = true; // there was at least one else clause
                Advance(); // else
                if (Parser.CheckKeyword("if"))
                {
                    continue; // else if
                }   
                // final else block
                Block.PushBlock(false); // not a loop context
                assembleBlock();
                Block.PopBlock();
            }
// end:     
            if (wasElse)
            {       
                foreach (var jump in jumpEnds)
                {
                    Asm6502.PatchJump(jump, Asm6502.NextAddress);
                }
            }
            else
            {
                // simple if with no "else" clause/s
                uint jumpSize = 3; // this is always a 3 byte jump (for 6502, it could be BRA followed by NOP)
                Asm6502.PopTail(jumpSize);
                Asm6502.PatchJump(jumpPast, pastAddress-jumpSize);
                
            }
            success = true;                    
            break;
        }
        return success;
    }
    bool assembleLoop()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // loop

            Block.PushBlock(true); // loop context
            uint continueAddress = Asm6502.NextAddress;
            
            Block.PushBlock(false); // for block locals
            assembleBlock();
            Block.PopBlock();
            Asm6502.InsertDebugInfo(true);
            
            Asm6502.AddInstructionJ(continueAddress);
            
            uint breakAddress = Asm6502.NextAddress;
            Block.PopBlock(continueAddress, breakAddress);
            if (Parser.HadError)
            {
                break;
            }
            success = true;                    
            break;
        }
        return success;    
    }
    bool assembleReturn()
    {
        bool success = false;
        loop
        {
            Parser.Advance(); // return
            <string,variant> blockContext = Block.GetMethodBlock();
            if (blockContext.Count != 0)
            {
                if (blockContext.Contains("returntype"))
                {
                    Die(0x0B); // not supported yet
                }
            }
            
            // slotsToPop = locals + arguments
            uint slotsToPop = Block.GetLocalsToPop(true, iCurrentOverload == 0);
            Asm6502.AddInstructionRET(slotsToPop);
            success = true;
            break;
        }
        return success;        
    }
    bool assembleBreak()
    {
        bool success = true;
        
        Parser.Advance(); // break;
        
        // - pop all locals till inner loop
        uint slotsToPop = Block.GetBytesToPop(true, false);
        if (slotsToPop > 0)
        {
            Die(0x0B);            
        }
               
        // - jump to current inner loop 'exit'
        uint breakJump = Asm6502.NextAddress;
        Asm6502.AddInstructionJ();
        if (!Block.AddBreakPatch(breakJump))
        {
            Parser.ErrorAtCurrent("'break' must be inside loop block");
            success = false;
        }
        
        return success;
    }
    bool assembleContinue()
    {
        bool success = true;
        
        Parser.Advance(); // continue;
        
        // - pop all locals till inner loop
        uint slotsToPop = Block.GetBytesToPop(true, true);
        if (slotsToPop > 0)
        {
            Die(0x0B);
        }
        // - jump to current inner loop 'next'
        uint continueJump = Asm6502.NextAddress;
        Asm6502.AddInstructionJ();
        if (!Block.AddContinuePatch(continueJump))
        {
            Parser.ErrorAtCurrent("'continue' must be inside loop block");
            success = false;
        }
        
        return success;
    }
    
    bool assembleMethodCall(string methodName)
    {
        bool success = false;
        loop
        {
            Parser.Consume(HopperToken.LParen);
            if (Parser.HadError)
            {
                break;
            }
            Parser.Consume(HopperToken.RParen);
            if (Parser.HadError)
            {
                break;
            }
            string returnType;
            < <string > > arguments;
            if (!methodName.Contains('.'))
            {
                methodName = Types.QualifyMethodName(methodName);
            }
            uint iOverload = Types.FindVisibleOverload(methodName, arguments, ref returnType);
            if (Parser.HadError)
            {
                break;
            }
            
            Symbols.OverloadToCompile(iOverload); // CompileMethodCall(methodName): Setters, function calls, actual method calls
            Symbols.AddFunctionCall(iOverload);   // CompileMethodCall(methodName)
            
            Asm6502.AddInstructionCALL(iOverload);
            success = true;
            break;
        } // loop
        return success;
    }
    bool assembleInstruction6502()
    {
        // 6502 instruction forms:
        //
        // Implied:
        //     RTS
        // Accumulator:
        //     INC A
        // Immediate:
        //     LDA #nn
        // Absolute:
        //     LDA nnnn
        // X-Indexed Absolute:
        //     LDA nnnn,X
        // Y-Indexed Absolute:
        //     LDA nnnn,Y
        // Absolute Indirect:
        //     JMP [nnnn]
        // Absolute X-Indexed Indirect:
        //     JMP [nnnn,X]
        // Zero Page:
        //     LDA nn   (same as LDA 00nn)
        // X-Indexed Zero Page:
        //     LDA nn,X (same as LDA 00nn, X) 
        // Y-Indexed Zero Page:
        //     LDX nn,Y (same as LDA 00nn, Y) 
        // Zero Page Indirect:
        //     LDA [nn]
        // X-Indexed Zero Page Indirect:
        //     LDA [nn,X]
        // Zero Page Indirect Y-Indexed:
        //     LDA [nn],Y
        // Relative:
        //     BEQ dd
        
        bool success = false;
        loop
        {
            <string,string> currentToken = Parser.CurrentToken;
            HopperToken tokenType;
            string instructionName = currentToken["lexeme"];
            Parser.Advance();
            
            currentToken = Parser.CurrentToken;
            tokenType = Token.GetType(currentToken);
            
            AddressingModes addressingModes = Asm6502.GetAddressingModes(instructionName);
            
            if (addressingModes == AddressingModes.Implied)
            {
                Asm6502.EmitInstruction(instructionName);
                success = true;
                break;
            }
            if (addressingModes == AddressingModes.Relative)
            {
                int offset;
                // -128 .. 127
                bool negative;
                if (tokenType == HopperToken.Subtract)
                {
                    Parser.Advance(); // '-' 
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    negative = true; 
                }
                else if (tokenType == HopperToken.Add)
                {
                    Parser.Advance(); // '+'    
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                }
                if ((tokenType == HopperToken.Integer) && Int.TryParse(currentToken["lexeme"], ref offset))
                {
                    Parser.Advance(); // <offset>
                    Asm6502.EmitInstruction(instructionName, negative ? -offset : offset);
                    success = true;
                    break;
                }
                else if (tokenType == HopperToken.Identifier)
                {
                    Parser.Advance(); // label
                    // flip the condition
                    switch (instructionName)
                    {
                        case "BCC": { instructionName = "BCS"; }
                        case "BCS": { instructionName = "BCC"; }
                        case "BEQ": { instructionName = "BNE"; }
                        case "BNE": { instructionName = "BEQ"; }
                        case "BMI": { instructionName = "BPL"; }
                        case "BPL": { instructionName = "BMI"; }
                        case "BVC": { instructionName = "BVS"; }
                        case "BVS": { instructionName = "BVC"; }
                        default:    { NI();                    }
                        
                    }
                    Asm6502.EmitInstruction(instructionName, int(3));
                    string label = (currentToken["lexeme"]).Replace(":", "");
                    labelBranches[Asm6502.NextAddress] = label;
                    Asm6502.EmitInstructionAbsolute("JMP", uint(0), AddressingModes.Absolute);
                    success = true;
                    break;
                }
                else
                {
                    Parser.ErrorAtCurrent("integer offset (-128..127) expected");
                }
                break;
            }
            if ((addressingModes & AddressingModes.Accumulator) == AddressingModes.Accumulator)
            {
                if ((tokenType == HopperToken.Register) && (currentToken["lexeme"] == "A"))
                {
                    Parser.Advance(); // 'A'
                    Asm6502.EmitInstruction(instructionName);
                    success = true;
                    break;
                }
            }
            bool expectImmediate;
            if ((addressingModes & AddressingModes.Immediate) == AddressingModes.Immediate)
            {
                if (tokenType == HopperToken.Hash)
                {
                    Parser.Advance(); // '#'
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    expectImmediate = true;
                }
                if ((tokenType == HopperToken.Identifier) || (tokenType == HopperToken.DottedIdentifier))
                {
                    if ((currentToken["lexeme"]).StartsWith('#'))
                    {
                        expectImmediate = true;
                    }
                }
            }
            bool expectIndirect;
            if ((addressingModes & (AddressingModes.AbsoluteIndirect
                                   |AddressingModes.AbsoluteIndirectX
                                   |AddressingModes.ZeroPageIndirect
                                   |AddressingModes.XIndexedZeroPage
                                   |AddressingModes.YIndexedZeroPage)) != AddressingModes.None)
            {
                if (tokenType == HopperToken.LBracket)
                {
                    Parser.Advance(); // '['
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    expectIndirect = true;
                }
            }
                        
            bool hasImmediate;
            uint immediateValue;
            
            switch (tokenType)
            {
                case HopperToken.Char:
                case HopperToken.Integer:
                case HopperToken.DottedIdentifier:
                case HopperToken.LParen:
                {
                    hasImmediate = assembleConstantExpression(ref immediateValue);
                    if (Parser.HadError)
                    {
                        break;
                    }
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                }
                case HopperToken.Identifier:
                {
                    if (!expectIndirect && (instructionName == "JMP"))
                    {
                        labelBranches[Asm6502.NextAddress] = currentToken["lexeme"];
                        Asm6502.EmitInstructionAbsolute(instructionName, uint(0), AddressingModes.Absolute);
                        Parser.Advance(); // label
                        success = true;
                        break;
                    }
                    else
                    {
                        hasImmediate = assembleConstantExpression(ref immediateValue);
                        if (Parser.HadError)
                        {
                            break;
                        }
                        currentToken = Parser.CurrentToken;
                        tokenType = Token.GetType(currentToken);
                    }
                }
            }
            
            if (expectImmediate)
            {
                if (!hasImmediate || (immediateValue > 255))
                {
                    Parser.Error("immediate byte value expected");
                }
                else
                {
                    Asm6502.EmitInstruction(instructionName, byte(immediateValue));
                    success = true;
                }
                break;
            }
            if (!hasImmediate)
            {
                // Second swing at Accumulator, where we just assume 'A'
                //   There are only 6 instructions that have Accumulator addressing mode and all their
                //   alternate addressing modes would have had an immediate operand next so ...
                if ((addressingModes & AddressingModes.Accumulator) == AddressingModes.Accumulator)
                {
                    Asm6502.EmitInstruction(instructionName);
                    success = true;
                    break;
                }
                Parser.Error("immediate operand expected");
                break;
            }
            
            if ((addressingModes & (AddressingModes.ZeroPageRelative)) == AddressingModes.ZeroPageRelative)
            {
                if (tokenType != HopperToken.Comma)
                {
                    Parser.Error("',' expected");
                    break;
                }
                if (immediateValue > 255)
                {
                    Parser.Error("byte zero page address");
                    break;
                }
                Parser.Advance();
                
                currentToken = Parser.CurrentToken;
                tokenType = Token.GetType(currentToken);
                
                int offset;
                // -128 .. 127
                bool negative;
                if (tokenType == HopperToken.Subtract)
                {
                    Parser.Advance(); // '-' 
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    negative = true; 
                }
                else if (tokenType == HopperToken.Add)
                {
                    Parser.Advance(); // '+'    
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                }
                if ((tokenType == HopperToken.Integer) && Int.TryParse(currentToken["lexeme"], ref offset))
                {
                    Parser.Advance(); // <offset>
                    
                    // ZeroPageRelative=0x8000,          // nn,dd
                    Asm6502.EmitInstructionZeroPageRelative(instructionName, byte(immediateValue), negative ? -offset : offset);
                    
                    success = true;
                    break;
                }
                else if (tokenType == HopperToken.Identifier)
                {
                    Parser.Advance(); // label
                    // flip the condition
                    if (instructionName.StartsWith("BBR"))
                    {
                        instructionName = instructionName.Replace("BBR", "BBS");
                    }
                    if (instructionName.StartsWith("BBS"))
                    {
                        instructionName = instructionName.Replace("BBS", "BBR");
                    }
                    Asm6502.EmitInstructionZeroPageRelative(instructionName, byte(immediateValue), int(3));
                    string label = (currentToken["lexeme"]).Replace(":", "");
                    labelBranches[Asm6502.NextAddress] = label;
                    Asm6502.EmitInstructionAbsolute("JMP", uint(0), AddressingModes.Absolute);
                    success = true;
                    break;
                }
                
                else
                {
                    Parser.ErrorAtCurrent("integer offset (-128..127) expected");
                    break;
                }
            }
            
            char registerName;
            bool rparenConsumed;
            if ((addressingModes & (AddressingModes.AbsoluteIndirectX
                                   |AddressingModes.AbsoluteIndirect
                                   |AddressingModes.XIndexedZeroPage
                                   |AddressingModes.YIndexedZeroPage
                                   |AddressingModes.ZeroPageX
                                   |AddressingModes.ZeroPageY
                                   |AddressingModes.AbsoluteX
                                   |AddressingModes.AbsoluteY
                                   |AddressingModes.ZeroPageRelative
                                   )) != AddressingModes.None)
            {
                if (tokenType == HopperToken.RBracket)
                {
                    if ((addressingModes & (AddressingModes.YIndexedZeroPage|AddressingModes.AbsoluteIndirect)) != AddressingModes.None)
                    {
                        Parser.Advance(); // ']'
                        currentToken = Parser.CurrentToken;
                        tokenType = Token.GetType(currentToken);
                        rparenConsumed = true;
                    }
                }
                if (tokenType == HopperToken.Comma)
                {
                    Parser.Advance(); // ','
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    if ((tokenType != HopperToken.Register) || ((currentToken["lexeme"] != "X") && (currentToken["lexeme"] != "Y")))
                    {
                        Parser.ErrorAtCurrent("index register expected");
                        break;
                    }
                    string registerString = currentToken["lexeme"];
                    registerName = registerString[0];
                    Parser.Advance(); // X|Y
                    currentToken = Parser.CurrentToken;
                    tokenType = Token.GetType(currentToken);
                    
                    //Print(" " + currentToken["line"] + registerName);
                }
                if (tokenType == HopperToken.RBracket)
                {
                    if ((addressingModes & (AddressingModes.XIndexedZeroPage)) == AddressingModes.XIndexedZeroPage)
                    {
                        Parser.Advance(); // ']'
                        currentToken = Parser.CurrentToken;
                        tokenType = Token.GetType(currentToken);
                        rparenConsumed = true;
                    }
                }
            }
                       
            if (immediateValue <= 255)
            {
                byte operand = byte(immediateValue);
                if (expectIndirect)
                {
                    switch (registerName)
                    {
                        case 'X':
                        {
                            if ((addressingModes & (AddressingModes.XIndexedZeroPage)) != AddressingModes.XIndexedZeroPage)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // XIndexedZeroPage=0x1000,  // [nn,X]
                            Asm6502.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.XIndexedZeroPage);
                        }
                        case 'Y':
                        {
                            if ((addressingModes & (AddressingModes.YIndexedZeroPage)) != AddressingModes.YIndexedZeroPage)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // YIndexedZeroPage=0x2000,  // [nn], Y
                            Asm6502.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.YIndexedZeroPage);
                        }
                        default:
                        {
                            if ((addressingModes & (AddressingModes.ZeroPageIndirect)) == AddressingModes.ZeroPageIndirect)
                            {
                                // ZeroPageIndirect=0x0800,  // [nn]
                                Asm6502.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPageIndirect);
                            }
                            else if ((addressingModes & (AddressingModes.AbsoluteIndirect)) == AddressingModes.AbsoluteIndirect)
                            {
                                // JMP [nnnn]
                                if (instructionName != "JMP")
                                {
                                    Parser.ErrorAtCurrent("JMP instruction expected");
                                    break;
                                }
                                Asm6502.EmitInstructionAbsolute("JMP", immediateValue, AddressingModes.AbsoluteIndirect);
                            }
                            else
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                        }
                    }
                }
                else
                {
                    switch (registerName)
                    {
                        case 'X':
                        {
                            if ((addressingModes & (AddressingModes.ZeroPageX)) != AddressingModes.ZeroPageX)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // ZeroPageX=0x0200,         // nn,X
                            Asm6502.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPageX);
                        }
                        case 'Y':
                        {
                            if ((addressingModes & (AddressingModes.ZeroPageY)) != AddressingModes.ZeroPageY)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // ZeroPageY=0x0400,         // nn,Y
                            Asm6502.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPageY);
                        }
                        default:
                        {
                            if ((addressingModes & (AddressingModes.ZeroPage)) == AddressingModes.ZeroPage)
                            {
                                // ZeroPage=0x0100,          // nn
                                Asm6502.EmitInstructionZeroPage(instructionName, byte(immediateValue), AddressingModes.ZeroPage);
                            }
                            else
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                        }
                    }
                }
            }
            else // > 255
            {
                uint operand = immediateValue;
                if (expectIndirect)
                {
                    if (registerName == 'X')
                    {
                        if ((addressingModes & (AddressingModes.AbsoluteIndirectX)) != AddressingModes.AbsoluteIndirectX)
                        {
                            Parser.Error("internal error"); Die(0x0B);
                        }
                        // AbsoluteIndirectX=0x0080, // [nnnn,X]
                        Asm6502.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteIndirectX);
                    }
                    else
                    {
                        if ((addressingModes & (AddressingModes.AbsoluteIndirect)) != AddressingModes.AbsoluteIndirect)
                        {
                            Parser.Error("internal error"); Die(0x0B);
                        }
                        // AbsoluteIndirect=0x0040,  // [nnnn]
                        Asm6502.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteIndirect);
                    }
                }
                else
                {
                    switch (registerName)
                    {
                        case 'X':
                        {
                            if ((addressingModes & (AddressingModes.AbsoluteX)) != AddressingModes.AbsoluteX)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // AbsoluteX=0x0020,         // nnnn,X
                            Asm6502.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteX);
                        }
                        case 'Y':
                        {
                            if ((addressingModes & (AddressingModes.AbsoluteY)) != AddressingModes.AbsoluteY)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // AbsoluteY=0x0010,         // nnnn,Y
                            Asm6502.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.AbsoluteY);
                        }
                        default:
                        {
                            if ((addressingModes & (AddressingModes.Absolute)) != AddressingModes.Absolute)
                            {
                                Parser.Error("internal error"); Die(0x0B);
                            }
                            // Absolute=0x0008,          // nnnn
                            Asm6502.EmitInstructionAbsolute(instructionName, immediateValue, AddressingModes.Absolute);
                        }
                    }
                }
            }
            
            success = true;
            if (expectIndirect && !rparenConsumed)
            {
                Parser.Consume(HopperToken.SemiColon);
                if (Parser.HadError)
                {
                    success = false;
                }
            }
            break;
        }
        return success;
    }
    
    bool assembleStatement(bool noSemiColon, bool debugInfoInsert)
    {
        bool success = false;
        <string,string> currentToken = Parser.CurrentToken;
        string tokenString = currentToken["lexeme"];
        HopperToken tokenType = Token.GetType(currentToken);
        if (debugInfoInsert)
        {
            Asm6502.InsertDebugInfo(false);
        }
        
        switch (tokenType)
        {
            case HopperToken.Keyword:
            {
                if (tokenString == "if")
                {
                    success = assembleIfStatement();
                    noSemiColon = true;
                }
                else if (tokenString == "switch")
                {
                    success = assembleSwitchStatement();
                    noSemiColon = true;
                }
                else if (tokenString == "return")
                {
                    success = assembleReturn();
                }
                else if (tokenString == "break")
                {
                    success = assembleBreak();
                }
                else if (tokenString == "continue")
                {
                    success = assembleContinue();
                }
                else if (tokenString == "loop")
                {
                    success = assembleLoop();
                    noSemiColon = true;
                }
                else
                {
                    // simple type
                    Parser.ErrorAtCurrent("no local declarations in assembly");
                }
            }
            case HopperToken.Instruction:
            {
                success = assembleInstruction6502();
                noSemiColon = true;
            }
            case HopperToken.LabelIdentifier:
            {
                Advance(); // label:
                string label = (currentToken["lexeme"]).Replace(":", "");
                if (labelLocations.Contains(label))
                {
                    Parser.ErrorAtCurrent("duplicate label");
                }
                else
                {
                    labelLocations[label] = Asm6502.NextAddress;
                    Asm6502.InsertLabel(label);
                    noSemiColon = true;
                    success = true;
                }
            }
            default:
            {
                if (   (tokenType == HopperToken.Identifier) 
                    || (tokenType == HopperToken.DottedIdentifier)
                    || (tokenType == HopperToken.Discarder)
                   )
                {
                    bool isDotted    = (tokenType == HopperToken.DottedIdentifier);
                    HopperToken nextTokenType = Parser.PeekTokenType();
                    if (Types.IsEnum(tokenString) || Types.IsFlags(tokenString))
                    {
                        Parser.ErrorAtCurrent("no local declarations in assembly");
                    }
                    else if (nextTokenType == HopperToken.Identifier)
                    {
                        Parser.ErrorAtCurrent("no local declarations in assembly");
                    }
                    else
                    {
                        Advance();
                        <string,string> idToken   = Parser.PreviousToken;
                        tokenString = idToken["lexeme"];
                        tokenType = Token.GetType(Parser.CurrentToken);
                        if (tokenType == HopperToken.LParen)
                        {
                            // method call
                            success = assembleMethodCall(tokenString);
                        }
                        else
                        {
                            if (!Parser.HadError)
                            {
                                Parser.ErrorAtCurrent("'(' expected");
                            }
                        }
                    }
                }
                else
                {
                    // failed
                }
            }
        } // switch (tokenType)
        if (success && !noSemiColon)
        {
            Parser.Consume(HopperToken.SemiColon);
            if (Parser.HadError)
            {
                success = false;
            }
        }
        return success;
    }
    
    assembleBlock()
    {
        loop
        {
            if (!Parser.Check(HopperToken.LBrace))
            {
                Parser.ErrorAtCurrent('{');
                break;
            }
            
            Parser.Advance(); // {
            loop
            {
                // next statement ..
                if (Parser.HadError)
                {
                    break;
                }
                if (Parser.Check(HopperToken.Directive))
                {
                    // preprocessor directives (#ifdef, #ifndef, #else, #endif")
                    Directives.Directive();
                }
                else
                {
                    // not directive
                    bool allDefined = Directives.IsAllDefined();
                    if (!allDefined)
                    {
                        loop
                        {
                            if (Parser.Check(HopperToken.Directive))
                            {
                                break;
                            }
                            if (Parser.Check(HopperToken.EOF))
                            {
                                break;
                            }
                            Parser.Advance(); // gobble gobble
                        }
                    }
                    else if (Parser.Check(HopperToken.RBrace))
                    {
                        Advance(); // }
                        break; // end of method
                    }
                    else
                    {      
                        <string,string> currentToken = Parser.CurrentToken;
                        HopperToken tokenType = Token.GetType(currentToken);
                        if (   (tokenType == HopperToken.Keyword)           // "if", "loop", "switch" ...
                            
                            || (tokenType == HopperToken.Identifier)        // procedure call
                            || (tokenType == HopperToken.DottedIdentifier) 
                            
                            || (tokenType == HopperToken.Instruction)
                            || (tokenType == HopperToken.LabelIdentifier)   // label:
                            )
                        {
                            if (!assembleStatement(false, true))
                            {
                                if (!Parser.HadError)
                                {
                                    Parser.ErrorAtCurrent("bad statement?");
                                }
                                break;
                            }
                        }
                        else if (tokenType == HopperToken.LBrace)
                        {
                            Asm6502.InsertDebugInfo(false);
                            if (!assembleBlockScope())
                            {
                                if (!Parser.HadError)
                                {
                                    Parser.ErrorAtCurrent("bad 'block' statement?");
                                }
                                break;
                            }
                        }
                        else
                        {
                            DumpPrevious();
                            DumpCurrent();
                            Parser.ErrorAt(currentToken, "keyword or identifier expected");
                            break;
                        }
                    }
                }   
            } // loop
            break;
        } // loop
    }
    
    
    bool assemble()
    {
        <byte> globalCode = initializeGlobals();
        
        
        
        
        bool success = false;
        bool isMain = true;
        uint iMain = iCurrentOverload;
        loop
        {
            if (HadError)
            {
                break;
            }
            
            // compile fIndex
            <string, string> startToken = Symbols.GetOverloadStart(iCurrentOverload);
            Scanner.Reset(startToken);
            Parser.Reset();
            Directives.New();
            Asm6502.New();
            
            if (globalCode.Count != 0)
            {
                Asm6502.AppendCode(globalCode);
                globalCode.Clear();
            }
            
            Types.SetCurrentMethod(iCurrentOverload);
                                                                                                                                                                    
            Parser.Advance(); // load first token
            
            <string,string> braceToken = Parser.CurrentToken; // for CodeGen location
            
            if (isMain)
            {
                Asm6502.AddInstructionRESET();
            }
            Asm6502.AddInstructionENTER();
            if (!isMain) // already pushed with globals
            {
                Block.PushBlock(false); // new block context
            }
            
            <string,variant> blockContext = Block.Top();
            < < string > > arguments = Symbols.GetOverloadArguments(iCurrentOverload);
            if (arguments.Count != 0)
            {
                Die(0x0B); // no return types in Assembly : preprocess should catch this
            }
            blockContext["arguments"] = arguments;
            blockContext["iOverload"] = iCurrentOverload.ToString();
            string returnType = Symbols.GetOverloadReturnType(iCurrentOverload);
            if (returnType != "void")
            {                    
                Die(0x0B); // no return types in Assembly : preprocess should catch this
            }
            Block.ReplaceTop(blockContext);
            
            labelLocations.Clear();
            labelBranches.Clear();
                     
            assembleBlock();
            if (Parser.HadError)
            {
                break;
            }
            
            foreach (var kv in labelBranches)
            {
                string label = kv.value;
                if (!labelLocations.Contains(label))
                {
                    Parser.ErrorAtCurrent("undefined label '" + label + "'");
                    break;
                }
                uint jumpAddress    = kv.key;
                uint jumpToAddress  = labelLocations[label];
                Asm6502.PatchJump(jumpAddress, jumpToAddress);
            }
            
            if (Parser.HadError)
            {
                break;
            }
            
            Parser.ProgressTick(".");
            
            // check that #ifdef nesting is zero
            if (Directives.IsStillOpen)
            {
                Parser.ErrorAtCurrent("'#endif' expected before end of method");
                break;
            }
            
            <string,string> previousToken = Parser.PreviousToken;
            HopperToken tokenType = Token.GetType(previousToken);
            if (tokenType != HopperToken.RBrace)
            {
                DumpCurrent();
                DumpPrevious();
                Parser.Error("'}' expected in assemble()!!");
                Die(0x0B);
            }
            
            Asm6502.InsertDebugInfo(true);
            
            uint slotsToPop = Block.GetLocalsToPop(true, isMain);
            Asm6502.AddInstructionRET(slotsToPop);
            
            if (!isMain)
            {
                Block.PopBlock();
            }
            else
            {
                Block.Export(0);
                
                // pop "main" locals and arguments but keep globals
                <string,variant> mainContext = Block.Top();
                < <string> > empty;
                mainContext["locals"] = empty;
                mainContext["arguments"] = empty;
                Block.ReplaceTop(mainContext);
            }
            
            <byte> asmStream = Asm6502.CurrentStream;
            <string,string> debugInfo = Asm6502.DebugInfo;
            <string,string> labelInfo = Asm6502.LabelInfo;
            Symbols.SetCodeStream(iCurrentOverload, asmStream, debugInfo, labelInfo);
            Asm6502.ClearDebugInfo();
            
            Symbols.OverloadWasCompiled(iCurrentOverload);         
            if (!Symbols.OverloadNextToCompile(ref iCurrentOverload))
            {
                success = true; // all done
                break;
            }
            isMain = false;
            
        } // loop 
        iCurrentOverload = iMain;
        Types.SetCurrentMethod(iCurrentOverload);
        return success;               
    }
    
    Hopper()
    {
        bool success = false;
        loop
        {
            <string> rawArgs = System.Arguments;
            <string> args;
            bool checkedBuild = true;
            bool touchesTree = false;
          
            for (uint iArg = 0; iArg < rawArgs.Count; iArg++)
            {
                string arg = rawArgs[iArg];
                if ((arg.Length == 2) && (arg[0] == '-'))
                {
                    arg = arg.ToLower();
                    switch (arg)
                    {
                        case "-g":
                        {
                            uint col;
                            uint row;
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref col))
                            {
                            }
                            iArg++;
                            if (UInt.TryParse(rawArgs[iArg], ref row))
                            {
                            }
                            Parser.SetInteractive(byte(col), byte(row));
                        }
                        case "-x":
                        {
                            isExperimental = true;   
                        }
                        default:
                        {
                            args.Clear();
                            break;
                        }
                    }
                }
                else
                {
                    args.Append(arg);
                }
            }
          
            if (args.Count != 1)
            {
                badArguments();
                break;
            }
            
            string jsonPath = args[0];
            string ext = ".sym";
            if (!File.Exists(ref jsonPath, ref ext, "/Debug/Obj/"))
            {
                badArguments();
            }
            
            long startTime = Millis;
            loop
            {
                Symbols.New();
                if (!Symbols.Import(jsonPath))
                {
                    break;
                }
                isExperimental       = isExperimental || Symbols.DefineExists("EXPERIMENTAL");
                Architecture = CPUArchitecture.M6502; 
                IsTiggerC = Symbols.DefineExists("TIGGERC");
                if (Symbols.DefineExists("CPU_6809"))
                {
                    Architecture = CPUArchitecture.M6809;
                }
                else if (Symbols.DefineExists("ROM_16K"))
                {
                    Asm6809.SetOrg(0xC000);
                }
                else if (Symbols.DefineExists("ROM_8K"))
                {
                    Asm6809.SetOrg(0xE000);
                }
                else if (Symbols.DefineExists("ROM_4K"))
                {
                    Asm6809.SetOrg(0xF000);
                }
                else if (Symbols.DefineExists("ROM_1K"))
                {
                    Asm6509.SetOrg(0xFC00);
                }
                else
                {
                    Asm6809.SetOrg(0x8000); // assume 32K ROM
                }
                
                uint mIndex;
                if (!Symbols.GetFunctionIndex("Hopper", ref mIndex))
                {
                    Parser.Error("where is 'Hopper()'?");
                    break;
                }
                <uint> mOverloads = Symbols.GetFunctionOverloads(mIndex);
                if (mOverloads.Count != 1)
                {
                    Parser.Error("'Hopper()' has overloads?");
                    break;
                }
                
                Scanner.New();
                Token.InitializeAssembler(Architecture);
                
                
                iHopper = mOverloads[0];
                Symbols.AddFunctionCall(iHopper); // yup, main is called at least once
                
                uint iIndex;
                uint nIndex;
                
                if (Symbols.GetFunctionIndex("IRQ", ref iIndex))
                {
                    mOverloads = Symbols.GetFunctionOverloads(iIndex);
                    if (mOverloads.Count != 1)
                    {
                        Parser.Error("'IRQ' has overloads?");
                        break;
                    }
                    iIRQ = mOverloads[0];
                    Symbols.OverloadToCompile(iIRQ);
                    Symbols.AddFunctionCall(iIRQ);
                }
                if (Symbols.GetFunctionIndex("NMI", ref nIndex))
                {
                    mOverloads = Symbols.GetFunctionOverloads(nIndex);
                    if (mOverloads.Count != 1)
                    {
                        Parser.Error("'NMI' has overloads?");
                        break;
                    }
                    iNMI = mOverloads[0];
                    Symbols.OverloadToCompile(iNMI);
                    Symbols.AddFunctionCall(iNMI);
                }

                // start with iHopper
                iCurrentOverload = iHopper;
                Block.PushBlock(false); // new block context
                if (!assemble()) 
                {
                    break;
                }
                Block.PopBlock();
                
                string extension = Path.GetExtension(jsonPath);
                string codePath = jsonPath.Replace(extension, ".code");
                if (!Symbols.ExportCode(codePath, Asm6502.GetConstantStream()))
                {
                    break;
                }
                
                if (!IsInteractive())
                {
                    PrintLn();
                    Print("Success.", Colour.ProgressText, Colour.ProgressFace);
                    long elapsedTime = Millis - startTime;
                    float seconds = elapsedTime / 1000.0;
                    PrintLn("  " + seconds.ToString() + "s", Colour.ProgressHighlight, Colour.ProgressFace);
                }
                else
                {
                    Parser.ProgressDone();
                }
                success = true;
                break;
            } // main loop
            break;
        } // argument loop
        if (!success)
        {
            Diagnostics.SetError(0x0E);
        }
    }
}
